---
# type: docs 
title: 动态规划
date: 2025-03-23T13:50:16+08:00
featured: false
draft: true
comment: true
toc: true
reward: true
pinned: false
carousel: false
series:
categories: []
tags: []
images: []
---

# 引例

设有无限多的硬币，面值分别为1，2，5，10，20，50，100。

对给定的数额w，问最少需要多少枚硬币可以凑出w？

> 贪心算法：每次选择面值最大的硬币，直到凑出w。

但是，这种贪心算法不一定是最优的。

若硬币面值为1，5，11 。 对于数额15，贪心算法会选择11，1*4，但是最优解是 5\*3。

贪心算法第一步选择了11，导致了后续我们需要面对w=4的情况。

但是如果不使用贪心算法，使用枚举，复杂度又太高了。

## 性质

若硬币面值为1，5，11 。

我们记“凑出w的最少硬币数”为f(w)。

我们会发现f(n)只与f(n-1), f(n-5), f(n-11)有关。

即f(n) = min(f(n-1), f(n-5), f(n-11)) + 1。

这就是一个动态规划问题。

动态规划能比枚举法更快是因为它舍弃了无关的计算。

# 动态规划（Dynamic Programming）

动态规划是一种解决重复子问题的算法。

它将一个问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

## 无后效性

动态规划的无后效性是指，某个状态以前的过程不会影响以后的状态，只与当前状态有关。

即中间的某一步的决策，不会影响到后面的决策，也不会被前面的决策影响。

## 最优子结构

动态规划的最优子结构是指，问题的最优解包含子问题的最优解。

即某个问题的最优解，包含了其子问题的最优解。

回忆例题中我们对f(n)的定义，f(n) = min(f(n-1), f(n-5), f(n-11)) + 1。

f(n)的最优解包含了f(n-1), f(n-5), f(n-11)的最优解。

利用w=14,10,4的最优解，我们可以得到w=15的最优解。

## 状态转移方程

动态规划的状态转移方程是指，从一个状态到另一个状态的转移方式。

即某个状态到另一个状态的转移方式。

回忆例题中我们对f(n)的定义，f(n) = min(f(n-1), f(n-5), f(n-11)) + 1。

## DP为什么会快？

无论是DP还是暴力枚举，都是在可能的解空间内寻找最优解。

但是DP只会在可能的解空间内寻找最优解，而暴力枚举会在所有可能的解空间内寻找最优解。

DP会舍弃一大堆不可能成为最优解的答案，相当于自带剪枝。

**DP的核心**：尽可能的缩小可能的解空间。

## 设计DP算法

首先，把我们面对的局面表示为x，这一步成为设计状态。对于状态x，记我们要求的答案（即最优值）为f(x)。而我们的目标则是求出f(T)。

找出f(x)与哪些局面有关（记为p），写出状态转移方程（记为g）。

设f(p)已知，根据g求出f(x)。

### DP三连

我是谁？ --> 设计状态，表示局面

我从哪里来？ --> 找出与哪些局面有关

我要到哪里去？ --> 写出状态转移方程

# 例题

## 最大子段和

给定一个长度为n的数列A，求子段和的最大值。

例如：

$A = \{1, -2, 3, 10, -4, 7, 2, -5\}$

最大子段和为18，即$3, 10, -4, 7, 2$。

### 暴力枚举

枚举所有子段，计算子段和，取最大值。

时间复杂度：$O(n^3)$

### 前缀和

枚举所有子段，计算子段和，取最大值。

时间复杂度：$O(n^2)$

### DP

设$f(i)$为以第i个元素结尾的最大子段和。

则$f(i) = max(f(i-1) + A[i], A[i])$。

时间复杂度：$O(n)$