[{"authors":[],"categories":[],"content":" 本页面主要用于记录期末复习纲要，方便复习。\n本页面仅作为参考，不保证内容的准确性。\nGenerated by Gemini.\n23《高等数学Ⅰ(2)》(理工)期末试卷一》知识点复习纲要 总览与复习策略建议：\n这份试卷体现了对学生数学基础知识的全面掌握、概念理解的深度、计算能力的准确性以及解决实际（数学）问题的能力的综合考查。复习时，建议采取“点-线-面”结合的方式：\n点： 掌握每一个核心定义、定理、公式。 线： 理解不同知识点之间的联系和推导，形成逻辑链条。 面： 将知识点放入整体框架中，理解其在数学体系中的地位和应用。 训练： 大量练习，提高计算熟练度和解题速度，并养成严谨的解题习惯。 一、向量代数与空间解析几何 （对应试卷：填空1，选择1）\n1. 向量的基本概念与运算\n核心概念： 向量（方向与大小），零向量，单位向量，位置向量。 向量的线性运算： 加法、减法、数乘。几何意义（平行四边形法则、三角形法则）。 数量积（点积）： 定义： $\\vec{a} \\cdot \\vec{b} = |\\vec{a}| |\\vec{b}| \\cos\\theta$，其中 $\\theta$ 为两向量夹角。 坐标表示： $\\vec{a} = (a_x, a_y, a_z)$, $\\vec{b} = (b_x, b_y, b_z)$，则 $\\vec{a} \\cdot \\vec{b} = a_x b_x + a_y b_y + a_z b_z$。 性质： 交换律：$\\vec{a} \\cdot \\vec{b} = \\vec{b} \\cdot \\vec{a}$ 分配律：$\\vec{a} \\cdot (\\vec{b} + \\vec{c}) = \\vec{a} \\cdot \\vec{b} + \\vec{a} \\cdot \\vec{c}$ 结合律（与数乘）：$(k\\vec{a}) \\cdot \\vec{b} = k(\\vec{a} \\cdot \\vec{b})$ 自身点积： $\\vec{a} \\cdot \\vec{a} = |\\vec{a}|^2$。这是计算向量模（长度）的关键。 垂直条件： $\\vec{a} \\perp \\vec{b} \\iff \\vec{a} \\cdot \\vec{b} = 0$ (若 $\\vec{a}, \\vec{b}$ 均为非零向量)。 几何意义： 投影（$\\vec{a}$ 在 $\\vec{b}$ 上的投影为 $|\\vec{a}|\\cos\\theta = \\frac{\\vec{a} \\cdot \\vec{b}}{|\\vec{b}|}$）。 向量积（叉积）： 定义： $\\vec{a} \\times \\vec{b}$ 是一个向量，其模为 $|\\vec{a}| |\\vec{b}| \\sin\\theta$，方向由右手定则确定，垂直于 $\\vec{a}$ 和 $\\vec{b}$ 构成的平面。 坐标表示： 行列式形式。 性质： 反交换律，分配律，结合律（与数乘）。 平行条件： $\\vec{a} \\parallel \\vec{b} \\iff \\vec{a} \\times \\vec{b} = \\vec{0}$。 几何意义： 模表示由两向量构成的平行四边形面积。 混合积： 表示平行六面体的体积。 【试题关联：填空1】\n考查点积的性质：$\\vec{a} \\cdot \\vec{a} = |\\vec{a}|^2$ 和垂直条件 $\\vec{a} \\cdot \\vec{b} = 0$。 解题思路： $(2\\vec{a}+\\vec{b}) \\cdot (2\\vec{a}+\\vec{b}) = (2\\vec{a}) \\cdot (2\\vec{a}) + 2(2\\vec{a}) \\cdot \\vec{b} + \\vec{b} \\cdot \\vec{b} = 4|\\vec{a}|^2 + 4(\\vec{a} \\cdot \\vec{b}) + |\\vec{b}|^2$。代入已知条件即可。 2. 空间直线与平面方程\n平面的方程： 一般式： $Ax + By + Cz + D = 0$。其法向量为 $\\vec{n} = (A, B, C)$。 点法式： $A(x-x_0) + B(y-y_0) + C(z-z_0) = 0$ (过点 $(x_0, y_0, z_0)$，法向量 $\\vec{n}=(A,B,C)$)。 直线的方程： 一般式（两平面交线）： $\\begin{cases} A_1x + B_1y + C_1z + D_1 = 0 \\ A_2x + B_2y + C_2z + D_2 = 0 \\end{cases}$ 点向式（对称式）： $\\frac{x-x_0}{l} = \\frac{y-y_0}{m} = \\frac{z-z_0}{n}$ (过点 $(x_0, y_0, z_0)$，方向向量 $\\vec{s}=(l,m,n)$)。 参数式： $\\begin{cases} x = x_0 + lt \\ y = y_0 + mt \\ z = z_0 + nt \\end{cases}$。 直线与平面的关系： 垂直： 直线的方向向量平行于平面的法向量。 平行： 直线的方向向量垂直于平面的法向量。 相交： 通过联立方程求解。 【试题关联：选择1】\n考查直线与平面垂直的条件：直线的方向向量就是平面的法向量。 解题思路： 平面方程 $x-3y+2z+5=0$ 的法向量是 $\\vec{n}=(1, -3, 2)$。通过原点 $(0,0,0)$ 且垂直于该平面的直线，其方向向量即为 $\\vec{n}$。因此直线方程为 $\\frac{x-0}{1} = \\frac{y-0}{-3} = \\frac{z-0}{2}$。 【易错点与提醒】\n点积和叉积的几何意义和计算公式要区分清楚。 判断向量平行和垂直的条件不要混淆（点积为0 vs 叉积为0）。 在写直线和平面方程时，注意所需的点和向量的类型（方向向量 vs 法向量）。 二、多元函数微分学 （对应试卷：填空2，选择2，选择3，解答4）\n1. 多元函数的概念\n定义域、值域、曲面、等高线（等值面）。 2. 偏导数与全微分\n偏导数： 对其中一个变量求导，将其他变量视为常数。 几何意义： 沿着坐标轴方向的切线斜率。 高阶偏导数： 混合偏导数（二阶导数顺序无关的条件）。 定理： 若 $f_{xy}$ 和 $f_{yx}$ 在某点连续，则在该点 $f_{xy} = f_{yx}$。 全微分： $dz = \\frac{\\partial z}{\\partial x} dx + \\frac{\\partial z}{\\partial y} dy$。 几何意义： 曲面在某点切平面上 $z$ 的增量。 近似计算： $f(x+\\Delta x, y+\\Delta y) \\approx f(x,y) + df$。 3. 多元函数的连续性、可偏导性、可微性\n概念辨析： 存在偏导数 $\\nRightarrow$ 连续 $\\nRightarrow$ 可微。 可微 $\\Rightarrow$ 连续 $\\Rightarrow$ 存在偏导数。 偏导数存在且连续 $\\Rightarrow$ 可微。 【试题关联：选择2】 考查对这些概念之间关系的理解。选择D是正确答案，因为偏导数存在只能保证函数在沿坐标轴方向上是光滑的，不能保证其他方向，因此不能推出连续性和可微性。 4. 隐函数求导\n直接法： 将隐函数视为复合函数，利用链式法则。 公式法： 若 $F(x,y)=0$ 确定 $y$ 是 $x$ 的隐函数，则 $\\frac{dy}{dx} = -\\frac{F_x}{F_y}$。 若 $F(x,y,z)=0$ 确定 $z$ 是 $x,y$ 的隐函数，则 $\\frac{\\partial z}{\\partial x} = -\\frac{F_x}{F_z}$, $\\frac{\\partial z}{\\partial y} = -\\frac{F_y}{F_z}$。 5. 复合函数求导（链式法则）\n核心： 搞清自变量、中间变量、因变量之间的依赖关系，画出变量关系图。 【试题关联：选择3】 考查复合函数的高阶偏导数。 $z = f(r)$, $r = \\sqrt{x^2+y^2}$。 $\\frac{\\partial z}{\\partial x} = \\frac{dz}{dr} \\frac{\\partial r}{\\partial x} = f\u0026rsquo;(r) \\frac{x}{\\sqrt{x^2+y^2}} = f\u0026rsquo;(r) \\frac{x}{r}$。 $\\frac{\\partial^2 z}{\\partial x^2} = \\frac{\\partial}{\\partial x} (f\u0026rsquo;(r) \\frac{x}{r}) = f\u0026rsquo;\u0026rsquo;(r) \\frac{\\partial r}{\\partial x} \\frac{x}{r} + f\u0026rsquo;(r) \\frac{\\partial}{\\partial x}(\\frac{x}{r})$ $= f\u0026rsquo;\u0026rsquo;(r) \\frac{x}{r} \\frac{x}{r} + f\u0026rsquo;(r) \\frac{r \\cdot 1 - x \\cdot (x/r)}{r^2} = f\u0026rsquo;\u0026rsquo;(r) \\frac{x^2}{r^2} + f\u0026rsquo;(r) \\frac{r^2-x^2}{r^3} = f\u0026rsquo;\u0026rsquo;(r) \\frac{x^2}{r^2} + f\u0026rsquo;(r) \\frac{y^2}{r^3}$。 同理，$\\frac{\\partial^2 z}{\\partial y^2} = f\u0026rsquo;\u0026rsquo;(r) \\frac{y^2}{r^2} + f\u0026rsquo;(r) \\frac{x^2}{r^3}$。 相加即可得到结果。这是在极坐标系中求解拉普拉斯算子的前置知识。 6. 曲面的切平面与法线\n对于 $z=f(x,y)$ 形式： 切平面方程：$z - z_0 = f_x(x_0,y_0)(x-x_0) + f_y(x_0,y_0)(y-y_0)$。 法线方程：$\\frac{x-x_0}{f_x(x_0,y_0)} = \\frac{y-y_0}{f_y(x_0,y_0)} = \\frac{z-z_0}{-1}$。 对于 $F(x,y,z)=0$ 形式（水平集/等值面）： 梯度向量： $\\nabla F = (\\frac{\\partial F}{\\partial x}, \\frac{\\partial F}{\\partial y}, \\frac{\\partial F}{\\partial z})$。梯度向量垂直于等值面。 切平面方程： $F_x(x_0,y_0,z_0)(x-x_0) + F_y(x_0,y_0,z_0)(y-y_0) + F_z(x_0,y_0,z_0)(z-z_0) = 0$。 法线方程： $\\frac{x-x_0}{F_x(x_0,y_0,z_0)} = \\frac{y-y_0}{F_y(x_0,y_0,z_0)} = \\frac{z-z_0}{F_z(x_0,y_0,z_0)}$。 【试题关联：填空2】 考查 $F(x,y,z)=0$ 形式的切平面方程。 解题思路： 将曲面方程 $3x^2 - 2y^2 + z^2 - 2z = 0$ 视为 $F(x,y,z)=0$。 求偏导：$F_x = 6x$, $F_y = -4y$, $F_z = 2z-2$。 在点 $(1,1,1)$ 处求值：$F_x(1,1,1)=6$, $F_y(1,1,1)=-4$, $F_z(1,1,1)=0$。 代入切平面方程：$6(x-1) - 4(y-1) + 0(z-1) = 0$，化简得 $6x - 4y - 2 = 0$，即 $3x - 2y - 1 = 0$。 7. 多元函数极值\n无条件极值： 驻点： 令所有一阶偏导数等于零，解出 $(x,y)$。 第二偏导数判别法： 设 $A = f_{xx}$, $B = f_{xy}$, $C = f_{yy}$。 判别式 $\\Delta = AC - B^2$。 若 $\\Delta \u0026gt; 0, A \u0026gt; 0$：极小值。 若 $\\Delta \u0026gt; 0, A \u0026lt; 0$：极大值。 若 $\\Delta \u0026lt; 0$：鞍点。 若 $\\Delta = 0$：无法判断，需另行分析。 【试题关联：解答4】 考查无条件极值的求解。 解题思路： 按照上述步骤，先求一阶偏导并置零求驻点，再求二阶偏导计算判别式，最后根据判别式判断极值类型。注意对分母为 $x$ 的项求导时不要出错。 【易错点与提醒】\n可微性、连续性、偏导数存在性之间的关系是常考陷阱。 复合函数求导时，要理清变量依赖关系，防止漏项或多项。 求极值时，二阶偏导判别法的条件和结论要记清楚。当 $\\Delta=0$ 时，不能简单下结论，需要特殊考虑。 三、重积分 （对应试卷：填空3，选择4，解答1）\n1. 二重积分\n几何意义： 曲顶柱体的体积。 计算方法： 直角坐标系下： 化为累次积分 $\\iint_D f(x,y) dx dy$ 或 $\\iint_D f(x,y) dy dx$。 积分区域的表示： 区域类型、边界曲线。绘制区域图是关键。 改变积分次序： 必须重新描绘积分区域并确定新的积分限。 【试题关联：填空3】 考查改变积分次序。 原积分限： $0 \\le y \\le 1$, $0 \\le x \\le y$。 积分区域： 直线 $x=0$, $y=1$, $x=y$ 围成的三角形区域。 改变次序后： 先对 $y$ 积分，后对 $x$ 积分。 $x$ 从 $0$ 到 $1$。 对于固定的 $x$， $y$ 从 $x$ 到 $1$。 $\\int_0^1 dy \\int_0^y e^{x^2} dx$ 应该改为 $\\int_0^1 dx \\int_x^1 e^{x^2} dy$。 核心： 题目写错了积分顺序！原题是 $\\int_0^1 dy \\int_0^y e^{x^2} dx$，这个内积分是无法用初等函数积出的。正确写法应该是 $\\int_0^1 dx \\int_x^1 e^{y^2} dy$ 或者 $\\int_0^1 dy \\int_y^1 e^{x^2} dx$。 试卷给出的答案 $(e-1)/2$ 提示可能是 $\\int_0^1 dx \\int_x^1 e^{y^2} dy$ 或类似的。 如果题目是 $\\int_0^1 dx \\int_x^1 e^{y^2} dy$ 那就是 $\\int_0^1 (e^{y^2}y|_x^1) dx = \\int_0^1 (e^{y^2}y) |_x^1 dx$ 这个也是不方便计算的。 如果题目是 $\\int_0^1 dx \\int_x^1 y e^{x^2} dy$ 呢？ 那就是 $\\int_0^1 (\\frac{1}{2}y^2 e^{x^2})|_x^1 dx = \\int_0^1 \\frac{1}{2}(1-x^2)e^{x^2} dx$ 也不好算。 如果题目是 $\\int_0^1 dy \\int_0^y x e^{y^2} dx$ 呢？ 那么 $\\int_0^1 (\\frac{1}{2}x^2 e^{y^2})|_0^y dy = \\int_0^1 \\frac{1}{2}y^2 e^{y^2} dy$ 也不好算。 重新审视原题的答案和形式： $e^{x^2}$ 的原函数不是初等函数。这说明积分次序的改变是必须的。原题的内积分对 $x$ 积分，但被积函数是 $e^{x^2}$，这在初等函数范围内无法积分。这意味着 $e^{x^2}$ 实际上是 $e^{y^2}$ 或者其他的形式。结合答案 $(e-1)/2$，最常见的考法是把 $e^{x^2}$ 变成 $e^{y^2}$，然后改变积分次序。 假设原题是 $\\int_0^1 dy \\int_0^y e^{y^2} dx$。 内积分：$\\int_0^y e^{y^2} dx = x e^{y^2} |_0^y = y e^{y^2}$。 外积分：$\\int_0^1 y e^{y^2} dy$。令 $u=y^2$, $du=2y dy$。 $= \\int_0^1 e^u \\frac{1}{2} du = \\frac{1}{2} e^u |_0^1 = \\frac{1}{2} (e^1 - e^0) = \\frac{e-1}{2}$。 结论： 题目应该是 $\\int_0^1 dy \\int_0^y e^{y^2} dx$。 极坐标系下： 坐标变换： $x = \\rho \\cos\\theta, y = \\rho \\sin\\theta, dx dy = \\rho d\\rho d\\theta$ (Jacobian 行列式)。 适用场景： 积分区域是圆、圆环、扇形等与圆相关的区域；被积函数含有 $x^2+y^2$ 项。 【试题关联：选择4】 考查二重积分的极坐标变换。 区域 $D$： $1 \\le x^2+y^2 \\le 4$, $y \\ge 0$。这是上半平面半径为1和2的同心圆环。 极坐标限： $\\rho$ 从 $1$ 到 $2$，$\\theta$ 从 $0$ 到 $\\pi$。 被积函数： $\\sqrt{x^2+y^2} = \\rho$。 变换： $\\iint_D \\sqrt{x^2+y^2} dx dy = \\int_0^\\pi d\\theta \\int_1^2 \\rho \\cdot \\rho d\\rho = \\int_0^\\pi d\\theta \\int_1^2 \\rho^2 d\\rho$。 2. 三重积分\n几何意义： 体积（当被积函数为1时）。 计算方法： 直角坐标系下： 转化为累次积分。需确定 $x,y,z$ 的积分限。 柱面坐标系下： 坐标变换： $x = \\rho \\cos\\theta, y = \\rho \\sin\\theta, z=z$。 体积微元： $dV = \\rho dz d\\rho d\\theta$。 适用场景： 积分区域为圆柱体、圆锥体、抛物面等绕 $z$ 轴旋转的立体。 【试题关联：解答1】 考查三重积分在柱面坐标系下的计算。 区域 $\\Omega$： $x^2+y^2=4$ (半径为2的圆柱体), $z=0$, $z=4$ (高度为4)。这是一个圆柱体。 被积函数： $x^2+y^2 = \\rho^2$。 柱面坐标限： $\\rho$ 从 $0$ 到 $2$，$\\theta$ 从 $0$ 到 $2\\pi$， $z$ 从 $0$ 到 $4$。 解题思路： $\\iiint_\\Omega (x^2+y^2) dV = \\int_0^{2\\pi} d\\theta \\int_0^2 \\rho^2 \\cdot \\rho d\\rho \\int_0^4 dz = \\int_0^{2\\pi} d\\theta \\int_0^2 \\rho^3 d\\rho \\int_0^4 dz$。 【易错点与提醒】\n画出积分区域是避免错误的关键一步。 坐标变换时，Jacobian 行列式 $\\rho$ 不要遗漏。 极坐标和柱面坐标的适用范围（对称性）。 注意积分限的顺序和变量关系。 四、曲线积分与曲面积分 （对应试卷：填空5，选择5，解答5，解答6）\n1. 第一类曲线积分（对弧长）\n定义： $\\int_L f(x,y,z) ds$。 几何意义： 当 $f(x,y)=1$ 时，表示曲线弧长；当 $f(x,y)$ 为密度时，表示质量。 计算： 参数化曲线 $L: x=x(t), y=y(t), z=z(t), t \\in [\\alpha, \\beta]$。 $ds = \\sqrt{(x\u0026rsquo;(t))^2 + (y\u0026rsquo;(t))^2 + (z\u0026rsquo;(t))^2} dt$。 代入积分式：$\\int_\\alpha^\\beta f(x(t),y(t),z(t)) \\sqrt{(x\u0026rsquo;(t))^2 + (y\u0026rsquo;(t))^2 + (z\u0026rsquo;(t))^2} dt$。 【试题关联：选择5】 考查第一类曲线积分。 曲线 $L$： 圆心在原点半径为 $a$ 的圆周。参数方程：$x=a\\cos t, y=a\\sin t, t \\in [0, 2\\pi]$。 $ds$： $ds = \\sqrt{(-a\\sin t)^2 + (a\\cos t)^2} dt = \\sqrt{a^2\\sin^2 t + a^2\\cos^2 t} dt = \\sqrt{a^2} dt = a dt$。 被积函数： $x^2+y^2+2x = (a\\cos t)^2 + (a\\sin t)^2 + 2(a\\cos t) = a^2 + 2a\\cos t$。 积分： $\\int_0^{2\\pi} (a^2 + 2a\\cos t) a dt = a \\int_0^{2\\pi} (a^2 + 2a\\cos t) dt = a [a^2t + 2a\\sin t]_0^{2\\pi} = a(a^2 \\cdot 2\\pi + 0) = 2\\pi a^3$。 2. 第二类曲线积分（对坐标）\n定义： $\\int_L P dx + Q dy + R dz$。 物理意义： 力场做的功。 计算： 参数化曲线，将 $dx, dy, dz$ 替换为 $x\u0026rsquo;(t)dt, y\u0026rsquo;(t)dt, z\u0026rsquo;(t)dt$。 与路径无关的条件（全微分）： 平面区域： 若 $P,Q$ 及其一阶偏导数连续，则 $\\int_L P dx + Q dy$ 与路径无关 $\\iff \\frac{\\partial P}{\\partial y} = \\frac{\\partial Q}{\\partial x}$。 空间区域： 类似条件，旋度为零。 势函数（原函数）： 如果满足条件，则存在函数 $U(x,y)$ (或 $U(x,y,z)$) 使 $dU = P dx + Q dy$ (或 $dU = P dx + Q dy + R dz$)，此时积分值只与起点终点有关， $\\int_L P dx + Q dy = U(终点) - U(起点)$。 【试题关联：解答5】 考查第二类曲线积分与路径无关的条件及计算。 第一步： 判断 $P dx + Q dy$ 是否为全微分。即检查 $\\frac{\\partial P}{\\partial y} = \\frac{\\partial Q}{\\partial x}$。 $P = ax\\cos y - y^2\\sin x$， $Q = by\\cos x - x^2\\sin y$。 $\\frac{\\partial P}{\\partial y} = -ax\\sin y - 2y\\sin x$。 $\\frac{\\partial Q}{\\partial x} = -by\\sin x - 2x\\sin y$。 要使它们相等，则 $-ax\\sin y = -2x\\sin y$ 且 $-2y\\sin x = -by\\sin x$。 得到 $a=2, b=2$。 第二步： 计算积分。由于与路径无关，可以选择最简单的路径，例如连接 $(0,0)$ 到 $(1,1)$ 的直线路径 $y=x$ 或分段路径 $(0,0) \\to (1,0) \\to (1,1)$。 更简便的方法是找到势函数 $U(x,y)$。 $U(x,y) = \\int P dx = \\int (2x\\cos y - y^2\\sin x) dx = x^2\\cos y + y^2\\cos x + C(y)$。 $\\frac{\\partial U}{\\partial y} = -x^2\\sin y + 2y\\cos x + C\u0026rsquo;(y)$。 令其等于 $Q = 2y\\cos x - x^2\\sin y$，则 $C\u0026rsquo;(y)=0$，所以 $C(y)=C$。 势函数 $U(x,y) = x^2\\cos y + y^2\\cos x + C$。 积分值 $I = U(1,1) - U(0,0) = (1^2\\cos 1 + 1^2\\cos 1 + C) - (0^2\\cos 0 + 0^2\\cos 0 + C) = 2\\cos 1$。 3. Green 公式（格林公式）\n条件： 曲线 $L$ 是闭合的、分段光滑的、简单正向曲线，区域 $D$ 是单连通区域。 公式： $\\oint_L P dx + Q dy = \\iint_D (\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y}) dx dy$。 应用： 计算闭合曲线积分。 计算平面区域的面积（令 $\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y} = 1$，例如 $P=-y/2, Q=x/2$）。 与路径无关的联系： 若 $\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y} = 0$，则闭合曲线积分为 0，即与路径无关。 4. 第一类曲面积分（对面积）\n定义： $\\iint_\\Sigma f(x,y,z) dS$。 几何意义： 当 $f(x,y,z)=1$ 时，表示曲面面积；当 $f(x,y,z)$ 为面密度时，表示质量。 计算： 参数化曲面 $\\Sigma$ 或投影法。 投影法： 若曲面 $z=z(x,y)$ 投影到 $xy$ 面上的区域为 $D_{xy}$。 $dS = \\sqrt{1 + (\\frac{\\partial z}{\\partial x})^2 + (\\frac{\\partial z}{\\partial y})^2} dx dy$。 $\\iint_\\Sigma f(x,y,z) dS = \\iint_{D_{xy}} f(x,y,z(x,y)) \\sqrt{1 + (\\frac{\\partial z}{\\partial x})^2 + (\\frac{\\partial z}{\\partial y})^2} dx dy$。 球面坐标： 球面 $x^2+y^2+z^2=R^2$ 上， $dS = R^2 \\sin\\phi d\\phi d\\theta$。 【试题关联：填空5】 考查球面上的第一类曲面积分。 曲面 $\\Sigma$： 球面 $x^2+y^2+z^2=4$ (半径 $R=2$)。 被积函数： $f(x^2+y^2+z^2)$。在球面上， $x^2+y^2+z^2=4$。 积分： $\\iint_\\Sigma f(x^2+y^2+z^2) dS = \\iint_\\Sigma 4 dS = 4 \\iint_\\Sigma dS = 4 \\cdot (\\text{球面面积})$。 球面面积 $A = 4\\pi R^2 = 4\\pi (2^2) = 16\\pi$。 所以积分结果为 $4 \\cdot 16\\pi = 64\\pi$。 5. 第二类曲面积分（通量）\n定义： $\\iint_\\Sigma P dy dz + Q dz dx + R dx dy = \\iint_\\Sigma \\vec{F} \\cdot \\vec{n} dS$ (通量)。 物理意义： 向量场穿过曲面的流量。 计算： 投影法。 $dx dy$ 表示投影到 $xy$ 面上，与 $z$ 轴正向夹角为锐角（法向量 $z$ 分量大于0）时取正，否则取负。 若曲面 $z=z(x,y)$，法向量 $\\vec{n} = (-\\frac{\\partial z}{\\partial x}, -\\frac{\\partial z}{\\partial y}, 1)$ 或 $(\\frac{\\partial z}{\\partial x}, \\frac{\\partial z}{\\partial y}, -1)$，取决于曲面侧的选择。 高斯公式（散度定理）： 条件： 闭合曲面 $\\Sigma$ 包围的区域为 $\\Omega$，向量场 $\\vec{F}=(P,Q,R)$ 及其一阶偏导数在 $\\Omega$ 上连续。 公式： $\\iint_\\Sigma P dy dz + Q dz dx + R dx dy = \\iiint_\\Omega (\\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z}) dV = \\iiint_\\Omega \\text{div} \\vec{F} dV$。 应用： 将闭合曲面积分转化为三重积分，常用于计算通量。 【试题关联：解答6】 考查高斯公式的应用。 向量场： $\\vec{F} = (x,y,z)$。 散度： $\\text{div} \\vec{F} = \\frac{\\partial x}{\\partial x} + \\frac{\\partial y}{\\partial y} + \\frac{\\partial z}{\\partial z} = 1+1+1 = 3$。 曲面 $\\Sigma$： 抛物面 $z = x^2+y^2$ ($0 \\le z \\le 4$) 的下侧。这是一个不封闭的曲面。 闭合曲面： 为了应用高斯公式，需要封闭曲面。用平面 $z=4$ 上 $x^2+y^2 \\le 4$ 的圆盘 $\\Sigma_1$ 封闭抛物面。 封闭区域 $\\Omega$： 由抛物面 $z=x^2+y^2$ 和平面 $z=4$ 围成的区域。 高斯公式应用： $\\iint_{\\Sigma+\\Sigma_1} \\vec{F} \\cdot \\vec{n} dS = \\iiint_\\Omega \\text{div} \\vec{F} dV = \\iiint_\\Omega 3 dV = 3 \\text{Vol}(\\Omega)$。 计算 $\\text{Vol}(\\Omega)$ 使用柱面坐标：$\\int_0^{2\\pi} d\\theta \\int_0^2 \\rho d\\rho \\int_{\\rho^2}^4 dz = 2\\pi \\int_0^2 \\rho (4-\\rho^2) d\\rho = 2\\pi [2\\rho^2 - \\frac{1}{4}\\rho^4]_0^2 = 2\\pi (8-4) = 8\\pi$。 所以 $\\iint_{\\Sigma+\\Sigma_1} \\vec{F} \\cdot \\vec{n} dS = 3 \\cdot 8\\pi = 24\\pi$。 计算 $\\Sigma_1$ 上的积分： $\\Sigma_1$ 是 $z=4$ 的圆盘，法向量 $\\vec{n}=(0,0,1)$ (上侧)。 $\\iint_{\\Sigma_1} \\vec{F} \\cdot \\vec{n} dS = \\iint_{\\Sigma_1} (x,y,z) \\cdot (0,0,1) dS = \\iint_{\\Sigma_1} z dS = \\iint_{\\Sigma_1} 4 dS = 4 \\cdot (\\text{圆盘面积}) = 4 \\cdot \\pi (2^2) = 16\\pi$。 原曲面 $\\Sigma$ 积分： 题目要求下侧，所以法向量方向与高斯公式要求的向外法向量相反。 $\\iint_\\Sigma \\vec{F} \\cdot \\vec{n}{\\text{down}} dS = -\\iint\\Sigma \\vec{F} \\cdot \\vec{n}_{\\text{up}} dS$。 $\\iint_{\\Sigma+\\Sigma_1} \\vec{F} \\cdot \\vec{n}{\\text{out}} dS = \\iint\\Sigma \\vec{F} \\cdot \\vec{n}{\\text{up}} dS + \\iint{\\Sigma_1} \\vec{F} \\cdot \\vec{n}_{\\text{up}} dS$。 所以 $\\iint_\\Sigma \\vec{F} \\cdot \\vec{n}_{\\text{up}} dS = 24\\pi - 16\\pi = 8\\pi$。 最终结果为 $-8\\pi$ (下侧)。但题目答案是 $8\\pi$，这可能意味着题目默认是求向上的通量，或者在考场上默认按照标准法向量方向计算。解法中直接用 $8\\pi$ 作为结果，可能是因为题目没有严格强调下侧法向量的方向，或者认为通量取正值。 【易错点与提醒】\n第一类和第二类积分的定义和计算方式不同，$ds$ 和 $dx dy$ 等的写法。 第二类曲线积分中，参数化方向与积分路径方向一致性。 格林公式、高斯公式、斯托克斯公式的适用条件和公式内容。特别是高斯公式，要判断曲面是否封闭，若不封闭需补面。 曲面积分中，法向量方向的选择（正侧/负侧，上侧/下侧，外侧/内侧）会影响符号。 五、常微分方程 （对应试卷：填空6，填空8，解答3，解答7）\n1. 一阶微分方程\n可分离变量： $g(y)dy = f(x)dx$，两边积分。\n齐次方程： $y\u0026rsquo; = f(y/x)$，令 $u=y/x$。\n一阶线性方程： $y\u0026rsquo; + P(x)y = Q(x)$。\n通解公式： $y = e^{-\\int P(x)dx} [\\int Q(x) e^{\\int P(x)dx} dx + C]$。 全微分方程： $P(x,y)dx + Q(x,y)dy = 0$。\n判断条件： $\\frac{\\partial P}{\\partial y} = \\frac{\\partial Q}{\\partial x}$。 求解方法： $U(x,y) = \\int P(x,y) dx + C_1(y)$，再对 $y$ 求偏导与 $Q(x,y)$ 比较确定 $C_1(y)$。 或 $U(x,y) = \\int Q(x,y) dy + C_2(x)$，再对 $x$ 求偏导与 $P(x,y)$ 比较确定 $C_2(x)$。 【试题关联：填空6】 考查全微分方程的判断和通解。 判断条件： $M(x,y) = x^2-y, N(x,y) = ax$。 $\\frac{\\partial M}{\\partial y} = -1$, $\\frac{\\partial N}{\\partial x} = a$。 要使方程为全微分方程，必须 $-1=a$，所以 $a=-1$。 求通解： 当 $a=-1$ 时，方程为 $(x^2-y)dx - x dy = 0$。 $U(x,y) = \\int (x^2-y) dx + C_1(y) = \\frac{1}{3}x^3 - xy + C_1(y)$。 $\\frac{\\partial U}{\\partial y} = -x + C_1\u0026rsquo;(y)$。 令 $\\frac{\\partial U}{\\partial y} = N(x,y) = -x$，则 $-x + C_1\u0026rsquo;(y) = -x$，所以 $C_1\u0026rsquo;(y) = 0$， $C_1(y) = C$。 通解为 $\\frac{1}{3}x^3 - xy = C$。 可降阶方程（二阶方程）：\n$y\u0026rsquo;\u0026rsquo; = f(x, y\u0026rsquo;)$：令 $p = y\u0026rsquo;$。 $y\u0026rsquo;\u0026rsquo; = f(y, y\u0026rsquo;)$：令 $p = y\u0026rsquo;$, $y\u0026rsquo;\u0026rsquo; = p \\frac{dp}{dy}$。 【试题关联：解答3】 考查通过几何关系建立微分方程。\n解题思路： 设曲线方程为 $y=y(x)$，切点为 $(x,y)$。 切线方程为 $Y-y = y\u0026rsquo;(x)(X-x)$。 求切线在 $x$ 轴和 $y$ 轴上的截距 $X_{截}$ 和 $Y_{截}$。 令 $Y=0 \\implies X_{截} = x - \\frac{y}{y\u0026rsquo;}$。 令 $X=0 \\implies Y_{截} = y - x y\u0026rsquo;$。 根据题目条件“切线介于坐标轴间的部分被切点分成相等的两部分”，这意味着切点 $(x,y)$ 是 $(X_{截}, 0)$ 和 $(0, Y_{截})$ 的中点。 $x = \\frac{X_{截}+0}{2} \\implies X_{截} = 2x$。 $y = \\frac{0+Y_{截}}{2} \\implies Y_{截} = 2y$。 代入得 $2x = x - \\frac{y}{y\u0026rsquo;}$ 和 $2y = y - x y\u0026rsquo;$。 两式都化简为 $x = -\\frac{y}{y\u0026rsquo;}$ 或 $y = -x y\u0026rsquo;$。 得到微分方程 $y\u0026rsquo; = -\\frac{y}{x}$。 这是一个可分离变量的方程：$\\frac{dy}{y} = -\\frac{dx}{x}$。 积分：$\\ln|y| = -\\ln|x| + \\ln C \\implies \\ln|y| = \\ln|\\frac{C}{x}| \\implies y = \\frac{C}{x}$ 或 $xy=C$。 2. 二阶常系数线性非齐次微分方程\n形式： $y\u0026rsquo;\u0026rsquo; + py\u0026rsquo; + qy = f(x)$。 通解结构： $y = y_h + y_p$，其中 $y_h$ 是对应齐次方程的通解，$y_p$ 是非齐次方程的一个特解。 齐次方程通解 $y_h$： 特征方程：$r^2 + pr + q = 0$。 根据特征根的类型： 两不相等实根 $r_1 \\ne r_2$： $y_h = C_1 e^{r_1 x} + C_2 e^{r_2 x}$。 两相等实根 $r_1 = r_2 = r$： $y_h = (C_1 + C_2 x) e^{rx}$。 一对共轭复根 $r = \\alpha \\pm i\\beta$： $y_h = e^{\\alpha x} (C_1 \\cos(\\beta x) + C_2 \\sin(\\beta x))$。 非齐次特解 $y_p$（待定系数法）： 原则： 根据 $f(x)$ 的形式构造 $y_p$。 常见形式： $f(x) = P_n(x) e^{\\lambda x}$： 设 $y_p = x^k Q_n(x) e^{\\lambda x}$。其中 $Q_n(x)$ 是与 $P_n(x)$ 同次的待定多项式，$k$ 是 $\\lambda$ 作为特征根的重数（若不是特征根，则 $k=0$；若是单根，则 $k=1$；若是二重根，则 $k=2$）。 $f(x) = e^{\\alpha x} (P_m(x) \\cos(\\beta x) + Q_n(x) \\sin(\\beta x))$： 设 $y_p = x^k e^{\\alpha x} (R_N(x) \\cos(\\beta x) + S_N(x) \\sin(\\beta x))$。其中 $N=\\max(m,n)$，$R_N, S_N$ 是待定多项式，$k$ 是 $\\alpha+i\\beta$ 作为特征根的重数。 【试题关联：解答7】 考查二阶常系数线性非齐次微分方程的求解。 齐次方程： $y\u0026rsquo;\u0026rsquo; - 3y\u0026rsquo; + 2y = 0$。 特征方程 $r^2 - 3r + 2 = 0 \\implies (r-1)(r-2)=0$。 特征根 $r_1=1, r_2=2$。 齐次通解 $y_h = C_1 e^x + C_2 e^{2x}$。 特解： $f(x) = xe^{2x}$。 $P_n(x) = x$ ($n=1$)，$\\lambda=2$。 $\\lambda=2$ 是特征方程的单根，所以 $k=1$。 设特解 $y_p = x^1 (Ax+B)e^{2x} = (Ax^2+Bx)e^{2x}$。 计算 $y_p\u0026rsquo;, y_p\u0026rsquo;\u0026rsquo;$，代入原方程，比较系数，解出 $A,B$。 $y_p\u0026rsquo; = (2Ax+B)e^{2x} + 2(Ax^2+Bx)e^{2x} = (2Ax^2+(2A+2B)x+B)e^{2x}$。 $y_p\u0026rsquo;\u0026rsquo; = (4Ax+(2A+2B))e^{2x} + 2(2Ax^2+(2A+2B)x+B)e^{2x}$ $= (4Ax^2+(4A+4B+4A)x+(2A+2B+2B))e^{2x} = (4Ax^2+(8A+4B)x+(2A+4B))e^{2x}$。 代入 $y\u0026rsquo;\u0026rsquo; - 3y\u0026rsquo; + 2y = xe^{2x}$： $e^{2x} [ (4Ax^2+(8A+4B)x+(2A+4B)) - 3(2Ax^2+(2A+2B)x+B) + 2(Ax^2+Bx) ] = xe^{2x}$。 $e^{2x} [ (4A-6A+2A)x^2 + (8A+4B-6A-6B+2B)x + (2A+4B-3B) ] = xe^{2x}$。 $e^{2x} [ 0x^2 + (2A)x + (2A+B) ] = xe^{2x}$。 比较系数： $2A = 1 \\implies A = 1/2$。 $2A+B = 0 \\implies 2(1/2)+B=0 \\implies 1+B=0 \\implies B = -1$。 特解 $y_p = (\\frac{1}{2}x^2-x)e^{2x} = x(\\frac{1}{2}x-1)e^{2x}$。 通解： $y = C_1 e^x + C_2 e^{2x} + x(\\frac{1}{2}x-1)e^{2x}$。 【易错点与提醒】\n判断全微分方程的条件 $\\frac{\\partial P}{\\partial y} = \\frac{\\partial Q}{\\partial x}$ 易错。 待定系数法中，特解形式的选择是关键，尤其要记住当 $f(x)$ 中的 $\\lambda$ 是特征方程的根时，需要乘以 $x^k$。 六、无穷级数 （对应试卷：填空4，填空7，解答2，解答8）\n1. 数项级数\n敛散性判别法： 必要条件： 若 $\\sum_{n=1}^\\infty a_n$ 收敛，则 $\\lim_{n \\to \\infty} a_n = 0$。反之不成立。 正项级数判别法： 比较判别法： 直接比较或极限比较。 比值判别法（达朗贝尔判别法）： $\\lim_{n \\to \\infty} |\\frac{a_{n+1}}{a_n}| = L$。 若 $L \u0026lt; 1$，收敛。 若 $L \u0026gt; 1$，发散。 若 $L = 1$，判别失效。 根值判别法（柯西判别法）： $\\lim_{n \\to \\infty} \\sqrt[n]{|a_n|} = L$。 若 $L \u0026lt; 1$，收敛。 若 $L \u0026gt; 1$，发散。 若 $L = 1$，判别失效。 积分判别法： 将级数项与对应函数的积分进行比较。 交错级数判别法（莱布尼茨判别法）： 条件：$\\sum_{n=1}^\\infty (-1)^{n-1} u_n$ ($u_n\u0026gt;0$)，若 $u_n$ 单调递减且 $\\lim_{n \\to \\infty} u_n = 0$，则级数收敛。 绝对收敛与条件收敛： 若 $\\sum_{n=1}^\\infty |a_n|$ 收敛，则 $\\sum_{n=1}^\\infty a_n$ 绝对收敛。绝对收敛的级数一定收敛。 若 $\\sum_{n=1}^\\infty a_n$ 收敛，但 $\\sum_{n=1}^\\infty |a_n|$ 发散，则 $\\sum_{n=1}^\\infty a_n$ 条件收敛。 【试题关联：解答2】 考查级数的绝对收敛和条件收敛判别。 级数： $\\sum_{n=1}^\\infty (-1)^n \\frac{2^n}{n!}$。 首先判别绝对收敛性： 考虑正项级数 $\\sum_{n=1}^\\infty |\\frac{2^n}{n!}| = \\sum_{n=1}^\\infty \\frac{2^n}{n!}$。 使用比值判别法：$\\lim_{n \\to \\infty} \\frac{a_{n+1}}{a_n} = \\lim_{n \\to \\infty} \\frac{2^{n+1}}{(n+1)!} \\cdot \\frac{n!}{2^n} = \\lim_{n \\to \\infty} \\frac{2}{n+1} = 0$。 因为 $L=0 \u0026lt; 1$，所以级数 $\\sum_{n=1}^\\infty \\frac{2^n}{n!}$ 收敛。 因此，原级数 $\\sum_{n=1}^\\infty (-1)^n \\frac{2^n}{n!}$ 绝对收敛。 2. 幂级数\n形式： $\\sum_{n=0}^\\infty c_n (x-x_0)^n$。 收敛半径 $R$ 和收敛区间： 比值判别法： $\\lim_{n \\to \\infty} |\\frac{c_{n+1}}{c_n}| = L$ (或 $\\lim_{n \\to \\infty} |\\frac{u_{n+1}(x)}{u_n(x)}| = |x-x_0| L\u0026rsquo;$)。 收敛半径 $R = \\frac{1}{L}$ (或 $R = \\frac{1}{L\u0026rsquo;}$)。 根值判别法： $\\lim_{n \\to \\infty} \\sqrt[n]{|c_n|} = L$。 收敛半径 $R = \\frac{1}{L}$。 收敛区间： $(x_0-R, x_0+R)$。 端点检验： 在 $x=x_0-R$ 和 $x=x_0+R$ 处，幂级数可能收敛也可能发散，需要单独判断。 幂级数的性质： 在收敛区间内，幂级数可以逐项求导和逐项积分，且不改变收敛半径。 幂级数的和函数： 利用已知级数（如几何级数、泰勒级数）的和函数，通过逐项求导/积分、代换、乘除等运算得到。 几何级数： $\\sum_{n=0}^\\infty x^n = \\frac{1}{1-x}, |x|\u0026lt;1$。 常用泰勒级数： $e^x, \\sin x, \\cos x, \\ln(1+x), (1+x)^\\alpha$ 等。 【试题关联：填空4】 考查幂级数的展开式和收敛区间。 函数： $f(x) = \\frac{1}{x^2+4x+3} = \\frac{1}{(x+1)(x+3)}$。 部分分式分解： $\\frac{1}{(x+1)(x+3)} = \\frac{A}{x+1} + \\frac{B}{x+3}$。 $1 = A(x+3) + B(x+1)$。 令 $x=-1 \\implies 1 = 2A \\implies A = 1/2$。 令 $x=-3 \\implies 1 = -2B \\implies B = -1/2$。 $f(x) = \\frac{1}{2(x+1)} - \\frac{1}{2(x+3)}$。 几何级数形式转换： $\\frac{1}{x+1} = \\frac{1}{1-(-x)} = \\sum_{n=0}^\\infty (-x)^n = \\sum_{n=0}^\\infty (-1)^n x^n, |x|\u0026lt;1$。 $\\frac{1}{x+3} = \\frac{1}{3(1+x/3)} = \\frac{1}{3} \\frac{1}{1-(-x/3)} = \\frac{1}{3} \\sum_{n=0}^\\infty (-x/3)^n = \\sum_{n=0}^\\infty \\frac{(-1)^n}{3^{n+1}} x^n, |-x/3|\u0026lt;1 \\implies |x|\u0026lt;3$。 合并： $f(x) = \\frac{1}{2} \\sum_{n=0}^\\infty (-1)^n x^n - \\frac{1}{2} \\sum_{n=0}^\\infty \\frac{(-1)^n}{3^{n+1}} x^n = \\sum_{n=0}^\\infty \\frac{1}{2} (-1)^n (1 - \\frac{1}{3^{n+1}}) x^n$。 收敛区间： 取两个级数收敛区间的交集，即 $|x|\u0026lt;1$。所以 $x \\in (-1,1)$。 【试题关联：解答8】 考查幂级数的收敛域和和函数。 幂级数： $\\sum_{n=1}^\\infty (-1)^{n-1} \\frac{x^n}{n}$。 收敛半径 $R$： 使用比值判别法。 $\\lim_{n \\to \\infty} |\\frac{a_{n+1}(x)}{a_n(x)}| = \\lim_{n \\to \\infty} |\\frac{(-1)^n x^{n+1}/(n+1)}{(-1)^{n-1} x^n/n}| = \\lim_{n \\to \\infty} |\\frac{x}{n+1} \\cdot n| = |x| \\lim_{n \\to \\infty} \\frac{n}{n+1} = |x| \\cdot 1 = |x|$。 要使级数收敛，需 $|x| \u0026lt; 1$。所以 $R=1$。 端点检验： $x=1$： 级数变为 $\\sum_{n=1}^\\infty (-1)^{n-1} \\frac{1}{n}$。这是交错级数 $\\sum_{n=1}^\\infty (-1)^{n-1} u_n$，$u_n = 1/n$。 $u_n = 1/n \u0026gt; 0$，单调递减，$\\lim_{n \\to \\infty} 1/n = 0$。 由莱布尼茨判别法，级数收敛。 $x=-1$： 级数变为 $\\sum_{n=1}^\\infty (-1)^{n-1} \\frac{(-1)^n}{n} = \\sum_{n=1}^\\infty \\frac{(-1)^{2n-1}}{n} = \\sum_{n=1}^\\infty \\frac{-1}{n} = -\\sum_{n=1}^\\infty \\frac{1}{n}$。 这是调和级数的负数，发散。 收敛域： $(-1, 1]$。 和函数： 设 $S(x) = \\sum_{n=1}^\\infty (-1)^{n-1} \\frac{x^n}{n}$。 逐项求导：$S\u0026rsquo;(x) = \\sum_{n=1}^\\infty (-1)^{n-1} \\frac{nx^{n-1}}{n} = \\sum_{n=1}^\\infty (-1)^{n-1} x^{n-1}$。 $S\u0026rsquo;(x) = 1 - x + x^2 - x^3 + \\dots$。 这是一个公比为 $-x$ 的几何级数，其和为 $\\frac{1}{1-(-x)} = \\frac{1}{1+x}$，适用于 $|-x|\u0026lt;1 \\implies |x|\u0026lt;1$。 逐项积分：$S(x) = \\int \\frac{1}{1+x} dx = \\ln|1+x| + C$。 由 $S(0) = 0$ (将 $x=0$ 代入原级数)，得 $\\ln(1) + C = 0 \\implies C=0$。 所以和函数 $S(x) = \\ln(1+x)$，适用于 $x \\in (-1,1)$。 根据 Abel 定理，当 $x=1$ 时，级数收敛到 $\\lim_{x \\to 1^-} \\ln(1+x) = \\ln(2)$。 题目还问了 $\\sum_{n=1}^\\infty \\frac{(-1)^n}{n}$ 的和： 这是 $-S(1)$ 的形式。 $\\sum_{n=1}^\\infty \\frac{(-1)^n}{n} = - \\sum_{n=1}^\\infty \\frac{(-1)^{n-1}}{n} = -S(1) = -\\ln(2)$。 3. 傅里叶级数（傅立叶级数）\n周期函数展开： 将周期函数分解为正弦和余弦函数的和。 狄利克雷(Dirichlet)条件： 保证傅里叶级数收敛的条件。 收敛性： 若 $f(x)$ 在点 $x_0$ 连续，则 $S(x_0) = f(x_0)$。 若 $f(x)$ 在点 $x_0$ 间断，则 $S(x_0) = \\frac{f(x_0^+) + f(x_0^-)}{2}$。 【试题关联：填空7】 考查傅里叶级数和函数在间断点的收敛值。 函数： $f(x) = \\begin{cases} x, \u0026amp; -\\pi \u0026lt; x \\le 0 \\ -x, \u0026amp; 0 \u0026lt; x \\le \\pi \\end{cases}$，周期 $2\\pi$。 求 $S(\\pi)$： 点 $x=\\pi$ 是函数周期延拓后的间断点。因为 $f(\\pi)$ 是 $-x$ 在 $x=\\pi$ 的值，为 $-\\pi$。而 $f(\\pi^+)$ (相当于 $f(-\\pi^+)$) 对应的是 $x$ 在 $-\\pi$ 的右极限，为 $-\\pi$。 更精确的看，在区间 $(-\\pi, \\pi]$ 上，函数在 $x=0$ 处连续 ($f(0)=0$)，但在 $x=\\pi$ 处是区间的右端点，其值是 $f(\\pi^-) = -\\pi$。而 $f(\\pi^+)$ 对应的是周期延拓后 $f(-\\pi^+)$ 的值，即 $x \\to -\\pi$ 时的 $x$，为 $-\\pi$。 所以 $S(\\pi) = \\frac{f(\\pi^-) + f(\\pi^+)}{2} = \\frac{-\\pi + (-\\pi)}{2} = -\\pi$。 仔细核对答案： 答案是 $-\\frac{\\pi}{2}$。这说明我对 $f(\\pi^+)$ 的理解有偏差。傅里叶级数的和函数 $S(x)$ 在周期延拓的端点处，收敛到 $f(x_0)$ 和 $f(x_0+2L)$ （或 $f(x_0-2L)$） 的平均值。 对于周期 $2\\pi$ 的函数，傅里叶级数在 $x=\\pi$ 处收敛到 $\\frac{f(\\pi^-) + f(\\pi^+)}{2}$。 $f(\\pi^-)$ 是 $f(x)$ 在 $x \\to \\pi$ 从左边的极限，根据 $f(x)=-x$ 定义， $f(\\pi^-) = -\\pi$。 $f(\\pi^+)$ 是 $f(x)$ 在 $x \\to \\pi$ 从右边的极限。由于周期性 $f(x+2\\pi)=f(x)$，所以 $f(\\pi^+) = f(-\\pi^+)$。 根据 $f(x)=x$ 定义 (在 $(-\\pi, 0]$)，$f(-\\pi^+) = -\\pi$。 所以 $S(\\pi) = \\frac{-\\pi + (-\\pi)}{2} = -\\pi$。 再看答案 $-\\frac{\\pi}{2}$： 题目可能是故意考察 $x=\\pm\\pi$ 处的值。在标准 $2L$ 周期函数在 $[-L, L]$ 定义时，其傅里叶级数在 $x=\\pm L$ 处收敛到 $\\frac{f(L^-) + f(-L^+)}{2}$。 在这里 $L=\\pi$。$f(\\pi^-) = -\\pi$。$f(-\\pi^+) = \\lim_{x \\to -\\pi^+} x = -\\pi$。 因此 $S(\\pi)$ 仍是 $-\\pi$。 重新考虑傅里叶级数和函数的性质： 对于周期为 $2L$ 的函数 $f(x)$，其傅里叶级数的和函数 $S(x)$ 在点 $x_0$ 处收敛于： 若 $x_0$ 为连续点，则 $S(x_0) = f(x_0)$。 若 $x_0$ 为跳跃间断点，则 $S(x_0) = \\frac{f(x_0^+) + f(x_0^-)}{2}$。 函数 $f(x)$ 在 $(-\\pi, \\pi]$ 上的定义为 $f(x) = \\begin{cases} x, \u0026amp; -\\pi \u0026lt; x \\le 0 \\ -x, \u0026amp; 0 \u0026lt; x \\le \\pi \\end{cases}$。 $f(x)$ 是一个偶函数 ($f(-x)=f(x)$)。因此它的傅里叶级数是一个余弦级数。 在 $x=\\pi$ 处，其左极限 $f(\\pi^-) = \\lim_{x \\to \\pi^-} (-x) = -\\pi$。 其右极限，由于周期性，应该考虑 $f(\\pi^+) = f(-\\pi^+) = \\lim_{x \\to -\\pi^+} x = -\\pi$。 所以 $S(\\pi) = \\frac{-\\pi + (-\\pi)}{2} = -\\pi$。 答案与我的分析不符。 可能是 $f(x)$ 的定义域有问题，或者该题有特定考法。但根据标准傅里叶级数理论，答案应为 $-\\pi$。如果答案是 $-\\pi/2$，则可能是函数在 $x=\\pi$ 和 $x=-\\pi$ 处的定义或者和函数理解有特殊约定。 更新： 检查了一下，这个函数的图像是一个“屋顶”形，在 $x=\\pi$ 和 $x=-\\pi$ 处都是 $f(\\pi) = -\\pi$ 和 $f(-\\pi)= \\text{未定义，或设为}-\\pi$。它的周期延拓在 $x=\\pi$ 处是一个连续点。但 $x=\\pi$ 是区间端点。 最终： 既然试卷给出了答案，那么它可能暗示了在处理区间端点和周期函数延拓上的某种约定。但从标准的傅里叶级数和函数定义来看，在 $x=\\pi$ 处的值应该是 $-\\pi$。为了贴合题目，这里可能需要特别提醒学生注意傅里叶级数在周期端点处收敛值的特殊规定，但一般情况下 $S(L) = (f(L^-)+f(-L^+))/2$。 再三核对： $f(x)$ 是定义在 $(-\\pi, \\pi]$ 上的偶函数。在 $x=\\pi$ 处，值是 $f(\\pi) = -\\pi$。在 $x=-\\pi$ 处，它的值是 $\\lim_{x \\to -\\pi^+} f(x) = \\lim_{x \\to -\\pi^+} x = -\\pi$。 对于周期为 $2L$ 的函数，在周期端点 $x=L$ 处，傅里叶级数收敛到 $\\frac{f(L^-)+f(-L^+)}{2}$。 这里 $L=\\pi$，所以 $S(\\pi) = \\frac{f(\\pi^-) + f(-\\pi^+)}{2} = \\frac{-\\pi + (-\\pi)}{2} = -\\pi$。 所以，如果答案是 $-\\pi/2$，那意味着我的分析有误，或者题目有特殊设定。但根据常规理论，是 $-\\pi$。 考虑到是期末考试，答案可能更优先。如果解答中没有给出计算过程，只有答案，那么这需要学生理解特殊情况下可能出现的约定。 补充： 也有可能 $f(x)$ 的定义不是在 $(-\\pi, \\pi]$ 而是在 $[-\\pi, \\pi]$，并且 $f(-\\pi)=f(\\pi)$。但即便如此，结果仍是 $-\\pi$。 再看图： 这是一个锯齿波的变形，或者说绝对值函数 $|x|$ 在 $[-\\pi, \\pi]$ 上的定义。 $f(x) = |x|$ 在 $[-\\pi, \\pi]$ 上。 但题目给出的是 $x$ 和 $-x$。 如果函数是 $f(x) = |x|$ for $x \\in [-\\pi, \\pi]$， 那么 $f(\\pi) = \\pi$, $f(-\\pi)=\\pi$。 此时，傅里叶级数在 $x=\\pi$ 处收敛到 $\\frac{f(\\pi^-) + f(-\\pi^+)}{2} = \\frac{\\pi + \\pi}{2} = \\pi$。 但题目给的函数是 $f(x)=x$ for $-\\pi \u0026lt; x \\le 0$ 和 $f(x)=-x$ for $0 \u0026lt; x \\le \\pi$。 这个函数在 $(-\\pi, \\pi]$ 上的图像是：从 $(-\\pi, -\\pi)$ 到 $(0,0)$ 是直线 $y=x$，从 $(0,0)$ 到 $(\\pi, -\\pi)$ 是直线 $y=-x$。 所以 $f(\\pi) = -\\pi$。 $f(-\\pi)$ 不定义，但 $\\lim_{x \\to -\\pi^+} f(x) = -\\pi$。 因此，和函数在 $x=\\pi$ 处收敛到 $\\frac{f(\\pi^-) + f(-\\pi^+)}{2} = \\frac{-\\pi + (-\\pi)}{2} = -\\pi$。 结论： 除非题目存在印刷错误或某种特殊规定，否则标准答案应该是 $-\\pi$。如果考题答案是 $-\\pi/2$，这可能是个陷阱或概念理解上的微小偏差。在实际教学中，我会强调标准定义，并指出此类模糊点。 【易错点与提醒】\n数项级数各种判别法的适用条件和结论。 绝对收敛和条件收敛的概念及区别。 幂级数的收敛半径和收敛区间的求解（特别是端点检验）。 利用已知级数求和函数是常用技巧。 傅里叶级数在间断点处的收敛值是左右极限的平均值。在周期端点处，需要考虑周期延拓。 七、积分方程 （对应试卷：填空8）\n1. 简单积分方程\n概念： 待求函数出现在积分号下。 求解策略： 微分法： 若积分上限是变量，可以通过对变量求导将积分方程转化为微分方程。 莱布尼茨公式： $\\frac{d}{dx} \\int_{a(x)}^{b(x)} f(x,t) dt = f(x, b(x)) b\u0026rsquo;(x) - f(x, a(x)) a\u0026rsquo;(x) + \\int_{a(x)}^{b(x)} \\frac{\\partial}{\\partial x} f(x,t) dt$。 【试题关联：填空8】 考查积分方程的微分法。 方程： $f(x) + 2\\int_0^x f(t) dt = x^2$。 解题思路： 对两边关于 $x$ 求导。 $\\frac{d}{dx} [f(x) + 2\\int_0^x f(t) dt] = \\frac{d}{dx} (x^2)$。 $f\u0026rsquo;(x) + 2f(x) = 2x$ (这里用到 $\\frac{d}{dx} \\int_0^x f(t) dt = f(x)$)。 这是一个一阶线性微分方程：$f\u0026rsquo;(x) + 2f(x) = 2x$。 初始条件： 令 $x=0$ 代入原积分方程：$f(0) + 2\\int_0^0 f(t) dt = 0^2 \\implies f(0) + 0 = 0 \\implies f(0)=0$。 求解 $f\u0026rsquo;(x) + 2f(x) = 2x$： 使用通解公式：$f(x) = e^{-\\int 2dx} [\\int 2x e^{\\int 2dx} dx + C]$。 $f(x) = e^{-2x} [\\int 2x e^{2x} dx + C]$。 $\\int 2x e^{2x} dx$ 可以用分部积分法： $\\int 2x e^{2x} dx = x e^{2x} - \\int e^{2x} dx = x e^{2x} - \\frac{1}{2}e^{2x}$。 $f(x) = e^{-2x} [x e^{2x} - \\frac{1}{2}e^{2x} + C] = x - \\frac{1}{2} + C e^{-2x}$。 代入初始条件 $f(0)=0$： $0 = 0 - \\frac{1}{2} + C e^0 \\implies 0 = -\\frac{1}{2} + C \\implies C = \\frac{1}{2}$。 最终解： $f(x) = x - \\frac{1}{2} + \\frac{1}{2} e^{-2x}$。 【易错点与提醒】\n对积分方程求导时，要正确应用莱布尼茨公式。 求出微分方程后，不要忘记利用原积分方程的初始值来确定常数 $C$。 ","date":"June 15, 2025","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/math/examreview_1_1/","series":[],"smallImg":"","tags":[],"timestamp":1749978600,"title":"期末复习纲要1"},{"authors":[],"categories":[],"content":"在学习排序算法的过程中，我们接触到了快速排序。\n而快速排序的核心思想就是分治法。\n分治法概述 设计思想 对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。\n分治法能解决的问题的主要特征：\n该问题的规模缩小到一定的程度就可以容易地解决。 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。 利用该问题分解出的子问题的解可以合并为该问题的解。 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 基本步骤 分治法通常采用递归算法设计技术，在每一层递归上都有三个步骤：\n分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。 求解子问题：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题。 合并：将各个子问题的解合并为原问题的解。 算法框架 // 函数：解决问题 ResultType solve(ProblemType problem) { // 基本情况：问题足够小，直接解决 if (is_small(problem)) { return direct_solution(problem); } // 分解：将问题分解为子问题 SubproblemType subproblems[MAX_SUBPROBLEMS]; int num_subproblems = divide(problem, subproblems); // 解决：递归地解决子问题 ResultType subsolutions[MAX_SUBPROBLEMS]; for (int i = 0; i \u0026lt; num_subproblems; i++) { subsolutions[i] = solve(subproblems[i]); } // 合并：将子问题的解合并成原问题的解 return combine(subsolutions, num_subproblems); } 在实际的应用中人们发现，把问题分解成若干个规模较小的问题时，每个子问题的规模相同时，分治法的效率是最高的。\n求解排序问题 快速排序 基本思想 在待排序的n个记录中任取一个记录，以该记录的关键字为标准，将所有关键字小于该记录的记录排列在前，所有关键字大于该记录的记录排列在后，然后分别对前后两个子序列重复上述过程，直到所有记录都排好序为止。\n算法 int Partition(int a[], int low, int high) { int pivot = a[low];// 枢轴记录 while (low \u0026lt; high) { while (low \u0026lt; high \u0026amp;\u0026amp; a[high] \u0026gt;= pivot) { high--; } a[low] = a[high];// 比枢轴小的元素移动到左端 while (low \u0026lt; high \u0026amp;\u0026amp; a[low] \u0026lt;= pivot) { low++; } a[high] = a[low];// 比枢轴大的元素移动到右端 } a[low] = pivot;// 枢轴元素放到最终位置 return low;// 返回枢轴所在位置;实际上此时不论返回low还是high都是一样的 } void QuickSort(int a[], int low, int high) { if (low \u0026lt; high) { int pivotpos = Partition(a, low, high);// 划分 QuickSort(a, low, pivotpos - 1);// 递归求解 QuickSort(a, pivotpos + 1, high);// 递归求解 } } int main() { int a[10] = {5, 2, 4, 6, 1, 3, 9, 8, 7, 0}; QuickSort(a, 0, 9); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } return 0; } ","date":"March 15, 2025","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/c/divide/","series":[],"smallImg":"","tags":[],"timestamp":1742018057,"title":"分治策略"},{"authors":[],"categories":[],"content":" 图 图的结构定义 图是由一个顶点集V和一个边集S组成的数据结构。 其中，V是顶点的集合，S是边的集合。\n图的边有两种：\n有向边：有向边是指从一个顶点指向另一个顶点的边。 有向图：有向图是指图中的边都是有向边的图。 无向边：无向边是指两个顶点之间没有方向的边。 无向图：无向图是指图中的边都是无向边的图。 Graph = (V, S) 而 R={VR}\n度：和顶点v相关联的边的数目。\n对于有向图来说，由于弧是有方向的，所以有入度和出度的概念：\n入度：以顶点v为终点的边的数目。\n出度：以顶点v为起点的边的数目。\n路径 在图论中，路径是指连接图中两个或多个顶点的一系列边的序列。 更正式地说，从顶点 u 到顶点 v 的路径是一个顶点序列：\nP = (v1, v2, \u0026hellip;, vk)\n其中：\nv1 = u （路径的起点是 u） vk = v （路径的终点是 v） 对于所有的 i (1 \u0026lt;= i \u0026lt; k)，顶点 vi 和 vi+1 之间都存在一条边。 路径的长度\n路径的长度是指路径中边的数量。 在上面的例子中，路径 P 的长度是 k - 1。\n路径的类型\n根据路径中是否允许重复顶点和边，可以将路径分为以下几种类型：\n简单路径 (Simple Path)： 路径中的所有顶点都是不同的，即没有重复的顶点。\n因此，简单路径中也不会有重复的边。\n例如： A -\u0026gt; B -\u0026gt; C (A, B, C 各不相同)\n非简单路径 (Non-Simple Path)： 路径中可以包含重复的顶点和边。\n例如： A -\u0026gt; B -\u0026gt; C -\u0026gt; B (B 重复出现)\n环 (Cycle)： 是一种特殊的路径，它的起点和终点是同一个顶点。\n例如： A -\u0026gt; B -\u0026gt; C -\u0026gt; A\n简单环 (Simple Cycle)： 除了起点和终点相同外，环中的所有其他顶点都是不同的。\n例如： A -\u0026gt; B -\u0026gt; C -\u0026gt; A (A, B, C 各不相同)\n如果图中任意两个顶点之间都存在路径，则该图被称为连通图。 也就是说，从任何一个顶点出发，都可以到达图中的任何其他顶点\n图的存储 邻接矩阵 无向图 邻接矩阵是一种表示图的方法，它使用一个二维数组来表示图中顶点之间的连接关系。\n在邻接矩阵中，数组的行和列分别表示图中的顶点，而数组元素的值则表示两个顶点之间是否有边。\n如果两个顶点之间有边，则数组元素的值为 1；否则，数组元素的值为 0。\n数学表示为:\n$$ M_{ij} = \\begin{cases} 1, \u0026amp; \\text{如果顶点 i 和顶点 j 之间有边} \\ 0, \u0026amp; \\text{否则} \\end{cases}\\ A = \\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; 0 \\ 1 \u0026amp; 0 \u0026amp; 1 \\ 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} $$\n矩阵的主对角线始终为0，因为一个顶点不可能与自己相邻。\n邻接矩阵的转置矩阵和邻接矩阵始终相同，也就意味着矩阵中1的个数始终是偶数且为图中边的两倍。\n有向图 如果顶点 i 和顶点 j 之间存在一条从 i 到 j 的边，那么 $adjacency_matrix[i][j] = 1$。\n但是，即使 adjacency_matrix[i][j] = 1，也不能保证 $adjacency_matrix[j][i] = 1$，除非也存在一条从 j 到 i 的边。\n因此，有向图的邻接矩阵通常是不对称的。\n例题 有n个城市，其中一些城市彼此连接，有的城市之间没有直接的连接。\n给定一个二维数组 isConnected，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。\n省份是一组直接或间接相连的城市，而组内不含其他没有相连的城市。\n返回矩阵中省份的数量。\n思路：\n遍历矩阵，找到与当前城市直接相连的城市。 标记这些城市为已访问。（为了避免重复访问，我们可以使用一个数组来记录每个城市是否已被访问。把数组中的1改为0） 继续遍历，直到所有城市都被访问。 void DFs(int n, int row){ int j; visited[row] = 1; for(j = 0; j \u0026lt; n; j++){ if(isConnected[row][j] == 1 \u0026amp;\u0026amp; !visited[j]){ isConnected[row][j] = 0; isConnected[j][row] = 0;// 标记已访问 DFS(n, j);// 递归遍历 } } } int CountNum(int n){ int i; int count = 0; for (i = 0; i \u0026lt; n; i++){ if(!visited[i]){ DFS(n, i); count++; } } return count; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int isConnected[n][n]; int i, j; for (i = 0; i \u0026lt; n; i++){ for (j = 0; j \u0026lt; n; j++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;isConnected[i][j]); } } int count = CountNum(n); printf(\u0026#34;%d\u0026#34;, count); return 0; } 邻接表(不常用) 邻接表是一种表示图的方法，它使用一个数组和链表来表示图中顶点之间的连接关系。\n在邻接表中，数组的每个元素表示一个顶点，而链表则表示与该顶点相邻的其他顶点。\n例如，如果顶点 A 与顶点 B 和顶点 C 相邻，则在邻接表中，A 的链表中就会包含 B 和 C。\n基本思想： 为图中的每个顶点创建一个链表。 每个链表存储与该顶点相邻的所有顶点。\n具体实现：\n可以使用数组来存储顶点，数组的每个元素指向一个链表，该链表存储与该顶点相邻的所有顶点。 链表可以使用单链表来实现。\n链式前向星 链式前向星主要由两个数组和一个结构体组成。\nhead[]: 表示以i为起点的第一条边的编号 edge[]: 表示所有边的信息 cnt: 表示边的数量\n结构体：\nstruct edge{ int w; // 表示边的权值 int to; // 表示边的终点 int next; // 表示与起点相同的下一条边的编号 }edge[maxn]; // 表示边的信息\nstruct edge{ int w; // 表示边的权值 int to; // 表示边的终点 int next; // 表示与起点相同的下一条边的编号 }edge[maxn]; // 表示边的信息 int head[maxn]; // 表示以i为起点的第一条边的编号 int cnt=0; // 表示边的数量 void add(int from, int to, int w){ edge[cnt].w = w; // 表示边的权值 edge[cnt].to = to; // 表示边的终点 edge[cnt].next = head[from]; // 表示与起点相同的下一条边的编号 head[from] = cnt++; // 表示以i为起点的第一条边的编号 } 适用于稀疏图。\n当链式前向星用于存储无向图时，每条边会被存储两次，一次是从起点到终点，一次是从终点到起点。\n链式前向星的基本思想是：\n为图中的每个顶点创建一个链表。 每个链表存储与该顶点相邻的所有顶点。 链表中的每个节点存储与该顶点相邻的顶点的编号。 链式前向星的优点是：\n链式前向星的空间复杂度比邻接表低。 链式前向星的时间复杂度比邻接表低。 链式前向星的实现比邻接表简单。 十字链表 十字链表是一种表示图的方法，它使用一个数组和链表来表示图中顶点之间的连接关系。\n在十字链表中，数组的每个元素表示一个顶点，而链表则表示与该顶点相邻的其他顶点。\n图的搜索算法 深度优先搜索 深度优先搜索（Depth-First Search，DFS）是一种用于遍历或搜索树或图的算法。\n连通图的遍历 从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。\n如果此时图中尚有顶点未被访问，则另选一个未曾被访问过的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止。\n从深度优先搜索遍历图的过程类似于树的先序遍历。 为了判别已访问的顶点，可设置一个访问标志数组visited[n]，其初值为FALSE（未访问）。 void DFS(Graph G, int v){ visited[v] = TRUE; //do what u want here for(w = FirstNeighbor(G, v); w \u0026gt;= 0; w = NextNeighbor(G, v, w)){ if(!visited[w]){ DFS(G, w); } } } 非连通图的遍历 对于非连通图，需要对每个连通分量分别进行遍历。\n广度优先搜索 广度优先搜索（Breadth-First Search，BFS）是一种用于遍历或搜索树或图的算法。\nBFS是按照路径的长度递增的次序来访问顶点的。\n过程：\n首先访问起始顶点v； 接着由v出发，依次访问v的各个未访问过的邻接点； 然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 为了保证访问的顺序，在BFS中会使用队列来存储顶点。\n（但是广度优先的题都可以使用深度优先算法解，并且还不用使用队列，所以BFS采用的比较少）\n","date":"March 9, 2025","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/dsa/graph/","series":[],"smallImg":"","tags":[],"timestamp":1741498647,"title":"图的搜索算法、知识点以及例题"},{"authors":[],"categories":[],"content":"C语言文件有两种储存类型\n文本文件\n储存量大 读写慢 便于对字符操作 存储格式：ASCII\n二进制文件\n储存小 速度快 便于存储中间结果 存储格式：二进制\n文件系统 C语言中使用的磁盘文件系统有两大类\n缓冲文件系统 特点是系统自动将文件的一部分内容读入内存，再由内存对文件进行操作。\n非缓冲文件系统 特点是系统直接对文件进行操作。\n文件的使用 在使用文件前，必须包含头文件\u0026lt;stdio.h\u0026gt;\nANSI C为正在使用的每个文件分配了一个文件系统，该文件系统包含文件的有关信息。\n类型为FILE的变量称为文件指针变量。\n文件结构体如下：\ntypedef struct{ short level;//缓冲区的当前级别 unsigned flags;//文件状态标志 char fd;//文件描述符 unsigned char hold;//未使用 short bsize;//缓冲区的大小 unsigned char *buffer;//数据传输缓冲区的位置 unsigned ar;//文件的当前读写位置 unsigned istemp;//临时文件指示器 short token;//用于有效性检查 }FILE; 文件使用示例：\nFILE *fp = fopen(\u0026#34;path\\\\file.txt\u0026#34;, \u0026#34;w\u0026#34;); if (fp == NULL) { printf(\u0026#34;文件打开失败\\n\u0026#34;); } else { printf(\u0026#34;文件打开成功\\n\u0026#34;); fprintf(fp, \u0026#34;Hello, world!\\n\u0026#34;); fclose(fp); } 文件打开时使用的路径可以使用相对路径或绝对路径。\n相对路径：从当前工作目录开始的路径。灵活，可移植性好\n绝对路径：从根目录开始的路径。方便，可移植性差\n文件打开模式 模式 功能 r 打开一个已有的文本文件，允许读取文件 w 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。如果文件已存在，则会截断文件，即删除文件中的所有内容 a 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。如果文件已存在，则会将写入的数据追加到文件的末尾 r+ 打开一个文本文件，允许读写文件 w+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。如果文件已存在，则会截断文件，即删除文件中的所有内容 a+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。如果文件已存在，则会将写入的数据追加到文件的末尾 rb 打开一个二进制文件，允许读取文件 文件操作 函数 功能 fopen 打开一个文件 fclose 关闭一个文件 fgetc 从文件中读取一个字符 fputc 向文件中写入一个字符 fgets 从文件中读取一个字符串 fputs 向文件中写入一个字符串 fprintf 向文件中格式化写入数据 fscanf 从文件中格式化读取数据 feof 检测文件是否到达末尾 fgets函数 fgets函数的原型如下：\nchar *fgets(char *str, int n, FILE *stream); fgets函数的作用是从指定的文件中读取至多n-1个字符，并将其存储在指定的字符数组中。读取字符直到遇见回车符或者EOF为止。\nfputs函数 fputs函数的原型如下：\nint fputs(char *str, FILE *stream); fputs函数的作用是将指定的字符串写入指定的文件中。\nfread函数 fread函数的原型如下：\nsize_t fread(void *ptr, size_t size, size_t count, FILE *stream); fread函数的作用是从指定的文件中读取指定数量的数据块，并将其存储在指定的内存地址中。\nfwrite函数 fwrite函数的原型如下：\nsize_t fwrite(void *ptr, size_t size, size_t count, FILE *stream); fwrite函数的作用是将指定的数据块写入指定的文件中。\nfgets,fputs和fread,fwrite的区别 fgets和fputs函数用于处理文本文件，而fread和fwrite函数用于处理二进制文件。\nfgets和fputs函数每次处理一个字符，而fread和fwrite函数每次处理一个数据块。\n数据块：数据块是指一组连续的内存单元，它们的大小由size参数指定。 fgets和fputs函数每次处理一个字符时，需要手动添加换行符，而fread和fwrite函数每次处理一个数据块时，不需要手动添加换行符。\n现在我们可以来解释一些程序中main函数的参数设计了\nint main(int argc, char *argv[]) { // 程序代码 return 0; } argc是一个整数，它表示命令行参数的数量。argv是一个指向字符串的指针数组，它包含了命令行参数的值。\n例如，假设我们在命令行中输入了以下命令：\n./program arg1 -i arg2 --v arg3 那么，argc的值将为4，argv的值将为：\n{ \u0026#34;program\u0026#34;, \u0026#34;arg1\u0026#34;, \u0026#34;-i\u0026#34;, \u0026#34;arg2\u0026#34;, \u0026#34;--v\u0026#34;, \u0026#34;arg3\u0026#34;, NULL } 文件指针的定位 stdio.h库中提供了用于文件指针定位的函数，它们的作用是将文件指针移动到指定的位置。函数如下：\n函数 功能 函数原型 fseek 将文件指针移动到指定的位置 int fseek(FILE *stream, long offset, int whence); ftell 获取文件指针当前的位置 long ftell(FILE *stream); rewind 将文件指针移动到文件的开头 void rewind(FILE *stream); fseek函数 fseek函数的作用是将文件指针移动到指定的位置。\nfseek函数的whence参数有以下取值：\n0 SEEK_SET：将文件指针移动到文件的开头，然后向文件的末尾移动offset个字节 1 SEEK_CUR：将文件指针移动到当前位置，然后向文件的末尾移动offset个字节 2 SEEK_END：将文件指针移动到文件的末尾，然后向文件的开头移动offset个字节 ","date":"December 23, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/c/file_c/","series":[{"title":"课堂笔记","url":"/series/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[],"timestamp":1734915334,"title":"文件"},{"authors":[],"categories":[],"content":" 结构体 为什么要使用结构体？\n变量：内置数据类型，但是相对独立，缺乏联系\n数组：可以存储多个变量，但是变量类型必须一致\n想要存储类型不同但是互相之间关联的数据\n结构体的声明 struct student{ char name[20]; char sex; int age; char job[40]; char address[40]; }; 结构体声明的一般形式： struct 结构体名{ 数据类型 成员变量名1; ... }; 结构体变量声明的一般形式： struct 结构体名 变量名; 也可以结合结构体声明和变量声明： struct student{ char name[20]; char sex; ... }stu1, stu2; stu1的内存大小是其所有成员变量的总大小，stu2的内存大小也是其所有成员变量的总大小。\n并且stu1和stu2是两个结构体变量，它们在内存中是独立的。\n结构体类型的嵌套定义： // birthday是student的成员变量 struct student{ char name[20]; char sex; struct birthday{ int year; int month; int day; }; }; //先声明birthday，再声明student struct birthday{ int year; int month; int day; }; struct student{ char name[20]; char sex; struct birthday birthday; }; //结构体的自引用 struct student{ char name[20]; char sex; struct student *next;//指向下一个结点的指针 }; 结构体变量的赋值 struct student{ char name[20]; char sex; int age; char job[40]; long num; char address[40]; }; //方法1:程序内赋值 int main(){ struct student stu; strcpy(stu.name,\u0026#34;张三\u0026#34;); stu.sex=\u0026#39;男\u0026#39;; stu.age=20; strcpy(stu.job,\u0026#34;学生\u0026#34;); stu.num=123456789; strcpy(stu.address,\u0026#34;北京\u0026#34;); } //方法2:从键盘输入 int main(){ struct student stu; printf(\u0026#34;请输入姓名:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,stu.name); printf(\u0026#34;请输入性别:\u0026#34;); scanf(\u0026#34; %c\u0026#34;,\u0026amp;stu.sex); printf(\u0026#34;请输入年龄:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;stu.age); printf(\u0026#34;请输入工作:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,stu.job); printf(\u0026#34;请输入学号:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;stu.num); printf(\u0026#34;请输入家庭住址:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,stu.address); } 同时，stu1=stu2是合法的，其结果是将stu2中所有元素的值赋给stu1\n需要注意的是，结构体变量之间不能直接比较，只能比较其元素\n结构体数组 结构体数组的定义的形式：\nstruct student{ char name[20]; int num; char address[20]; ... }; struct student stu[5]; for (int i = 0; i \u0026lt; 5; i++){ scanf(\u0026#34;%s %d %s\u0026#34;,stu[i].name,\u0026amp;stu[i].num,stu[i].address); } 似乎少了什么东西……\n指向结构体变量的指针 指针变量指向任一与指针变量类型一致的变量存储区域，同样可以定义指针变量来指向结构体变量\n定义指针变量p1,p2，可用如下方式指向结构体类型变量：\np1=\u0026amp;stu1;\np2=\n指向结构体变量的指针访问结构体成员： 结构体指针变量名 -\u0026gt; 成员变量名：\np1 -\u0026gt; name\n或\n(*结构体指针变量名).成员变量名：\n(*p1).name\n结构体与函数 C语言允许使用结构体作为函数的参数，将结构体成员逐个复制到形参中\n将实参结构体变量成员的值赋给形参结构体变量的成员，是单向的值传递。后续对形参的修改，不会影响实参。\n函数的返回值也可以是结构体类型\n指向结构体的指针变量作为函数参数，是将实参结构体数组或结构体变量的起始地址传递给形参指针变量，这样可以提高函数的效率。\nvoid func_1(struct student stu){//形参是结构体变量 ... } void func_2(struct student *p){//形参是结构体指针变量 ... } void func_3(struct student stu[]){//形参是结构体数组 ... } 结构体类型和普通类型的相似性 结构体变量的声明和定义与普通类型声明和定义相似\n例如：\n对整形类型变量的声明和定义：\nint a; int b[5]; int *c; int *d[5]; 相似的，对结构体类型变量的声明和定义：\nstruct student{ char name[20]; char sex; int age; char job[40]; char address[40]; ... }; struct student stu1; struct student stu2[5]; struct student *p1; struct student *p2[5];//数组指针 应用例：链表 链表是一种特殊的线性表，它不是连续存储的，而是由一系列的结点组成，每个结点包含一个数据元素和指向下一个结点的指针。\n创建链表 一般步骤：\n定义链表的数据结构\n定义头节点，置指针域为空，表示创建了一个空表\n申请一个结点储存单元\n将新结点的指针成员设为空。若是空表将新结点接到表头，若是非空表，将新结点接到表尾\n循环，直到无新结点需要接入\nstruct student{ char name[20]; int data; struct student *next; } struct student *create(struct student *head){ } ","date":"December 11, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/c/structure_1/","series":[{"title":"课堂笔记","url":"/series/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[],"timestamp":1733882045,"title":"结构体与共用体"},{"authors":[],"categories":[],"content":"树是一种数据结构。\n树的概念 树的定义 树是n个结点的有限集合（记为T）。\n形式化定义（二元组）\n树：$T=(D,R)$。\n$D$ 是包含n个结点的有限集合 $n\u0026gt;0$ 。\n当n=0时，称该树为空树。 当n\u0026gt;0时，这n个结点中存在一个唯一结点作为树的根结点，其余结点可分为m个互不相交的有限集 $T_1,T_2,\u0026hellip;,T_m$ ，其中每个集合本身又是一棵树，称为根的子树。\n$R$ 是D上的一个关系，$R\\subset D\\times D$ 。\n树的表示 逻辑表示法 即我们平时常见的树形图\n文氏图表示法 凹入表示法 括号表示法 例如：\nA(B(D,E),C(F,G))\n树的基本术语 结点的度和树的度 树中一个结点的子树的个数称为该结点的度。\n树中各个结点的度的最大值称为树的度，通常若树的度为m，称该树为m叉树。\n分支结点与叶结点 度不为0的结点称为非终端结点，也称为分支结点。\n度为0的结点称为终端结点，也称为叶结点。\n路径与路径长度 两个结点$d_i$和$d_j$之间的路径为从$d_i$到$d_j$的结点序列。\n路径的长度为路径上的结点个数减一。\n孩子结点、双亲结点和兄弟结点 每个结点的后继结点称为该结点的孩子结点。\n该结点被称为孩子结点的双亲结点。\n具有相同双亲结点的结点称为兄弟结点。\n深度优先搜索 从根结点出发，沿着一条路径搜索，直到到达一个叶子结点，然后回溯，继续沿着另一条路径搜索，直到到达另一个叶子结点，以此类推。\n一般采用递归的方式实现。\n广度优先搜索 从根结点出发，先访问所有的兄弟结点，再访问所有的孩子结点，以此类推。\n一般采用队列的方式实现。\n子孙结点和祖先结点 子孙结点：从根结点到该结点的路径上的所有结点称为该结点的子孙结点。\n祖先结点：从该结点到根结点的路径上的所有结点称为该结点的祖先结点。\n结点的层次和高度 待补充 有序树和无序树 若树中各结点的子树从左到右是有次序的，且相对次序是不能随意变换的，称该树为有序树。否则，称该树为无序树。\n森林 n个互不相交的树的集合称为森林。\n给m棵独立的树加一个根结点，则森林就变成了一棵树。\n树的性质 树中的结点数等于所有结点的度数加1。（加1是加上根结点） 度为m的树的其他重要特性： 结点个数为n，$n=n_0+n_1+n_2+\u0026hellip;+n_m$，其中$n_0$为度数为0的结点数，$n_1$为度数为1的结点数，$n_2$为度数为2的结点数，以此类推。 所有结点度之和=$n_1+2n_2+3n_3+\u0026hellip;+mn_m=n-1$。 度为m的树中第i层上至多有$m^{i-1}$个结点。 高度为h的m叉树至多有$\\frac {m^h-1}{m-1}$个结点。 具有n个结点的m叉树的最小高度为$\\lceil log_m(n(m-1)+1) \\rceil$，最大高度为$n-m+1$。 树的基本运算 树的遍历运算是指按某种方式访问树中的每个结点，且每个结点仅被访问一次。\n主要的遍历方法：\n先根遍历 先访问根结点，再依次先根遍历各子树。 后根遍历 先依次后根遍历各子树，再访问根结点。 层次遍历 从第一层（根结点）开始，从上到下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。 注意：先根遍历和后根遍历都是使用递归实现的。\n树的储存结构 双亲储存结构 typedef struct{ ElemType data;//结点的值 int parent;//指向双亲结点的伪指针 }PTree[MaxSize]; 孩子储存结构 typedef struct{ ElemType data;//结点的值 struct node *sons[MaxSons];//指向孩子结点的指针 }TSonNode; 孩子兄弟储存结构 typedef struct{ ElemType data;//结点的值 struct node *firstson;//指向第一个孩子结点的指针 struct node *nextbrother;//指向右兄弟结点的指针 }TSBNode; 使用链表实现\n二叉树 二叉树的定义 二叉树是\n满二叉树 所有结点都有两个孩子结点。 所有叶子结点都在同一层。 满二叉树的性质 高度为h的满二叉树的结点个数为$2^h-1$。\n完全二叉树 只有最下面两层有叶子结点。 最下面一层的叶子结点都集中在最左边。 二叉树的性质 非空二叉树上叶结点数等于双分支结点数加1。即：$n_0=n_2+1$。 求解一般二叉树结点个数方法 度之和=$n-1$。 $n=n_0+n_1+n_2$。 又:$n_0=n_2+1$。 得：$n=n_1+2n_2+1$。\n非空二叉树上第i层上至多有$2^{i-1}$个结点。 完全二叉树的性质 $n_1=0$或$n_1=1$，由n的奇偶性决定，n为奇数时$n_1=1$，n为偶数时$n_1=0$。 若一个结点的编号为i，则该结点的左孩子的编号为$2i$，右孩子的编号为$2i+1$。 并查集 并查集是一种树形的数据结构，用于处理不相交集合(Disjoint Sets) 的合并与查询问题。它特别适合解决动态连通性问题，比如判断两个元素是否属于同一个集合，或将两个集合合并。\n并查集的数据结构记录了一组动态集合\n","date":"November 30, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/c/tree_1/","series":[],"smallImg":"","tags":[],"timestamp":1732926506,"title":"树与二叉树"},{"authors":[{"title":"Falling_MY","url":"/authors/falling_my/"}],"categories":[],"content":"串，及字符串，是由零个或多个字符组成的有限序列。一般记为： $$ S = \u0026lsquo;a_1a_2a_3\u0026hellip;a_n\u0026rsquo; (n\u0026gt;0)$$\n串是一种特殊的线性表，数据元素之间呈线性关系。 串的数据对象是字符的有限序列。\n串的基本操作 StrAssign(\u0026amp;T, chars) 赋值操作，把串T赋值为chars StrCopy(\u0026amp;T, S) 复制操作，把串S复制给串T StrEmpty(S) 判空操作，若S为空串，则返回true，否则返回false StrLength(S) 求串长，返回串S的元素个数 ClearString(\u0026amp;S) 清空操作，将S清空 DestroyString(\u0026amp;S) 销毁串，将串S销毁 Concat(\u0026amp;T, S1, S2) 串联接，用T返回由S1和S2联接而成的新串 SubString(\u0026amp;Sub, S, pos, len) 求子串，用Sub返回串S的第pos个字符起长度为len的子串 Index(S, T, pos) 定位操作，若主串S中存在与串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则函数值为0 StrCompare(S, T) 比较操作，若S\u0026gt;T，则返回值\u0026gt;0，若S=T，则返回值=0，若S\u0026lt;T，则返回值\u0026lt;0 串的存储结构 串的顺序存储结构 顺序存储都是一个字符串数组+串长度，分为\n静态数组实现（定长顺序存储）： 栈区，数组长度固定 动态数组实现（堆分配存储）： 堆区，数组长度可变 char[0]一般不使用，从char[1]开始存储。 因为在C语言中，字符串是以\u0026rsquo;\\0\u0026rsquo;结尾的，所以char[0]存储的是字符串的长度。\n//Power by Marscode //静态数组实现：按预定义MAXLEN在栈区开辟储存区 #define MAXSIZE 255 typedef struct{ char ch[MAXSIZE]; int length; }StringNode; //Power by Marscode //动态数组实现：按串场在堆区开辟储存区，ch指向串的基地址，用完需要手动删除指针 typedef struct{ char *ch; int length; }HString; HString S; S.ch = new char[MAXSIZE];//在堆区开辟空间, 用完需要手动删除指针 S.length = 0; 串的链式存储结构 //Power by Marscode //结点结构和串结构：每个节点存多个字符 typedef struct StringNode{ char ch[4]; struct StringNode* next; }StringNode, *String; 串基本操作的实现 //求子串 bool SubString(StringNode \u0026amp;Sub, StringNode S, int pos, int len){ if(pos + len - 1 \u0026gt; S.length){ return false; }//子串范围越界 for(int i = pos; i \u0026lt; pos + len; i++){ Sub.ch[i - pos + 1] = S.ch[i]; }//子串赋值 Sub.length = len; return true; } //定位操作 int Index(StringNode S, StringNode T, int pos){ int i = pos; int j = 1; while(i \u0026lt;= S.length \u0026amp;\u0026amp; j \u0026lt;= T.length){ if(S.ch[i] == T.ch[j]){ ++i; ++j; }else{ i = i - j + 2; j = 1; } } if(j \u0026gt; T.length){ return i - T.length; }else{ return 0; } } 字符串模式匹配 朴素模式匹配算法 一旦发现不匹配的字符，就回溯到主串的下一个字符，从模式串的第一个字符重新开始匹配。\n优化思路 对于模式串T=\u0026quot;abaabc\u0026quot;, 主串S=\u0026quot;ababaabc\u0026quot;，当匹配到S[5]和T[5]不匹配时，我们可以直接将模式串T向右移动3个字符，从T[3]开始匹配。 …… KMP算法 思路：KMP算法的核心是利用已经部分匹配的结果，避免主串的指针回溯。详细的说就是，当匹配到S[i]和T[j]不匹配时，我们可以直接将模式串T向右移动j-next[j]个字符，从T[next[j]]开始匹配。\n这样可以有效的减少匹配的次数，降低时间复杂度。最坏时间复杂度：O(m+n)\n待完善 ","date":"November 23, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/dsa/string_1/","series":[{"title":"竞赛培训课笔记","url":"/series/%E7%AB%9E%E8%B5%9B%E5%9F%B9%E8%AE%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[],"timestamp":1732333147,"title":"串"},{"authors":[{"title":"Falling_MY","url":"/authors/falling_my/"}],"categories":[],"content":" 定义 与栈不同，队列的两端都允许插入和删除操作。\n队列(Queue) 是只允许一端进行插入操作，而另一端进行删除操作的线性表。\n相关术语\n队头：允许删除的一端\n队尾：允许插入的一端\n空队列：无元素\n特点：先进先出\n基本操作 InitQueue(\u0026amp;Q) 初始化队列, 构造一个空队列Q DestroyQueue(\u0026amp;Q) 销毁队列, 释放Q占用的内存空间 EnQueue(\u0026amp;Q, x) 入队, 若队列Q未满, 则将x加入, 使之成为新的队尾 DeQueue(\u0026amp;Q, \u0026amp;x) 出队, 若队列Q非空, 则删除Q的队头元素, 并用x返回 GetHead(Q, \u0026amp;x) 读队头元素, 若队列Q非空, 则将队头元素赋值给x QueueEmpty(Q) 判断队列是否为空, 若队列Q为空, 则返回true, 否则返回false 队列的顺序实现 //Power by Marscode #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXSIZE 10 typedef struct{ ElemType data[MAXSIZE]; int front, rear;//队头指针和队尾指针 }SqQueue; //使用 void testQueue(){ SqQueue Q; //....... } //初始化时，队头和队尾指针都指向0 void InitQueue(SqQueue \u0026amp;Q){ Q.front = Q.rear = 0; } //销毁 void DestroyQueue(SqQueue \u0026amp;Q){ free(Q.data); Q.front = Q.rear = 0; } bool GetHead(SqQueue Q, ElemType \u0026amp;x){ if(Q.front == Q.rear){ return false; }//队空，报错 x = Q.data[Q.front];//出队 return true; } //入队 bool EnQueue(SqQueue \u0026amp;Q, ElemType x){ if ((Q.rear + 1) % MAXSIZE == Q.front){ return false; }//队满，报错 Q.data[Q.rear] = x;//入队 Q.rear = (Q.rear + 1) % MAXSIZE;//队尾指针加1 return true; } //出队 bool DeQueue(SqQueue \u0026amp;Q, ElemType \u0026amp;x){ if(Q.front == Q.rear){ return false; }//队空，报错 x = Q.data[Q.front];//出队 Q.front = (Q.front + 1) % MAXSIZE;//队头指针加1 //和栈的出栈相似，不需要真的删除元素，只需要逻辑上的出队 return true; } 循环队列 Q.data[Q.rear] = x;//入队 Q.rear = (Q.rear + 1) % MAXSIZE;//队尾指针加1 链式队列 链式队列分为两种：带头指针和不带头指针。\n带头指针的链式队列，头指针指向头结点，头结点的指针指向队头元素，尾结点的指针指向队尾元素。 不带头指针的链式队列，头指针和尾指针都指向队头元素。 //Power by Marscode #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXSIZE 100 typedef struct LinkNode{ ElemType data; struct LinkNode *next; }LinkNode; typedef struct{ LinkNode *front, *rear;//队头指针和队尾指针 }LinkQueue; //初始化 void InitQueue(LinkQueue \u0026amp;Q){ Q.front = Q.rear = (LinkNode *)malloc(sizeof(LinkNode)); Q.front-\u0026gt;next = NULL; } void EnQueue(LinkQueue \u0026amp;Q, ElemType x){ //申请新结点 LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode)); s-\u0026gt;data = x; s-\u0026gt;next = NULL; Q.rear-\u0026gt;next = s;//新结点插入到队尾 Q.rear = s;//队尾指针指向新结点 return true; } //出队 bool DeQueue(LinkQueue \u0026amp;Q, ElemType \u0026amp;x){ if(Q.front == Q.rear){ return false; }//队空，报错 LinkNode *p = Q.front-\u0026gt;next;//p指向队头元素 x = p-\u0026gt;data;//出队 Q.front-\u0026gt;next = p-\u0026gt;next;//头结点的指针指向队头元素的下一个元素 if(Q.rear == p){//如果队头元素是队尾元素 Q.rear = Q.front;//队尾指针指向头结点 } free(p); return true; } //销毁 void DestroyQueue(LinkQueue \u0026amp;Q){ while(Q.front!= NULL){ Q.rear = Q.front-\u0026gt;next;//队尾指针指向头结点的下一个元素 free(Q.front);//释放头结点 Q.front = Q.rear;//队头指针指向队尾指针 } } ","date":"November 23, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/dsa/queue/","series":[{"title":"竞赛培训课笔记","url":"/series/%E7%AB%9E%E8%B5%9B%E5%9F%B9%E8%AE%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[],"timestamp":1732326969,"title":"队列"},{"authors":[{"title":"Falling_MY","url":"/authors/falling_my/"}],"categories":[],"content":"2024.11.23 这里是大一的我。 自己目前还不是很能理解栈和队列的相关知识，只是简单的做一下竞赛课程的笔记。\n不是很了解，所以我就先把我目前学到的东西记录下来，以后再慢慢补充。\n我们在以后的数据结构再见吧！\n由于老师上课的速度很快，所以难免笔记会有疏漏，并且代码大部分由Marscode生成。 如果你发现有什么问题或者有什么建议，欢迎在评论区留言。\nBtw，如果你觉的这篇文章对你有帮助，不妨点个赞吧⬇️ 👍 栈(stack) 定义 线性表是具有相同数据结构的n个元素的有限序列\n栈是只允许一段进行插入或删除操作的线性表\n相关术语 栈顶：允许插入和删除的一段 栈底：不允许操作的一段 空栈：无元素\n特点：先进后出\n基本操作 线性表 初始化 构造一个空的线性表，分配内存空间 销毁 释放线性表所占用的内存空间 插入 在指定位置插入元素 删除 删除指定位置的元素，并返回值 按值查找 查找具有给定关键字值的元素 按位查找 栈 初始化 销毁 进栈 Push(\u0026amp;s, x) 出栈 Pull(\u0026amp;s, \u0026amp;x) 查 获取栈顶元素 顺序栈的实现 定义 //Powered By Marscode #define MAXSIZE 10 typedef struct{ ElemType data[MAXSIZE]; int top;//栈顶指针，指向栈顶元素 }SqStack; //使用 void testStack(){ SqStack Q; //....... } void Init(SqStack \u0026amp;s){ s.top = -1; }// 初始化 bool Push(SqStack \u0026amp;s, ElemType \u0026amp;x){ if(s.top == MAXSIZE - 1){ return false; }//栈满，报错 s.data[++s.top] = x;//指针先加1，再入栈 return true; }// 入栈 bool Pop(SqStack \u0026amp;s, ElemType \u0026amp;x){ if(s.top == -1){ return false; }//栈空，报错 //考虑算法的时候要首先考虑异常情况 x = s.data[s.top--];//先出栈，指针再减1 //只需要逻辑上的出栈，无需真的删除元素 //函数运行结束之后会自动释放内存空间 return true; }// 出栈 bool GetTop(SqStack \u0026amp;s, ElemType \u0026amp;x){ if(s.top == -1){ return false; }//栈空，报错 x = s.data[s.top]; return true; }// 取栈顶元素 bool StackEmpty(SqStack \u0026amp;s){ if(s.top == -1){ return true; }else{ return false; } }// 判断栈是否为空 栈的链式存储 //链栈的结点结构、栈类型定义 typedef struct StackNode{ ElemType data; struct StackNode *next; }StackNode, *LinkStack; 例题1 题目描述： 给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。 输入格式： 第一行包含整数N，表示数列长度。 第二行包含N个整数，表示整数数列。 输出格式： 共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。 输入样例： 5 3 4 2 7 5 输出样例： -1 3 -1 2 2\n思路: 从前往后遍历数组 用栈维护一个单调递增的序列 如果栈顶元素大于当前元素，则弹出栈顶元素，直到栈顶元素小于当前元素或者栈为空 如果栈为空，则当前元素左边没有比它小的元素，输出-1 如果栈不为空，则栈顶元素就是当前元素左边第一个比它小的元素，输出栈顶元素 将当前元素入栈 // Powered By Marscode //参考代码 #include \u0026lt;stdio.h\u0026gt; #define MAXN 1000010 int n, top, stk[MAXN]; // 定义变量 n 表示数列长度，top 表示栈顶指针，stk 数组用于存储栈中的元素 int main(){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // 读入数列长度 for(int i = 0; i \u0026lt; n; i++){ int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); // 读入当前数 while(top \u0026amp;\u0026amp; stk[top] \u0026gt;= x){ // 如果栈顶元素大于等于当前数，弹出栈顶元素 top--; } if(top){ // 如果栈不为空 printf(\u0026#34;%d \u0026#34;, stk[top]); // 输出栈顶元素，即当前数左边第一个比它小的数 }else{ printf(\u0026#34;-1 \u0026#34;); // 如果栈为空，输出 -1 } stk[++top] = x; // 将当前数入栈 } return 0; } 例题2 题目描述： 斐波那契数(通常用F(n)表示)形成的序列称为斐波那契数列，该数列由0和1开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中n \u0026gt; 1 给定一个整数n，请计算F(n)。\n思路： 如果我们不使用递归的方式，直接使用栈，那又该如何求解呢？\n思路非常的简单。比如说我们求F(4),我们需要一个栈来存储F(1)和F(2)。然后我们依次取出栈顶元素，计算F(3)，然后将F(3)入栈。以此类推，直到我们计算出F(4)为止。\n// Powered By Marscode // 参考代码 #include \u0026lt;stdio.h\u0026gt; #define MAXN 1000010 int n, top, stk[MAXN]; // 定义变量 n 表示数列长度，top 表示栈顶指针，stk 数组用于存储栈中的元素 int main(){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // 读入数列长度 if (n \u0026lt;= 0){ printf(\u0026#34;0\\n\u0026#34;); // 如果 n \u0026lt;= 0，输出 0 } if (n == 1 || n == 2){ printf(\u0026#34;1\\n\u0026#34;); // 如果 n == 1，输出 1 } top = 0; // 初始化栈顶指针 stk[++top] = 1; // 将 F(1) 入栈 stk[++top] = 1; // 将 F(2) 入栈 for(int i = 3; i \u0026lt;= n; i++){ // 从 F(3) 开始计算 int a = stk[top - 1]; // 取出栈顶元素 int b = stk[top]; // 取出栈顶元素 stk[++top] = a + b; // 将 F(i) 入栈 } printf(\u0026#34;%d\\n\u0026#34;, stk[top]); // 输出栈顶元素，即 F(n) return 0; } 例题3 题目描述： 在编程当中，我们经常需要处理括号匹配的问题。例如，在编写一个编译器的时候，我们需要检查括号是否匹配。括号匹配指的是，对于一个给定的括号序列，其中的括号必须是成对出现的，并且每个右括号都必须与其对应的左括号匹配。 样例输入： {([])} 样例输出： YES\n思路 如果字符是左括号，则入栈；如果字符是右括号，则出栈。如果出栈的字符不是对应的左括号，则不匹配。如果栈为空，则匹配。\n// Powered By Marscode // 参考代码 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXN 1000010 int n, top, stk[MAXN]; // 定义变量 n 表示数列长度，top 表示栈顶指针，stk 数组用于存储栈中的元素 int main(){ char s[MAXN]; // 定义字符串 s scanf(\u0026#34;%s\u0026#34;, s); // 读入字符串 n = strlen(s); // 计算字符串长度 top = 0; // 初始化栈顶指针 for(int i = 0; i \u0026lt; n; i++){ // 遍历字符串 if(s[i] == \u0026#39;(\u0026#39; || s[i] == \u0026#39;[\u0026#39; || s[i] == \u0026#39;{\u0026#39;){ // 如果是左括号 stk[++top] = s[i]; // 将左括号入栈 }else{ // 如果是右括号 if(top == 0){ // 如果栈为空 printf(\u0026#34;NO\\n\u0026#34;); // 输出 NO return 0; // 结束程序 } char c = stk[top--]; // 取出栈顶元素 if(s[i] == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; c!= \u0026#39;(\u0026#39;){ // 如果右括号和左括号不匹配 printf(\u0026#34;NO\\n\u0026#34;); // 输出 NO return 0; // 结束程序 } if(s[i] == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; c!= \u0026#39;[\u0026#39;){ // 如果右括号和左括号不匹配 printf(\u0026#34;NO\\n\u0026#34;); // 输出 NO return 0; // 结束程序 } if(s[i] == \u0026#39;}\u0026#39; \u0026amp;\u0026amp; c!= \u0026#39;{\u0026#39;){ // 如果右括号和左括号不匹配 printf(\u0026#34;NO\\n\u0026#34;); // 输出 NO return 0; // 结束程序 } } } if(top == 0){ // 如果栈为空 printf(\u0026#34;YES\\n\u0026#34;); // 输出 YES }else{ // 如果栈不为空 printf(\u0026#34;NO\\n\u0026#34;); // 输出 NO } return 0; } ","date":"November 23, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/dsa/staker_1/","series":[{"title":"竞赛培训课笔记","url":"/series/%E7%AB%9E%E8%B5%9B%E5%9F%B9%E8%AE%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[],"timestamp":1732321653,"title":"栈"},{"authors":[],"categories":[],"content":" C语言能处理一类非常特殊的数据——内存地址（常量）\n如果这篇文章有帮到你的话，不妨点个赞吧\n👍 引入 计算机内部有很多储存单元，每个储存单位都用唯一的地址编号（表示为一个整数加以区别），简称为地址\n或者说\n内存中每个字节都有一个编号——地址\n指针使程序的不同部分能共享数据（地址唯一性）\n指针 指针自身的是一个变量，内容为地址变量。指针自身被称为指针变量（也作指针）。\n指针变量指向目标变量。\nchar *p,x; x = \u0026#34;A\u0026#34;; p = \u0026amp;x; *为取目标运算\n\u0026amp;为取地址运算\n空指针 int *p = 0; int p = null; 定义了一个空指针\n指向的目标变量为null\n作用 任何变量一旦定义就有值\n在不知道指针的指向时，将其定义为空指针\n无类型指针 void *p; void意思为该指针的目标类型当前未知\n在知道目标类型之后，可用强制类型转换将空类型指针转为整形指针或字符型指针\n(int*) p; (char*) p; 例 数字交换 #include\u0026lt;stdio.h\u0026gt; void swap(int *p1,int *p2){ int tmp; tmp = *p1;//储存p1目标变量值[a] *p1 = *p2;//将p2的目标变量值[b]赋值给p1 *p2 = tmp;//将p1的原目标值[a]赋值给p2 }//将a,b地址的变量进行交换操作 int main (){ int a, b; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); swap(\u0026amp;a, \u0026amp;b); printf(\u0026#34;%d %d\\n\u0026#34;, a, b); } 指针与函数 指针可以是函数的参数也可以是函数的返回值\n如果返回值是地址/指针的话，函数声明时也要加上*\nint *fun(int *x, int *y); 注意：应当注意当函数返回地址时，地址对应的空间是否被释放\n数组指针作函数参数 int max(int x[], int n); //其中x[]传入的实际上是指针，也可以写作下面这样 int max(int *x, int n); 数组指针作为函数参数中实参和形参的对应关系：\n若int a[3][4]; int (*p1)[4]=a; int *p2=a[0]\n形参 实参 数组定义int x[][4] 数组名a 指针变量int (*q)[4] 数组名a 数组定义int x[][4] 指针变量p1 指针变量int (*q)[4] 指针变量p1 指针变量int *q 指针变量p2 题外话：二维数组定义时第二个参数不可省略 a[n][m],a[][m]都是正确的\na[][],a[n][]是错误的\n原因是我们应该告诉程序行指针每一行有多少数字，每次移动应该跨越多少\n指针和数组 数组名就是数组在内存存储区域的首地址（常称为数组的指针），并且为常量\n指针变量可以用于存储变量的地址，也可存放数组的指针或数组元素的指针\n由于数组是连续占用内存，所以可以使用指针+位移来访问整个数组\n用一个指针变量来存储这个数组的首地址；数组和数组元素的引用，也可以通过使用指针的方式进行间接访问\nint arr[10]; int* p; p = a;//等价于p = \u0026amp;a[0] 指针间接访问数组元素 p+i和a+i都可以表示数组元素a[i]的地址 间接访问*(p+i)和*(a+i)就表示为数组的各元素即等效于a[i] *(p+i)$\\lrArr$p[i]$\\lrArr$a[i]$\\lrArr$*(a+i) 指针移动注意事项 必须指向连续储存空间 移动到的储存区域必须有意义 指针和二维数组 二维数组在内存当中其实是一维的\n拆分地来看，对于一个二维数组，可以用一维数组代替地理解。\n不同的拆分方法诞生了不同的访问方法\n列地址 +1跨过一列\n例如：a[0][0]可以视为一维数组a[0]的第1个值\na[i]+j$\\lrArr$\u0026amp;a[i][0]+j$\\lrArr$\u0026amp;a[i][j]\n故可以使用*(a[i]+j)访问a[i][j]\n行地址 +1跨过一整行\n如果将行看作一个数列，则可以先通过行进行访问\n思考过程如下：\n假设我们要访问二维数组arr[N][N]中的某个元素arr[i][j]\n首先我们要取到指定行 将行看为一个一维数组arr[N] 取到第i个元素的地址arr+i 取第i个元素，即到达第i行*(arr+i)$\\lrArr$arr[i]$\\lrArr$\u0026amp;arr[i][0](二级指针) 此时也正好为第i行的第一个元素的地址 接下来开始取到指定元素 进行列指针位移*(arr+i)+j 取元素*(*(arr+i)+j)$\\lrArr$arr[i][j] 二维数组的行指针 变量声明：数组的数据类型 (*指针变量名)[m];\n意义：声明指针指向m列的二维数组，或指向有m个元素的一维数组\n（可以理解为m表示了指针每次移动的步长）\nint a[3][4]; int (*p)[4]; //赋值 p=a; p=\u0026amp;a[0];//等价 指针与字符数组 实现字符串引用有两种办法：\n字符数组 指向字符串的指针 其余的感觉和数组差不多…………\n注意一下\\0就好了\n字符数组和字符指针处理字符串的比较 储存上的区别 字符数组由若干元素组成，每个元素储存一个字符 字符指针变量中储存的是字符串的首地址 传递上的区别 字符数组名作为函数参数时，传递的是整个数组 字符指针变量作为函数参数时，传递的是字符串的首地址 //使用数组形式 char str[] = \u0026#34;Hello World!\u0026#34;;//不定义数组长度 char str[13] = \u0026#34;Hello World!\u0026#34;;//定义数组长度 //使用指针形式 char *p = \u0026#34;Hello World!\u0026#34;; 指针数组 数组元素是指针的数组\n定义形式 类型标识 *数组名[数组长度]\nchar *p[10]; 由于[]的优先级高于*，所以先和p结合，形成一个数组形式 再由char*说明这是一个指针数组，它有10个指针类型的数组元素。这里执行p+1时，p要跨过10个char*的长度。\n注意区分： char *p[10]表示这是一个指针数组，它有10个指针类型的数组元素，其首元素的地址为p[0]，类型为char *即是一个字符指针。\nchar (*p)[10]表示这是一个数组指针，它指向一个一维数组，这个一维数组的长度为10，类型为char *，即一个字符指针。\n指针数组用的最多的是“字符串型指针数组”，利用字符指针数组可以指向多个长度不同的字符串，使字符串的处理更加方便灵活，节省空间。\n使用指针数组排序时不需要移动字符串，只需要移动指针\n//对已排好序的字符指针数组进行指定字符串的查找 //二分查找 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; /* 测试数据： Amanda Bob Chris Follow Jill William Follow */ int bianrysearch(char *p[],char *x,int n){ //p为字符串指针数组，x为要查找的字符串，n为数组长度 int mid,low=0,high=n-1; while(low\u0026lt;=high) { mid = (low+high)/2; if(strcmp(p[mid],x)==0) return mid; else if(strcmp(p[mid],x)\u0026gt;0) high = mid-1; else low = mid+1; } return -1; } int main(){ //char *name[]={\u0026#34;Amanda\u0026#34;,\u0026#34;Bob\u0026#34;,\u0026#34;Chris\u0026#34;,\u0026#34;Follow\u0026#34;,\u0026#34;Jill\u0026#34;,\u0026#34;William\u0026#34;}; char *name[6]; for(int i=0;i\u0026lt;6;i++) name[i] = (char *)malloc(10*sizeof(char)); printf(\u0026#34;请输入6个字符串：\\n\u0026#34;); for(int i=0;i\u0026lt;6;i++) gets(name[i]); int i,index; char findname[10]; printf(\u0026#34;请输入要查找的内容：\\n\u0026#34;); gets(findname); index = bianrysearch(name,findname,6); if(index==-1) printf(\u0026#34;没有找到\\n\u0026#34;); else printf(\u0026#34;在第%d个位置\\n\u0026#34;,index+1); for(int i=0;i\u0026lt;6;i++) free(name[i]);//释放内存空间 return 0; } 指针的地址分配 当定义指针变量时，系统会自动分配一个地址给指针变量\n在stdlib.h中提供了两个函数malloc()和free()用来分配和释放内存\n函数原型为：\nvoid *malloc(unsigned int size); void free(void *p); malloc()用以向操作系统申请size个字节的内存空间，并返回该内存空间的首地址。需要注意的是，size的值应和要指向的变量类型的字节数一致。\nfree()用来释放malloc()函数所申请的内存空间。\n例：\n//两个字符串的交换 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char *p1,*p2; p1 = (char *)malloc(100); p2 = (char *)malloc(100); gets(p1); gets(p2); printf(\u0026#34;交换前：\\n\u0026#34;); printf(\u0026#34;p1=%s\\np2=%s\\n\u0026#34;,p1,p2); char *temp; temp = (char *)malloc(100); strcpy(temp,p1); strcpy(p1,p2); strcpy(p2,temp); printf(\u0026#34;交换后：\\n\u0026#34;); printf(\u0026#34;p1=%s\\np2=%s\\n\u0026#34;,p1,p2); free(p1); free(p2); free(temp); return 0; } 指向指针的指针变量 概念： 如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。\n这个指针也被称为二级指针变量。\n例如：\nint a = 100; int *p = \u0026amp;a;//p存放a的地址 int **pp = \u0026amp;p;//pp存放p的地址 printf(\u0026#34;%d\\n\u0026#34;,**pp);//输出100 printf(\u0026#34;%d\\n\u0026#34;,*pp);//输出p的地址 指向函数的指针变量 ","date":"November 18, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/c/pointer/","series":[{"title":"课堂笔记","url":"/series/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[],"timestamp":1731888486,"title":"指针"},{"authors":[{"title":"Falling_MY","url":"/authors/falling_my/"}],"categories":[],"content":" 插入排序 Insertion Sort 从新元素开始，从后向前扫描直到扫描到的元素小于等于新元素\n则将新元素插入扫描到的元素前\n代码实现\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { int arr[8] = {5,6,1,7,5,3,1,4}; for (int i = 1; i \u0026lt; 8;i++) {//从第二位开始遍历数组 int j = i -1; int cur = arr[i];//储存当前数字 while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt;= cur) {//向前遍历 arr[j+1] = arr[j];//将前面的数字向后移动一位 j--; arr[j+1] = cur;//插入数字 } } for (int i = 0; i \u0026lt; 8; i++) {//输出排好序的数组 printf(\u0026#34;%d\u0026#34;,arr[i]); } system(\u0026#34;pause\u0026#34;); } 时间复杂度：O(n^2^) 空间复杂度：O(1) 快速排序 Quick Sort 快排是一种分治(Divide and Conquer)算法，在这种算法\n中，我们把大问题变成小问题，然后将小问题逐个解决，当\n小问题解决完时，大问题也迎刃而解\n步骤\n1.对于当前的数组，取最后一个元素当做基准数 (pivot)\n2.将所有比基准数小的元素排到基准数之前，比基准数大的排在基准数之后\n3.当基准数被放到准确的位置之后，根据基数数的位置将数组切分为前后两个子数组\n4对子数组采用步骤1~4的递归操作，直到子数组的长度小于等于1为止\n","date":"September 8, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/dsa/3/","series":[],"smallImg":"","tags":[],"timestamp":1725757116,"title":"排序算法"},{"authors":[{"title":"Falling_MY","url":"/authors/falling_my/"}],"categories":[],"content":" 时间空间复杂度 如何判断一个算法的好坏？\n我们需要一种复杂度计算方式，不受计算机性能和程序数据的影响\n时间复杂度 BigO BigO计算表示一个算法的渐进时间复杂度\nT(n) = O(f(n)) f(n) 表示代码执行次数之和，O表示正比例关系\n复杂度越低代码效率越高\ne.g. 1 for (int i = 1; i \u0026lt;= n; i++) { x++; } 首先int i = 1为一次运算\n其次，每次循环中会分别执行i \u0026lt;= n、i++、x++三次运算\n则n次循环下会执行3n次\n总共运算1+3n次，那么这个算法复杂度则为O(n)\n因为BigO用于表示计算的增长变化趋势，所以当n无限大时，常数1和系数3可忽略不计\ne.g. 2 for (int i = 1; i\u0026lt;= n; i++){ for(int j =1; j \u0026lt;= n; j++){ x++; } } 在这个双层循环中，内外层各需运行n次\n则其时间复杂度为O(n^2^)\n当我们将例一例二合起来时，时间复杂度应为多少呢？\n你可能会认为是 O(n+n^2^)\n然而，当n趋近于无穷大时，线性的n远远小于n^2^\n所以此时的时间复杂度应为 O(n^2^)\n常见的时间复杂度量级 常数阶O(1)\n对数阶O(logN)\n线性阶O(n)\n线性对数阶O(lognN)\n平方阶O(n^2^)\n立方阶O(n^3^)\nK次方阶O(n^k^)\n指数阶(2^n^)\n阶乘O(n!)\n其他复杂度指标 O(Big O)\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;最差情况\nΩ(big Omega) \u0026hellip;最好情况\nΘ(big theta) \u0026hellip;\u0026hellip;.一个算法区间\n空间复杂度 内存空间增长的趋势\n常用的空间复杂度 O(1) O(n) O(n^2^)\ne.g.3 O(1)空间复杂度 int x = 0; int y = 0; x++; y++; 如果算法执行所需要的临时空间不随着某个变量n的大小而变化，此算法空间复杂度为一个常量，可表示为 O(1)\n其中x, y所分配的空间不随着处理数据量变化，因此「空间复杂度」为 O(1)\ne.g.4 O(n)空间复杂度 ","date":"September 3, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/dsa/2/","series":[],"smallImg":"","tags":[],"timestamp":1725355985,"title":"2.时间空间复杂度、BigO表示法"},{"authors":[{"title":"Falling_MY","url":"/authors/falling_my/"}],"categories":[],"content":" 数据结构与算法 数据结构是程序储存信息的基本单位，数组就是常见的数据结构。而算法则是实现特定任务的计算步骤，比如排序算法和搜索算法的目的顾名思义就是排序和搜索。\n但数据结构和算法不一定像数组和二分查找这个例子这样是完全分开的单独内容。数组是最简单的数据结构，而很多其他复杂的数据结构往往又集成了很多的算法在其中。\n所以可以这样理解\n程序 = 数据结构 + 算法\n数据结构 官方定义\n数据结构是计算机存储、组织数据的方式\n但是在很多情况中，数据结构不仅包含数据本身，还会包含一些算法\n算法 官方定义\n算法是一系列规定的计算步骤，为了实现特定的计算目的\n","date":"September 3, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/notes/dsa/1/","series":[],"smallImg":"","tags":[],"timestamp":1725355359,"title":"1.数据结构和算法简介, 二分查找"},{"authors":[{"title":"Falling_MY","url":"/authors/falling_my/"}],"categories":[],"content":" 写在前面 本文内容量较大，请结合大纲跳转功能使用\n学分 知乎解释 学分是一种用于计算学生学习量的计量单位，按学期计算，每门课程及实践环节的具体学分数以专业教学计划的规定为准。通过考核，成绩合格方可取得该课程学分。每一门课程都有一定的学分，只有通过这门课的考试，才能获得相应的学分，也只有学分积累到专业要后才能毕业。\n你♥对学分的解释 学分是学生学习量的计量单位，原则上规定:\n理论课16学时为1学分\n体育及实验课32学时为1学分\n集中性实践教学环节1周为1学分\n官方文档 总结一下 完成课程，并在考试/考查中获得60分以上/D评级就可以获得相应的学分，积累到一定学分即可拿到毕业证\n南信大要求学生选课应从个人实际出发，首先保证必修课，再选选修课\n原则上学生每学期所修的学分不少于20学分（已修满足够学分者除外），且不超过35学分\n网络工程专业毕业学分要求以及计算机科学毕业学分要求附在文末表格中\n创新创业学分 本科生在校期间必须获得至少4学分的“创新创业学分”（民族特招生、专转本学生、第二学士学位学生至少2学分），未达到要求者不能毕业。创新创业学分达到10分（含）以上记为“优秀”，8分（含）以上记为“良好”，6分（含）以上记为“中等”，4分（含）以上记为“及格\u0026quot;；民族特招生、专转本学生、第二学士学位学生等级分数减半\n创新创业学分不参与GPA计算\n获得途径 科研创新活动、创新创业竞赛、发表论文与著作、各类证书、听学术报告与讲座、体育竞赛等 具体评价标准见附录\n绩点 绩点与课程考核成绩直接相关，如下表所示\n等级成绩 成绩绩点 百分制成绩 成绩绩点 优秀（A） 4.5 90-100 4.0-5.0 良好（B） 3.5 80-89 3.0-3.9 中等（C） 2.5 70-79 2.0-2.9 及格（D） 1.5 60-69 1.0-1.9 不及格（F） 0 59-0 0 平均学分绩点/GPA GPA：Grade Point Average\n学期（或学年或四年）的平均学分绩点按下列公式计算：\n$GPA= \\frac {∑(已修必修课程的学分 \\times 课程绩点)} {∑已修必修课程的学分}$\n课程学分、绩点、成绩记入学生学业成绩表\n附录 毕业学分要求及学分学时分配表 网络工程 课程类别 课程 学分 **** **** 占总学分比例（％） **** 学时 **** **** 占总学时比例（％） **** 性质 理论 实践 合计 理论学分占比 实践学分占比 理论 实践 合计 理论学时占比 实践学时占比 学分 学分 学时 学时 通修课程 必修 61 1 62 36.97 0.61 1046 78 1124 36.88 2.75 通识课程 选修 10 0 10 6.06 0 160 0 160 5.64 0 学科基础课程 必修 26 0 26 15.76 0 326 90 416 11.5 3.17 专业主干课程 必修 22 0 22 13.33 0 232 120 352 8.18 4.23 专业选修课程 选修 12 0 12 7.27 0 130 62 192 4.58 2.19 综合实践 必修 0 30 30 0 18.18 0 544 544 0 19.18 教学环节 选修 0 3 3 0 1.82 0 48 48 0 1.69 合计 131 34 165 79.39 20.61 1894 942 2836 66.78 33.22 总计 165 100% 2836 100% 计算机科学与技术 课程类别 课程性质 学分 (含实验学分) 占总学分比例 (%) (含实验学分占总学分比例) 学时 (含实验学时) 占总学时比例 (%) (含实验学时占总学时比例) 通修课程 必修 62 35.43 1138 37.70 通识课程 选修 10 5.71 160 5.30 学科基础课程 必修 27 15.43 432 14.31 专业主干课程 必修 24 13.71 336 11.13 专业选修课程 选修 15.5 8.86 248 8.21 综合实践环节 必修 33.5 19.14 656 21.73 综合实践环节 选修 3 1.71 48 1.59 合计 175 100 3018 100 教学计划运行表 网络工程 课程类别 课程性质 课程号 课程名称 课程英文名称 学分 总 学时 讲课 实验 课外 线上 开课单位 开课学期 备注 通修课程 必 修 62 学 分 15000076 形势与政策 Situation \u0026amp; Policy 2 64 64 马院（各） 各 15000126 思想道德与法治 Ideology, Morality and the Rule of Law 3 48 48 马院 1 15000109 中国近现代史纲要 Modern Chinese History 3 48 48 马院 2 15000123 毛泽东思想和中国特色社会主义理论体系概论 Introduction to Mao Zedong Thought and Theory of Socialism With Chinese Characteristics 2 32 32 马院 2 15000125 习近平新时代中国特色社会主义思想概论 Introduction to Xi Jinping Thought on Socialism with Chinese Characteristics for a New Era 2 32 32 马院 5 15000006 马克思主义基本原理 Marxism Basic Theory 3 48 48 马院 6 30000020 军事理论 Military Theory 2 36 36 人武部 1 14000045 职业生涯规划 Career Development 0.5 16 10 6 6 法政院 1 14000221 就业指导 Employment Guidance 0.5 16 10 6 6 法政院 6 16000435 创新创业基础 Innovation and Entrepreneurship Foundation 1 32 16 16 管工院 3 20000085 体育（1） Physical Education（1） 1 36 30 2 4 体育部 1 20000069 体育（2） Physical Education（2） 1 36 32 4 体育部 2 20000048 体育（3） Physical Education（3） 1 36 32 2 2 体育部 3 20000034 体育（4） Physical Education（4） 1 36 32 2 2 体育部 4 25000195 心理健康教育 Psychological Health Education 2 32 16 8 8 8 教师院 1 29000713 劳动教育 Labour Education 1 32 28 4 人艺中心 1-6 18000107 通用英语（1） English for General Purpose（1） 3 48 48 文学院 1 18000105 通用英语（2） English for General Purpose（2） 3 48 48 文学院 2 18001299 学术英语（1） English for Academic Purpose（1） 2 32 32 文学院 3 18002077 学术英语（2） English for Academic Purpose（2） 2 32 32 文学院 4 12000039 高等数学Ⅰ（1） Advanced MathematicsⅠ（1） 6 96 96 数统院 1 12000025 高等数学Ⅰ（2） Advanced MathematicsⅠ（2） 6 96 96 数统院 2 12000343 线性代数 Linear Algebra 3 48 48 数统院 2 12000552 概率统计 Probability Theory and Statistics 3 48 48 数统院 3 13000480 大学物理Ⅱ（1） College Physics Ⅱ（1） 3 48 48 物电院 2 13000478 大学物理Ⅱ（2） College Physics Ⅱ（2） 3 48 48 物电院 3 13000455 大学物理实验Ⅱ College Physics Experiment Ⅱ 1 32 32 物电院 3 计算机导论 Introduction to Computer 1 16 16 软件学院 1 合计 62 1172 1046 78 44 24 通识课程 选 修 10 学 分 一般通识 理工农类：选修6学分，其中必须选修公共艺术类和人文社科类各2学分。 6 各 四史教育 1 2 国家安全教育 1 1 通识拓展 在线开放课、名师讲座课、新生研讨课、跨校选修课等 2 各 应修合计 10 学科基础课程 必 修 26 学 分 36000045 程序设计基础 Fundamentals of Programming 4 64 48 16 软件学院 1 36000050 离散数学 Discrete Mathematics 3 48 48 软件学院 2 36000120 数据结构 Data Structure 4 64 48 16 软件学院 3 36000178 电子技术基础 Basic Electronic Technology 4 64 48 16 软件学院 3 36000179 计算机组成原理 Computer Organization Principles 4 64 48 16 软件学院 4 36000024 计算机网络 Computer Network 3 48 36 12 软件学院 4 36000181 操作系统 Operating System 4 64 50 14 软件学院 5 合计 26 416 326 90 专业主干课程 必 修 22 学 分 36000216 通信技术基础 Communication Technology Fundamentals 3 48 32 16 软件学院 3 36000183 面向对象程序设计(Java) Object-Oriented Programming (Java) 3 48 32 16 软件学院 3 36000184 算法设计与分析 Algorithm Analysis \u0026amp; Design 2 32 24 8 软件学院 4 36000185 数据库系统原理 Database System Principles 3 48 32 16 软件学院 4 36000187 人工智能导论 Introduction to Artificial Intelligence 2 32 20 12 软件学院 4 36000217 网络协议分析与设计 Network Protocol Analysis and Design 3 48 32 16 软件学院 5 全英文 36000218 软件定义网络技术 Software Defined Networking Technology 2 32 20 12 软件学院 6 36000219 网络安全技术 Network Security Technology 2 32 20 12 软件学院 6 36000052 气象信息系统工程 Meteorological information system engineering 2 32 20 12 软件学院 6 合计 22 352 232 120 专业选修课程 选 修 至 少 12 学 分 36000220 C++程序设计 C++ Programming 3 48 32 16 软件学院 4 36000039 编译原理 Compiler Principles 3 48 40 8 软件学院 5 36000225 软件工程 Software Engineering 3 48 32 16 软件学院 5 36000191 Web技术与应用 Web Technology and Application 3 48 32 16 软件学院 5 36000192 移动应用开发 Mobile Application Development 2 32 24 8 软件学院 5 36000061 机器学习 Machine Learning 2 32 20 12 软件学院 5 36000193 气象数据采集与分析 Meteorological Data Collection \u0026amp; Analysis 2 32 20 12 软件学院 5 36000194 气象大数据技术 Meteorological Big Data Technology 2 32 20 12 软件学院 6 36000195 系统智能运维 Intelligent System Operation and Maintenance 2 32 20 12 软件学院 6 36000226 嵌入式系统设计 Embedded System Design 2 32 20 12 软件学院 6 36000227 物联网技术 Internet of Things Technology 2 32 24 8 软件学院 6 36000228 云计算 Cloud Computing 2 32 20 12 软件学院 7 合计 12 192 130.2857143 62 综合实践教学环节 必 修 30 学 分 15000036 毛泽东思想和中国特色社会主义理论体系概论实践 Introduction to Mao Zedong Thought and Theory of Socialism With Chinese Characteristics Practice 1 1W 马院 2 15000127 习近平新时代中国特色社会主义思想概论实践 Introduction to Xi Jinping Thought on Socialism with Chinese Characteristics for a New Era Practice 1 1W 马院 5 30000008 军训 Military Training 2 2W 人武部 2 36000221 程序设计基础实践 Practice of Fundamental Programming 2 2W 软件学院 2 36000068 数据结构课程设计 Practice of Data Structure 1 1W 软件学院 3 36000200 面向对象程序设计实践(Java) Practice of Object-oriented Programming(Java) 1 1W 软件学院 3 36000202 计算机组成原理课程设计 Practice of Computer Organization Principles 1 1W 软件学院 4 36000022 计算机网络实践 Practice of Computer Network 1 1W 软件学院 4 36000070 数据库系统原理课程设计 Practice of Database System Principles 1 1W 软件学院 4 36000075 操作系统课程设计 Practice of Operating System 1 1W 软件学院 5 36000159 网络协议分析与设计实践 Practice of Network Protocol Analysis and Design 1 1W 软件学院 5 36000222 软件定义网路技术实践 Practice of Software Defined Networking Technology 1 1W 软件学院 6 36000223 网络安全技术实践 Practice of Network Security Technology 1 1W 软件学院 6 36000224 网络工程综合实践 Comprehensive Practice of Network Engineering 1 1W 软件学院 7 36000204 社会实践 Social Practice 2 6W 1-8 36000215 毕业实习 Graduation Practice 2 4W 8 36000206 毕业设计（论文） Graduation Design（Dissertation） 10 12W 7、8 36000098 创新创业训练 通过学科竞赛、创新训练项目、发表论文、发明专利、技能证书等方式获得 4 各 该部分学分不含在总学分内 小计 30 34W 选 修 至 少 3 学 分 36000207 C++程序设计实践 Practice of C++ Programming 1 1W 软件学院 4 须选修与之匹配的理论课，方可选修 36000160 软件工程实践 Practice of Software Engineering 1 1W 软件学院 5 须选修与之匹配的理论课，方可选修 36000111 WEB技术与应用实践 Practice of WEB Technology and Application 1 1W 软件学院 5 须选修与之匹配的理论课，方可选修 36000208 移动应用开发实践 Practice of Mobile Application Development 1 1W 软件学院 5 须选修与之匹配的理论课，方可选修 36000209 气象数据采集与分析实践 Practice of Meteorological Data Acquisition and Analysis 1 1W 软件学院 5 须选修与之匹配的理论课，方可选修 36000211 气象大数据技术实践 Practice of Meteorological Big Data Technology 1 1W 软件学院 6 须选修与之匹配的理论课，方可选修 36000210 系统智能运维实践 Practice of System Intelligent Operation and Maintenance 1 1W 软件学院 6 须选修与之匹配的理论课，方可选修 36000224 嵌入式系统设计实践 Practice of Embedded System Design 1 1W 软件学院 6 须选修与之匹配的理论课，方可选修 36000214 云计算实践 Practice of Cloud Computing 1 1W 软件学院 7 须选修与之匹配的理论课，方可选修 小计 3 3W 合计 33 毕业总学分 165 计算机科学与技术 暂未找到\n南京信息工程大学本科生创新创业学分考核标准一览表 一、创新发明 作者排名 发明专利 实用新型及外观设计专利 计算机软件著作权 独立完成 8 2 1 排名第一 6 1 0.5 排名第二 2 0.5 0.3 备注：专利需取得授权。发明专利、实用新型及外观设计专利、计算机软件著作权请提供作者排序相关有效证明。\n二、大学生创新创业训练计划项目 作者排名 国家级结题 省级结题 校级结题 主持人 3 2 1 参与人 1 0.5 0.3 三、创新创业竞赛 获奖等级 I类竞赛国赛 II类竞赛国赛 III类竞赛国赛 I类竞赛省赛 II类竞赛省赛或区域选拔赛 III类竞赛省赛或区域选拔赛 IV类竞赛 最高等级 18 12 9 9 4.5 3 1.5 第二等级 12 9 6 3 3 1.5 1 第三等级 9 6 4.5 1.5 1.5 0.75 0.5 备注：竞赛目录详见《南京信息工程大学学生创新创业竞赛管理办法（试行）》（竞赛目录每年更新）；团队参赛的竞赛：前三位队员均可获得各对应奖项的学分，其余参赛员减半；团队参赛获奖且参赛名单无排序的按获奖等级加权均分计学分；同一作品参加同一竞赛获不同等级奖励按最高等级奖酌认定学分。\n四、发表论文 （一）自然科学类 作者完成 独立完成 排名第一 排名第二 Nature、Science、Cell 论文 Nature、Science 子刊论文（影响因子≥10，含LANCET、PNAS、NSR） 三高期刊库T1层次，卓越期刊 18 15 8 SCI（E）一区论文，NI期刊论文 三高期刊库T2层次，卓越期刊 学术著作（12万字以上） SCI（E）二区论文，三高会议库T1层 9 7 4 三高期刊库T3层次，卓越期刊，国内权威期刊论文 SCI（E）三/四区论文，三高会议库T2层次 EI收录的期刊论文，三高会议库T3层次，北京大学图书馆中文核心期刊发表论文 4 3.2 1.6 CSCD收录期刊论文 3 2.4 1.2 SCD收录期刊论文 2 1.6 0.8 省级期刊 1 0.8 0.4 （二）人文社科类 作者\\完成 独立完成 排名第一 排名第二 《中国社会科学》论文（中文版/英文版） 18 15 8 UTD24/FT50 期刊论文 学科最高权威论文（ST1）SSCI Ⅰ区论文、《人民日报》理论版/智库版文章《新华文摘》、《中国社会科学》长文转摘 CSSCI 扩展版收录论文、北大核心期刊论文、学校特别认定期刊论文 学术著作（12万字以上） 权威期刊论文（ST2）SSCI Ⅱ区论文被A\u0026amp;HCI收录的学术期刊论文《人大复印报刊资料》全文转载文章、《高等学校文科学术文摘》长文转摘、《经济日报》理论版、《人民日报》、《光明日报》《解放军报》理论文章 9 7 4 CSSCI（不含扩展版）收录论文（ST3）SSCI Ⅲ/Ⅳ区论文、《中国教育》论文（理论版）、《中国社会科学》理论文章 权威期刊译文（5000字以上） 5 4 2 SCD期刊收录论文、其他国外期刊论文 4 3.2 1.6 CSSCI期刊译文（5000字以上） 2.5 2 1 省级期刊 1 0.8 0.4 五、语言类等级考试证书 考试类型 六级 八级 四级 托福考试 雅思考试 英语口译 全国大学英语等级考试（CET） 2 1 4 (95分以上) 4 (6.5分以上) 4 (高级) 全国高校英语专业考试 2 1 2 (85分以上) 2 (6分以上) 2 (中级) 六、计算机等级考试证书 等级 文科学生通过全国或江苏省计算机等级考试 理工科学生通过全国或江苏省计算机等级考试 一级 1 无 二级 2 1 三级 3 2 四级 4 3 七、体育竞赛 我不会参加所以就不写了\n八、其他项目 序号 类别 项目 备注 学分 2 营业执照 注册公司 申报人为法定代表人 0.5 3 培训 参加由学校组织的各类创新创业课程培训（不少于8学时，本项最多计1次） 取得培训合格证书 1 4 培训 青年大学生创业培训SYB合格证书 取得培训合格证书 2 5 培训 青年大学生创业培训GYB证书，南京青年大学生创业证 取得培训合格证书 1 6 培训 学校组织的各类实践实训培训（不少于2周） 提供证明或合格成绩单 2 7 证书 国家司法考试 取得证书 2 8 证书 教师资格证、驾驶证、初级会计师 取得证书 1 9 证书 普通话水平考试二级乙等及以上 取得证书 1 10 证书 职业资格证书（权威机构认证） 取得证书 1 11 证书 职业资格证书（公司认证） 取得证书 0.5 12 证书 红十字救护员（初级） 取得证书 0.5 13 证书 心肺复苏（CPR+AED）培训证书 取得证书 0.5 14 证书 红十字救护员证 取得证书 1 15 大赛报名 在官网完成中国国际“互联网+”大学生创新创业大赛报名（限前三名） 凭报名截图，提交时间以当年校赛通知要求为准 0.5 16 听学术报告 撰写与报告相关的学术材料（不少于1500字）1篇 本项最高累积计2分 0.5 备注：\n各单位举办的创新创业课程培训和实训培训需在培训前5天向教务处（藕舫楼）报告培训安排，参加学生名单等单位公章附相关材料未报告的将不予认定。 未明确列出的职业资格证书按照人力资源社会保障部公布的国家职业资格目录认定。 ","date":"September 2, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/%E5%85%B3%E4%BA%8E%E5%AD%A6%E5%88%86%E7%BB%A9%E7%82%B9%E4%BB%A5%E5%8F%8Agpa/","series":[],"smallImg":"","tags":[{"title":"University","url":"/tags/university/"}],"timestamp":1725240887,"title":"关于学分、绩点以及GPA"},{"authors":[{"title":"Internet Users","url":"/authors/internet-users/"}],"categories":[],"content":" .\n在这里收录着平时会用的一些网站\n$\\LaTeX$ 相关文档/博客/网站 通用 LaTeX 数学公式语法手册 http://www.uinio.com/Math/LaTex/\nLaTeX详细教程+技巧总结 https://blog.csdn.net/NSJim/article/details/109066847\nLATEX 教程 https://zilutian.github.io/latex-tutorial-chinese/\nMarkdown \u0026amp; $\\LaTeX$ 完全指南 https://www.cnblogs.com/Rosmarinus/articles/15553532.html\n在线$\\LaTeX$公式编辑器 https://www.latexlive.com/\nHugo/本站博客相关文档/教程 Hugo中文文档 https://hugo.opendocs.io/getting-started/usage/\nHugo Bootstrap Theme 中文帮助文档 https://hbs.razonyang.com/v1/zh-hans/docs/getting-started/\n工具网站 SAI2破解汉化发布站 https://sai.piv.ink/\n网易云音乐解析（但是我推荐free music） https://tools.qzxdp.cn/wyy_vip\nBPM测量（可能不准） https://bpmdetector.kniffen.dev/file\n字体100（可商用字体） https://www.100font.com/\n公益ChatGPT(有GPT4共享) https://sharedchat.cn/\n安卓投屏软件（非常好用） https://gitee.com/Barryda/QtScrcpy#https://gitee.com/Barryda/QtScrcpy/releases\nGreasy Fork https://greasyfork.org/zh-CN\n大众脸LookAE https://www.lookae.com/\n果核剥壳 https://www.ghxi.com/\n更多网站还在路上\n未完待续…………\n欢迎推荐！！！请将你珍藏的宝藏网上留在下方comments中，看到后我会将其收录入文中。\n","date":"July 6, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99%E5%90%88%E9%9B%86/","series":[],"smallImg":"","tags":[{"title":"Tool","url":"/tags/tool/"},{"title":"LaTeX","url":"/tags/latex/"}],"timestamp":1720229687,"title":"常用参考网站合集"},{"authors":[{"title":"Falling_MY","url":"/authors/falling_my/"}],"categories":[],"content":"终于搞定博客啦！！！\n经历了 艰苦卓绝 的奋斗之后\n总算是建立了个人博客啦~~\n会把平时有用的一些文档放到Docs里面，欢迎翻阅喔\n希望自己能够经常更新博客吧（\n如果你喜欢我的内容也欢迎 Buy Me A Coffee~（↓小组件上的按钮）\nThanks for reading~~\n","date":"July 5, 2024","img":"/news/2024/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/featured.webp","lang":"en","langName":"English","largeImg":"/news/2024/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/featured_hu12434315746270282370.webp","permalink":"/news/2024/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/","series":[{"title":"News","url":"/series/news/"}],"smallImg":"/news/2024/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/featured_hu4232062683093291453.webp","tags":[{"title":"News","url":"/tags/news/"}],"timestamp":1720165160,"title":"第一个博客！"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":" anaconda的安装和使用（管理python环境看这一篇就够了） 前言 一、Anaconda是什么？ 二、Anaconda安装 三、Anaconda使用教程 四、pycharm使用anaconda创建的虚拟环境 总结 前言 以前写python，一个电脑上就一个python环境和pycharm就够了，现在遇到项目需求为不同的python环境，如打包为32位的可执行文件、openopc只有python2.7_32位才能使用等。第一个办法是在电脑上安装多个python环境，使其同时存在，但这样过于麻烦而且容易搞混淆，因此本篇文章就来介绍下anaconda的安装和使用。\n一、Anaconda是什么？ 就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。即它可以在你的电脑上创建多个你想要的python环境，并为每个python环境安装不同的包，不同环境相互切换，操作简单，使用方便！\n二、Anaconda安装 下载地址：https://www.anaconda.com/download/\n百度网盘链接：https://pan.baidu.com/s/1ccqr833QKsxI5qkW97LCJg\n提取码：o09u\n打开下载好的 Anaconda.exe文件，出现如下界面。\n点击 Next 即可。\n用户协议，点击 I Agree。\n选All Users 点Next\n接下来选择安装路径，这里不建议装在C盘，安装完大概3个G左右，现在都是固态硬盘了，安装到固态硬盘就好，路径要知道自己安到了哪里（后续使用不同环境的时候会用到这个安装路径）。选择好了之后点击Next\n接下来是重中之重，第一个选项是添加环境变量，默认是没有勾选的，请务必勾选上，如果这里不勾选，后续安装完成后想要自行添加环境变量会非常麻烦。勾选完后点击 Install 安装。如果忘了勾选可以卸载重装。\n这里是pycharm的一个推广没有需求的话可以不用管，最后一步了，继续点Next。\nFinish完成。（那两个 √ 可以取消。）\n安装完成后在开始菜单会多出一个快捷方式，也就是Anaconda下的子程序：\n开始菜单\n1.修改为清华源\n直接打开cmd输入以下命令\nconda config \u0026ndash;add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config \u0026ndash;add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config \u0026ndash;add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud//pytorch/\nconda config \u0026ndash;add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\nconda config \u0026ndash;set show_channel_urls yes\n2.移除清华源\n输入：conda config \u0026ndash;remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\n这个命令是为了移除之前conda config \u0026ndash;show channels显示的清华源。\n三、Anaconda使用教程 主要用的两个为Anaconda Prompt 和Anaconda Navigator\nAnaconda Prompt 就是我们的cmd，打开后如下：\n以后的创建环境和环境切换，和pip安装各种包全在这里，\n介绍几个常用的快捷键：\n1.conda info 查看当前环境的信息\n2.conda info -e 查看已经创建的所有虚拟环境\n目前我创建的3个不同的虚拟环境，分别32位python2.7、32位python3.6和64位python3.7\n3.conda activate xx 切换到xx虚拟环境\n现在即切换到了64位python3.7环境\n4.set CONDA_FORCE_32BIT=1 # 切换到32位\nset CONDA_FORCE_32BIT=0 # 切换到64位\n表示已经切换到32位\n5.conda create -n xxx python=2.7 创建一个python2.7 名为xxx的虚拟环境，如要创建32位的python环境，先设置为32位在创建环境，这样创建好的环境即为32位的Python环境，先切换到创建好的环境中\n然后输入python 检查下是否为32位的python2.7版本，这样即创好了\n6.conda remove -n env_name \u0026ndash;all 移除环境，也可在Anaconda Navigator中移除\nAnaconda Navigator为可视化管理软件\n这是我们添加的清华源，加快包的下载速度，\n我们创建的环境和环境里的安装的包可以在Environments里查看\n也可以在这里创建虚拟环境和移除虚拟环境，还可为每个独立的环境安装需要的包\n四、pycharm使用anaconda创建的虚拟环境 1.进入项目设置里的Project Interpreter\n然后点击show all\n然后点击添加\n接着选Existing environment\n选择自己在anaconda里创建的虚拟环境，路径在anaconda的安装路径里的envs里\n最后点确定应用即可。\n至此pycharm使用该环境已完毕。\n总结 anaconda是一款强大的软件也是python程序员必备的软件，尽量达到每个项目单独一个虚拟环境，因为后面使用pyinstaller打包的项目成为可执行文件的时候，会打包环境里所有安装的包，该环境下每个包都是我们项目用到才安装的，非常干净，这样会加快文件的运行速度也减小文件的大小。便于我们管理和维护！\n文章知识点与官方知识档案匹配，可进一步学习相关知识\nPython入门技能树预备知识常用开发工具426640 人正在系统学习中\n本文转自 https://blog.csdn.net/tqlisno1/article/details/108908775，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/python/anaconda%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%90%86python%E7%8E%AF%E5%A2%83%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86-csdn%E5%8D%9A%E5%AE%A2/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Python","url":"/tags/python/"}],"timestamp":1720150487,"title":"Anaconda的安装和使用（管理python环境看这一篇就够了）-CSDN博客"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":" 带着以下问题阅读本文，相信会事半功倍。\n什么是git？为什么用git而不是其他的版本控制工具，如svn？ 什么是仓库？本地仓库与远程仓库，常用的远程仓库有哪些，如何建立？ 怎么用git？如何用git管理文件，实现版本控制？ 2019年8月19日 15:59:48\ngit安装尽量避免中文路径，一般会因路径含中文出现以下问题：\n一、git简介 git是个分布式版本管理工具，与集中式版本管理工具svn相反。\n二、下载git 官网： https://git-scm.com/downloads\n官网速度较慢，腾讯软件中心就有，而且版本更新及时。\nhttps://pc.qq.com/detail/13/detail_22693.html\n三、安装git 3.1安装位置\n图3.1\n3.2安装配置文件，根据需要选择 图3.2\n3.3启动文件夹设置（截图略）\n3.4设置默认编辑器，可自定义，点击Browse，添加第三方编辑器.exe即可，本文以NotePad++为例\n图3.4\n3.5选择path配置，提示都是见名知意，按需选择。\n图3.5\n3.6默认即可\n图3.6\n3.7 配置行结束标记，保持默认即可\n图3.7\n3.8选择git使用终端风格 图3.8\n3.9额外配置，默认即可 图3.9\n3.10 默认\n图3.10\n3.11 安装完成\n图3.11\n3.12 打开git bash\n图3.12\n图3.13\n四、远程仓库配置 远程仓库有很多，比如github，国内的码云，局域网自建git服务器，托管在其他地方的服务器，本文以github为例\n**网址：**https://github.com\n4.1注册账户： 类似普通的网站新用户注册，使用邮箱注册即可。\n4.2新建仓库： 点击右上角，加号，new repository\n下一步\n如，我已经建立好的仓库：\n五、生成（配置）SSH git客户端安装后，如何和远程仓库，如github连接呢？本文使用SSH。\n5.1 用户名\ngit config --global user.name \u0026#34;注册名\u0026#34; 5.2 邮箱\ngit config --global user.email \u0026#34;注册邮箱\u0026#34; 5.3 生成SSH（以有SSH可以跳过这一步）\nssh-keygen -t rsa -C \u0026#34;自己的邮箱\u0026#34; 生成成功，如下图所示：\nSSH文件存放在C:/User/用户/.ssh下，id_rsa为私钥，id_rsa.pub为公钥。\n5.4 github配置SSH\n打开id_rsa.pub文件，全选，复制全文\ngithub-\u0026gt;账户-\u0026gt;setting\n选择SSH and GPGkeys，New SSH key\n自定义一个title，然后粘贴从公钥文件中拷贝的key\n5.5 测试SSH连接\nssh -T git@github.com 按照提示输入yes，回车，提示successfully之类的就说明SSH连接正常，github上的钥匙也会变成绿色\n至此，本地git客户端和远程github建立了联系。\n六、推送文件至远程仓库 在把文件推送到远程仓库之前，先要了解本地仓库这个概念，此外还有add，commit，push等概念，本文不再赘述。\n基本流程:add-\u0026gt;commit-\u0026gt;push\n6.1建立本地仓库 新建一个文件夹\ngit bash中执行命令，将该文件夹初始化为一个仓库\ngit init 结束以后在文件夹下面会出现一个隐藏的文件夹.git，没有的话，设置一下文件夹选项，显示隐藏文件\n6.2 推送文件至远程 本文建议，在远程建立好仓库，本地进行clone，然后再添加新文件，最后推送至远程。这样的步骤对新手比较友好。\n如：事先在github建立了仓库，bysj，并新建了README文件，此时远程仓库中只有这一个文件。\n一、clone远程至本地\ngit clone git@github.com:用户名/仓库名.git 将远程的bysj仓库及其中的README文件clone至本地\n然后，向bysj文件夹中手动添加了doc，src，WebContent三个文件夹及其中的子文件夹和文件等。\n可以用ls命令查看bysj文件夹下的文件，可以看到有一个文件，三个文件夹，使用命令进行add\n二、add\ngit add 文件夹1/ 文件夹2/ 注意:add有多种形式，可以add某个文件，某个文件夹，或直接add当前仓库下所有文件\ngit add 单个文件 git add 文件夹1/ 文件夹2/ ……多个文件夹之间空格隔开 git add . 三、commit\ngit commit -m “注释” 四、push\ngit push -u origin master 成功推送至远程仓库bysj，三个文件夹，一个README文件。\n总结：如何推送文件至远程？ ①建立本地仓库\n②与远程建立连接，测试\nssh -T git@github.com ③init命令初始化仓库\ngit init ④手动拷贝文件，并执行add命令\ngit add 文件夹1/ 文件夹2/ ⑤commit命令\ngit commit -m “注释” ⑥push命令\ngit push -u origin master 后记：时间匆忙，难免有遗漏或不当之处，望大家批评指正！\n文章知识点与官方知识档案匹配，可进一步学习相关知识\nGit技能树Git入门Git简介7467 人正在系统学习中\n本文转自 https://blog.csdn.net/qq_35206244/article/details/97698815，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/git/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E4%B8%80%E5%85%A5%E9%97%A8%E5%8F%8A%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9F%BA%E6%9C%AC%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Git","url":"/tags/git/"}],"timestamp":1720150487,"title":"Git基本使用教程（一）：入门及第一次基本完整操作"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":"传送门：Git基本使用教程（一）:入门及第一次基本完整操作\n官方文档：Git基础\n提示：直接使用Ctrl+F全文检索关键字，更容易找到相应命令\n①查看远程仓库:切换至某一目录，执行命令 git remote show origin 如图所示，我在Git目录下（包含两个仓库，dywhml，bysj）执行命令，将显示config文件中配置的仓库地址。\n切换目录至bysj，再看下效果\n②修改工作区文件，进行add,status,diff,commit,push 工作目录内容track了才能用git diff git diff 是工作区(work dict)和暂存区(stage)的比较 git diff –-cached 是暂存区(stage)和版本库（repository）的比较\n如图，在bysj下执行了对某个文件的修改（README.md），执行add，然后执行status，可以看到提示，modified:README.md。 git diff --cached 接着，执行diff，就是上面提到的，直接diff和diff \u0026ndash;cached的含义不一样。\n注意：\ngit diff 是工作区(work dict)和暂存区(stage)的比较 git diff –-cached 是暂存区(stage)和版本库（repository）的比较 ③commit提交 git commit -m “注释内容” ④push到远程仓库 git push origin ⑤从远程获取更新fetch，pull 获取更新有两种，fetch和pull。\nfetch只是从远程获取最新到本地，不会自动merge，需要手动合并，比较安全。 方法一： 1、git fetch orgin master #将远程仓库的master分支下载到本地当前branch中 2、git log -p master ..origin/master #比较本地的master分支和origin/master分支的差别 3、git merge origin/master #进行合并 1、fetch:\n2、对比差异：\n3、确认后，合并：\n方法二： 1、git fetch origin master:tmp #从远程仓库master分支获取最新，并在本地建立tmp分支 2、git diff tmp #将当前分支和tmp对比 3、git merge tmp #合并tmp分支到当前分支 pull从远程获取最新版本并merge到本地 git pull origin master 文章知识点与官方知识档案匹配，可进一步学习相关知识\nGit技能树首页概览7467 人正在系统学习中\n本文转自 https://blog.csdn.net/qq_35206244/article/details/97772285，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/git/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E4%BA%8C%E8%8E%B7%E5%8F%96%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%8E%A8%E9%80%81%E6%9B%B4%E6%96%B0/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Git","url":"/tags/git/"}],"timestamp":1720150487,"title":"Git基本使用教程（二）：获取更新与推送更新"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":"Git是用来干什么的呢？\n是用来管理代码文件的，具体是啥自行百度就行，其实你点进来你多少会对他有点了解，知道他是干嘛的~\n提示：照着本文，敲一下指令就能掌握，底层原理了解即可，主要是会用！\n01 | 下载软件 软件官网\nGit官网进口\n下载好了可以输入\ngit --version\n这里可以看到git的版本，这就说明git安装成功了！\n02 | Git的命令–开发需要 首先需要熟悉linux常用基本命令！\n而常用的Git也就无非这么几个\n只要把linux命令，配合git命令（红色的记住），就能实现大部分开发需求了！\ngit init:初始化\ngit status：查看状态\ngit add \u0026lt;文件名\u0026gt;：追踪文件，添加到暂存区\ngit commit -m '备注' \u0026lt;文件名\u0026gt;：提交文件到本地库\ngit reflog / git log：查看日志\ngit reset --hard 版本号：版本切换\ngit rm --cached \u0026lt;file\u0026gt;：丢弃工作目录中对文件的修改，将其还原为最近一次提交的状态。\ngit restore \u0026lt;file\u0026gt;：用于取消暂存区中对文件的修改，将其还原为最近一次提交的状态，并保留工作目录中的修改\ngit restore --staged \u0026lt;file\u0026gt;：用于停止跟踪某个文件，将其从暂存区中移除，但保留在工作目录中。\n03 | 实操 3.1 | 设置用户签名和密码 这里的用户签名和其他地方任何的账号密码都没有关系，这个只是作为你提交代码的一个标识，你在本机上提交代码，提交代码的人就是你设置的签名Layne，这只是一个标识。\n3.2 | 初始化本地库 在桌面新建一个文件git-demo,在这个文件里面又新建一个文件git_space\n接着在这个路径下，启动git bash窗口，输入git init命令\n可以看到，该目录下创建了一个.git的文件，这个文件放的东西就是用来进行版本控制的。\n在window里可以看到如下的文件结构，把隐藏的文件打钩\n3.3 | 查看本地库状态 输入命令git status\n下面来分析一下这三行输出的文字所代表的意思\n现在在git_space下执行下面代码\n可以看到创建了一个hello.txt的文件，里面编写了一些内容。\n这时候我们再来看git status\n1、前两行文本没有变化，\n2、第三行有了改变，意思是，存在没有追踪的文件，下面括号也说了，（使用git add \u0026lt;文件\u0026gt;这个这个命令去添加它，然后准备提交），\n3、红色的hello.txt说明该文件只存在而已，但是没有被追踪。\n4、最后一行说了，没有可以添加去提交的东西，但是呢，存在没有追踪的文件（使用git add命令去追踪它）\n3.4 | 添加文件到暂存区 那么我们就使用git add \u0026lt;filename\u0026gt;这个命令，添加到暂存区吧~，也就是追踪这个文件。\n再使用git status命名查看一下状态。\n再来分析一下输出的文本\n1、没有变化，在master分支上\n2、没有提交过东西\n3、提交这个改变，可以看到这个hello.txt文件变成了绿色，说明我们已经把这个文件添加到暂存区了，已经被追踪了。括号里面写（使用git rm --cached \u0026lt;file\u0026gt;命令去取消上一步操作\n那我们就按照他的提示操作一下吧git rm --cached hello.txt\n再查看一下状态\n可以看到，hello.txt回到了没有被追踪的状态，可以理解为把这个hello.txt文件从暂存区拿出来 这个告诉我们，暂存区的数据既然可以被添加，也可以被删除（只是移出暂存区） 现在我们重新把hello.txt文件添加回去 3.5 | 提交本地库（赠：查看日志） 这个的意义就是，将暂存区的文件添加到本地库，形成一个历史版本\n基本语法：git commit -m “备注” \u0026lt;文件名\u0026gt;\n再来进行查看一下状态\n发现这次输出只有两行文本\n1、在master分支，这个没变\n2、没有可以去提交的东西，工作区已经清空了\n对比一下之前的三个文本 少了No commits yet，这句话说的是“还没有提交过东西”，而现在我们已经提交东西了，所以他就不显示了。 这里我们可以使用一个查看版本提交的命名git reflog\n解释一下：\n0759d50 ：表示提交版本号，由Git自动生成，通常用哈希值表示 (HEAD -\u0026gt; master) ： 表示HEAD这个指针，指向master，也就是我们现在在master这个分支上 HEAD@{0} ： 表示HEAD的一个偏移量，而这个偏移量是{0}，在这个位置进行的提交 commit (initial): first commit ： 你之前提交的时候，输入的备注信息 可以再使用git log命令，这个命令是查看完整版的日志的\n解释一下：\ncommit 操作的一个版本号（这个是一个完整的，而git reflog只是截取了一部分的哈希值）,HEAD指针指着master分支 作者：用户名 邮箱 （也就是一开始设置的东西） 提交的日期： 巴拉巴拉 提交的备注信息 3.6 | 文件的修改 在hello.txt文件中插入修改一下，添加了‘123456’\n再次查看本地库的状态\n解释一下：\n在master分支 意思是‘更改没有提交到暂存区’，也就是没有被追踪\n（使用git add \u0026lt;file\u0026gt;命令去更新将要被提交的内容）\n（使用git restore \u0026lt;file\u0026gt;命令去放弃更改在工作目录中） 更改的文件：hello.txt，可以看到这个文件变成了红色，说明没有添加到暂存区里 没有添加要提交的更改（使用git add或者git commit -a） 使用git restore \u0026lt;file\u0026gt;命令\n查看状态发现，他提示说，没有东西可以提交，工作区是空的，也就是没有执行过任何操作\n再看文件内容，这个‘123456’也给我撤回去\n好了~，我们把文件还原吧，把‘123456’重新输入进去，回到执行git restore前的状态吧，再进行下面的操作\n使用git add命令添加到暂存区，再看看状态\n意思是，在master分支上，将要提交的更改：\n（使用git restore --staged \u0026lt;file\u0026gt;命令，把文件移出暂存区）\n修改了文件：hello.txt\n输入一下命令git restore --staged \u0026lt;file\u0026gt;\n不知道你有没有发现，回到了之前的使用git add的时候\n对文件进行commit一下吧\n解释一下：\n【master分支， 版本号（哈希值截取）】，备注信息 一个文件修改了，一行添加，一行删除\n（Git里面是对行进行处理的，所以你的修改操作，它表示为删除一行，然后新增一行）\n========================= 再次查看状态，这个时候已经没有东西提交啦，而且工作区也干净了 执行一下git reflog和git log查看日志信息\n解析一下：\n可以看到第一行的备注信息为上一次提交，也就是第二次提交，HEAD的偏移量为0，而上一次的偏移量为1了，同时也可以看出，这个HEAD指针指向master分支的同时，指向第二个提交版本 3.7 | 历史版本和版本穿梭 先再进行一个文件修改，然后提交\n此时有三个被提交的版本了\n文件改了之后，我想要回到任何一个提交的版本怎么办呢？\n可以使用git reset --hard \u0026lt;版本号\u0026gt;\n解释一下：\n文本输出，这个HEAD指针现在指向了我们输入的版本号，备注是第二次提交 查看一下日志 HEAD指针指向了master分支，然后是第二次提交的版本 再看一下文件内容，已经是回到了之前的状态了\n其实你想要切换到哪里都可以，只需要带上版本号就行\n底层其实是指针的移动操作\n图说明了，这三个版本同时存在，只要master指向哪里，就是哪个版本。\n持续更新中。。。。，你的支持是作者的动力噢~\n文章知识点与官方知识档案匹配，可进一步学习相关知识\n算法技能树首页概览62043 人正在系统学习中\n本文转自 https://blog.csdn.net/weixin_49113403/article/details/131733580，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/git/git%E7%9A%84%E4%BD%BF%E7%94%A8%E6%98%93%E6%87%82+%E5%B7%A8%E6%97%A0%E6%AF%94%E8%AF%A6%E7%BB%86+%E6%96%B0%E6%89%8B%E5%BF%85%E7%9C%8B/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Git","url":"/tags/git/"}],"timestamp":1720150487,"title":"Git的使用（易懂+巨无比详细+新手必看）"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":" 第一节：Java语言概述 一、java背景知识 1、Java是美国sun公司（Stanford University Network）在1995年推出的一门计算机高级编程语言。\n2、Java早期被称为Oak（橡树），后期改名为Java。\n3、Java之父：詹姆斯·高斯林（James Gosling）\n4、2009年sun公司被Oracle（甲骨文）公司收购\n二、为什么用Java 1、世界上最流行的编程语言之一，在国内使用最为广泛的编程语言\n2、可移植性、安全可靠、性能较好\n3、开发社区最完善，功能最丰富\n三、JAVA能干什么 1、桌面应用开发\n2、企业级应用开发\n3、移动应用开发\n4、服务器系统\n5、大数据开发\n6、游戏开发\n四、JAVA技术体系 技术体系 说明 Java SE：标准版 Java技术的核心和基础 Java EE：企业版 企业级应用开发的一套解决方案 Java ME：小型版 针对移动设备应用的解决方案 第二节：Java环境搭建 一、如何使用Java 1、Java语言的产品是JDK（Java Development Kit：Java开发者工具包）,必须安装JDK才能使用Java语言。JDK产品的发展使。\n2、JDK产品的发展史\nLTS(long-term support)：长期支持版 3、如何获取JDK\n去Oracle官网下载JDK 4、验证JDK安装成功的方式 查询JDK的版本号\n在命令行中输入 java -version javac -version 查看版本，如果版本提示与自己安装的版本号一致，则代表安装成功。\n5、java和javac介绍\njava是执行工具\njavac是编译工具\n将来我们写好的java程序都是高级语言，计算机底层是不能识别这些语言的。\n必须先通过javac编译工具进行翻译，然后再通过java执行工具执行才可以驱动机器干活\n5、补充 常用命令 说明 盘符： 切换到某个盘下 dir 查看当前路径下的文件信息 cd 进入单级目录：cd 目录名 进入多级目录：cd 路径 回退到上一级目录：cd … 回退到盘符根目录：cd \\ cls 清屏 第三节：Java入门程序 一、Java程序的开发的三个步骤 1、编写代码：源代码文件（.java）\n2、编译代码：字节码文件（.class）\n3、运行代码\n注意事项： 第一个Java程序建议使用记事本写 建议代码文件名全英文，首字母大写，满足驼峰模式，源文件后缀名必须是.java 二、编写代码： 1、第一个程序的代码如下：\npublic class HelloWord{//HelloWord是类名 public static void main(String[] args){ System.out.println(\u0026#34;Hello Word\u0026#34;);//打印Hello Word } } 注意：\n文件名称必须与代码中的类名称一致 保存文件：ctrl+s 三、编译代码，运行代码 1、编译：javac 文件名.java\n//编译上述文件 javac HelloWord.java 2、运行：java 类名\n//运行上述代码 java HelloWord 注意：在源代码根目录下执行dom命令\n四、HelloWord案例常见错误 1、Windows的文件扩展名没有勾选\n2、代码写了，但是忘记保存了\n3、文件名和类名不一致。\n4、大小写错误，单词拼写错误，存在中文符号，找不到main方法。\n5、括号不配对。\n6、编译或执行工具使用不当。\n一个什么错都犯过的程序员，才是真正的程序员！\n第四节：Java程序的执行原理 一、机器语言长什么样子？ 1、机器语言就是01代码\n2、计算机底层都是硬件电路，可以通过不通电和通电，表示0、1。\n3、使用机器语言编程来实现呼吸灯效果（图）\n4、最早期的程序员通过机器语言编程的形式\n二、编程语言发展历程 机器语言 汇编语言 高级语言 三、为什么学习高级编程语言 1、更简单：使用接近人类自己的语言书写，翻译器再将其翻译成计算机能理解的机器指令\n四、BUG 1、原意是臭虫或者虫子，现在用来指代在电脑系统或者程序中隐藏的一些问题或者漏洞。\n2、修复漏洞就叫debug\n3、bug的创始人：格蕾丝.赫伯\n第五节：JDK的组成、跨平台原理 一、JDK的组成 JVM（Java Virtual Machine)：Java虚拟机，真正运行]ava程序的地方。 核心类库：Java自己写好的程序，给程序员自己的程序调用的。 JRE (Java Runtime Environment):Java的运行环境。 JDK (Java Development Kit):Java开发工具包（包括上面所有）。 二、Java的跨平台、工作原来（图） 一次编译，处处可用 我们的程序只需要开发一次，就可以在各种安装了JVM的系统平台上运行。 第六节：JDK安装后环境变量的配置 一、Path环境变量 ​ Path环境变量用于记住程序路径，方便在命令行窗口的任意目录启动程序。\n二、Path环境变量的原理 ​ 当我们在Pth中配置某个程序路径后，启动命令行窗口启动程时，是如何去找该程序的。\n三、为java、javac配置Path的注意事项 1、命令行窗口的任意目录可以使用javac和java，是不是也需要为其配置Path环境变量呢？\n四、为java、javaci配置Path的注意事项 目前较新的DK安装时会自动配置javac、java程序的路径到Path环境变量中去，因此，javac、java可以直接使用。 注意：以前的老版本的JDK在安装的是没有自动配置Path环境变量的，此时必需要自己配置Path环境变量。 五、重新配置了环境变量后，必须检测是否配置成功 打开命令行窗口，输入javac -version及java -version分别看版本提示。 六、配置Java\\_home环境变量 JAVA_HOME:告诉操作系统JDK安装在了哪个位置（将来其他技术要通过这个环境变量找到JDK) 注意：较新版本的DK只是自动配置了Path,没有自动配置JAVA_HOME。 第七节：IDEA开发工具的使用 一、之前的开发工具 1、文本编辑工具 ​ 记事本、UltraEdit、EditPlus、TextPad、NotePad++、sublime,\n2、存在的问题 ​ 编写代码时没有错误提醒、没有智能提示、需要自己进行编译、执行。功能不够强大。\n二、集成开发环境（IDE，Integrated Development Environment） 1、把代码编写，编译，执行等多种功能综合到一起的开发工具，可以进行代码智能提示，错误提醒，项目管理等等。\n2、常见Java的IDE工具有：Eclipse、MyEclipse、IntelliJ IDEA、Jbuilder、NetBeans等。\n三、IntelliJ IDEA开发工具 1、IntelliJ IDEA一般简称IDEA，是Java编程语言开发的集成环境，在业界被公认为最好的java开发工具。\n2、IDEA在代码错误提醒，智能代码补全等多方面表现的都非常优秀，是]ava开发企业级首选工具。\n四、IDEA下载 下载：https://www.jetbrains.com/idea/\n安装：傻瓜式安装，建议修改安装路径（不要安装在有空格和中文的路径下）。\n五、IDEA项目结构介绍 project(项目、工程) module（模块) package(包) class（类) 结论：这些结构的划分，是为了方便管理项目技术和代码文件的\n六、使用步骤 创建Project空工程 创建Module模块 创建Package包 创建class类 在类中编写代码 完成编译运行 七、idea中设置主题、字体 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gKXS0nQK-1684550528638)(./\\img\\idea中设置主题、字体.png)]\n八、idea常用快捷键 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MXeKZq8Q-1684550528640)(.\\img\\idea常用快捷键.png)]\n九、IDEA中其他操作 删除类文件 修改类名称 修改模块 导入模块 删除模块 打开工程 关闭工程 第八节、Java基础语法 一、注释 1、什么是注释 ​ 注释是写在程序中对代码进行解释说明的文字，方便自己和其他人查看，以便解释程序。\n2、注释有哪些 单行注释\n//注释内容 多行注释\n/* 注释内容1 注释内容2 */ 文档注释\n/** 注释内容 注释内容 */ 3、注释的特点 ​ 注释不影响程序的执行，编译后的class文件已经没有注释了。\n4、注释的快捷键 二、字面量 ​ 计算机是用来处理数据的，字面量就是告诉程序员：数据在程序中的书写格式。\n1、常用数据 2、常见的特殊值的书写格式 true false null \\n \\t 三、变量 1、什么是变量 ​ 变量就是用来存储一个数据的内存区域（可以理解为盒子），里面存储的数据可以变化。\n2、变量定义的格式 数据类型 变量名 = 初始值；\n数据类型：强制限制盒子存储数据的形式。例如：int（整型）、double（小数类型）\n变量名：取名字，首字母小写，有意义\n初始值：存储的初始数据\n3、修改变量中存储的值 double money = 6.0; System.out.println(money);//6 money=money+4; System.out.println(money);//10 int age=21; System.out.println(age); age=18; System.out.println(age); 4、定义变量需要注意的几个问题 变量要先声明在使用 变量声明后，不能存储其他类型的数据 变量的有效范围是从定义到“｝”截止，且在同一个范围内不能定义2个同名的变量 变量定义的时候可以没有初始值，但是使用的时候必须给初始值 5、变量在计算机的底层原理 （1）二进制 只有0、1，按照逢2进1的方式表示数据\n（2）十进制转二进制的算法 除二取余法\n（3）计算机中的数据的最小单位 最小保存的单元是：使用8个二进制位为一组，来保存数据，我们称之为一个字节（Byte，简称B） 其中每个二进制位称之为一位（bit，简称b），1Byte=8bit简写1B=8b （4）其他数据形式是如何存储的 字符在计算机中是如何存储的\n​ ASCII编码表：即美国信息交换标准编码，规定了现代英语、数字字符、和其他西欧字符对应的数字编号。\n​ 字符存的是ASCII码表中对应的数字二进制形式。\n​ 字符’A’对应的数字是65\n​ 字符’a’对应的数字是97\n​ 字符’0’对应的数字是48\n图片数据-彩色图\n图片就是无数个像素点组成的 每个像素点的数据：用0~255*255*255表示其颜色 声音数据\n6、多学几招 （1）十进制转二进制的算法 十进制数转二进制数：除二取余法 二进制数转十进制数：按位展开分权相加 （2）八进制、十六进制介绍 为了便于观察和表示二进制，退出了八进制和十六进制 每3位二进制作为一个单元，最小数是0，最大数是7，共8个数字，这就是八进制 每4位二进制作为一个单元，最小数是0，最大数是15，共16个数字，依次用：0~9 ABCDEF代表就是十六进制。 （3）注意： ​ Java程序中支持书写二进制、八进制、十六进制的数据，分别需要以0B或者0b、0、0X或者0x开头。\n（4）计算机的数据单位 计算机最小的组成单元是：字节，1B=8b。 在B的基础上，计算机发展出了KB、MB、GB、TB、.这些数据单位。 1B=8b 1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB 四、数据类型 1、数据类型的作用 数据类型就是约束变量存储数据的形式\n2、数据类型的分类 引用数据类型（除了基本数据类型之外的，如String，其他的后面学习）\n基本数据类型：4大类8种\n注意：\n随便写的整数是int类型，加上L/l就是long类型 小数字面值默认是double类型，加上F/f就是float类型 五、关键字、标志符 1、关键字 Java自己保留的一些单词，作为特殊功能的，例如：public、class、byte、short、int、long、double.… 我们不能用来作为类名或者是变量名称，否则报错 注意：关键字很多，不用刻意去记\n2、标识符 ​ 标识符就是由一些字符、符号组合起来的名称，用于给类、方法、变量等起名字的规矩\n（1）标识符的要求 基本要求：由数字、字母、下划线（_）和美元符（$）等组成 强制要求：不能以数字开头，不能是关键字、区分大小写 （2）命名指导规范 变量名称：满足标识符规则，建议全英文、有意义、首字母小写、满足“驼峰模式”。 类名称：满足标识符规则，建议全英文、有意义、首字母大写、满足“驼峰模式”。 第九节：类型转换 一、自动类型转换 1、什么是自动类型转换，为什么要学习类型转换？ 类型范围小的变量，可以直接赋值给类型大的变量。 存在不同类型的变量赋值给其他类型的变量 2、自动类型转换的底层原理 3、自动类型转换的其他形式 二、表达式的自动类型转换 1、表达式的自动类型转换 在表达式中，小范围类型的变量会自动转换成当前较大范围的类型在运算。\n注意事项\n表达式的最终结果类型由表达式中的最高类型决定。 在表达式中，byte、short、char是直接转换成int类型参与运算的。 三、强制类型转换 ​ 类型范围大的数据或者变量，不能直接赋值给类型范围小的变量，会报错。\n1、强制类型转换 ​ 可以强行将类型范围大的变量、数据赋值给类型小的变量\n2、强制类型转换底层原理 注意事项\n强制类型转换可能造成数据（丢失）溢出。 浮点型强制转换成整型，直接丢掉小数部分，保留整数部分返回。 第十节、运算符 一、基本算数运算符 1、运算符 对字面量或者变量进行操作的符号\n2、数字运算符 符号 作用 说明 + 加 参考小学数学一年级 - 减 参考小学数学一年级 * 乘 参考小学数学二年级，与“✖”相同 / 除 与“➗”相同，注意：在Java中两个整数相除结果还是整数。因为最高类型是整数 % 取余 获取的是两个数据做除法的余数 二、+符号做连接符 1、“+”做连接符 ​ “+”符号与字符串运算的时候是用作连接符的，其结果依然是一个字符串\n独门秘籍：能算则算，不能算就在一起（计算机很聪明）\n三、自增自减运算符 1、自增自减运算符 符号 作用 说明 ++ 自增 变量自身的值加1 – 自减 变量自身的值减1 注意：\n++和–既可以放在变量的后边，也可以放在变量的前边 ++、–只能操作变量，不能操作字面量 2、自增自减的使用注意事项 如果单独使用放在前后没有区别\n++、–如果不是单独使用（如在表达式中、或者同时有其他操作），放在变量前后会存才明显区别\n放在变量前面，先对变量进行+1、-1，再拿变量的值进行运算\nint a = 10; int rs = ++a; 放在变量后面，先拿变量的值进行运算，再对变量的值进行+1、-1\nint b= 10; int rs = b++; 四、赋值运算符 1、基本赋值运算符 就是“=” int a = 10;//先看“=”右边，把数据10赋值给左边变量a存储 2、扩展赋值运算符 符号 作用 说明 += 加后赋值 a+=b等价于a = （a的数据类型）（a+b）；将a+b的值给a -= 减后赋值 a-=b等价于a = （a的数据类型）（a-b）；将a-b的值给a *= 乘后赋值 a*=b等价于a = （a的数据类型）（a*b）；将a*b的值给a /= 除后赋值 a/=b等价于a = （a的数据类型）（a/b）；将a/b的商给a %= 取余后赋值 a%=等价于a = （a的数据类型）（a%b）；将a%b的值给a 注意：扩展的赋值运算符隐含了强制类型转换\n五、关系运算符 1、关系运算符 是对数据进行条件判断的符号，最终会返回一个比较的布尔值（false 、true）\n**注意：**在做相等判断时，千万不要把==误写成=\n六、逻辑运算符 1、逻辑运算符概念 可以把多个条件的布尔结果放在一起，最终返回一个布尔结果\n2、短路逻辑运算符 **注意：**逻辑与“\u0026amp;”、逻辑或“ | ”：无论左边是false还是true，右边都要执行\n七、三元运算符 1、三元运算符介绍 格式：\n条件表达式？值1：值2 执行流程：首先计算关系表达式的值，如果为true，返回值1，如果为false，返回值2\n八、运算符优先级 1、运算符优先级 在表达式中，哪个运算符先执行后执行是要看优先级的，例如“*、/”的优先级高于“+、-”。\n九、案例知识：键盘录入技术 1、需求： 请完成Java程序与用户交互，比如录入用户输入名称、年龄，怎么办？\n2、API（Application Programming Interface，应用程序编程接口） Java写好的程序（功能代码），咱们可以直接调用 Oracle也为Java写好的程序提供了相应的API文档（技术使用说明书） 3、下载API文档 https://www.oracle.com/java/technologies/downloads/#jdk19-windows\n4、键盘录入功能实现的三个步骤： 导包：告诉程序去JDK的那个包中找扫描器技术 写一行代码代表得到键盘扫描对象 等待用户输入数据 注意：\nSystem、String在JDK中的Java.lang包下 lang包不需要我们导包，是默认的包 第十节、顺序结构（程序默认） ​ Java提供了一些流程控制语句，来控制程序的执行流程\n​ 如果你没有写其他的结构，按照代码的先后顺序，依次执行程序中大多数的代码是这样执行的。\n第十一节、分支结构 一、if分支结构 1、if分支 ​ 根据判定的结果（真或假）决定执行某个分支的代码\n2、if分支有三种格式 格式1\nif(条件表达式){ 语句体; } 格式2\nif(条件表达式){ 语句体1; }else{ 语句体2; } 格式3\nif(条件表达式1){ 语句体1; }else if(条件表达式2){ 语句体2; }else if(条件表达式3){ 语句体3; } ... else{ 语句体n+1; } 二、switch分支 1、swutch分支 ​ 也是匹配条件去执行分支，适合做值匹配的分支，结构清晰，格式良好\n2、格式 switch（表达式）{ case 值1: 执行代码...; bresk; case 值2: 执行代码...; bresk; ... case 值n-1: 执行代码...; bresk; default: 执行代码n; } 3、执行流程 先执行表达式的值，拿着这个值与case后的值进行匹配 匹配哪个case的值为true就执行哪个case，遇到break就跳出switch分支 如果case后的值都不匹配则执行defauli代码 4、if、switch分支各自适合做什么业务场景 if其实在功能上远远强大于switch if适合做区间匹配 switch适合做值匹配、代码优雅 5、switch分支注意事项 表达式类型只能是byte、short、int、char，JDK5开始支持枚举，JDK7开始支持String、不支持double、float、long case给出的值不允许重复，且只能是字面量，不能是变量 不要忘记写break，否则会出现穿透现象 6、switch穿透性 ​ 如果代码执行到没有写break的case模块，执行完后将直接进入下一个case块执行代码（而且不会进行任何匹配），直到遇到break才跳出分支，这是switch的穿透性\n​ 存在多个case分支的功能代码是一样是，可以用穿透性把流程集中到同一处处理，这样可以简化代码。\n第十二节、循环结构 一、for循环 1、for循环 ​ 控制一段代码反复执行很多次\n2、格式 for(初始化语句;循环条件;迭代语句){ 循环体语句(重复执行的代码); } 二、while循环 1、while循环格式与执行流程\n初始化语句; while(循环条件){ 循环体语句(被重复执行的代码) 迭代语句; } 2、什么时候用for循环，什么时候用while循环\n功能上是完全一样的，for能解决的while也能解决，反之亦然 使用规范是：知道循环几次使用for；不知道循环几次建议使用while。 三、do-while循环 1、do-while循环 先执行再判断循环条件 do-while循环的特点：一定会先执行一次循环。 2、格式 初始化语句 do{ 循环体语句; 迭代语句; }while(循环条件); 四、三种循环的区别 for循环和while循环（先判断后执行） do…while（第一次先执行后判断） for和while的区别 for循环和while循环的执行流程是一模一样的 如果已知循环次数建议使用for循环，如果不清楚要循环多少次建议使用while循环。 fo循环中，控制循环的变量只在循环中可以使用。While循环中，控制循环的变量在循环后还可以继续使用。 五、死循环 ​ 一直循环的执行下去，如果没有干预不会停下来。\n1、写法 六、嵌套循环 循环中又包含循环\n1、嵌套循环的特点 外部循环每执行一次，内部循环全部执行完一次。\n七、跳转关键字：break、continue 1、跳转控制语句介绍 break 跳出并结束当前所在循环的执行\ncontinue 用于跳出当前循环的当次执行，进入下一次循环\n2、注意事项 break 只能用于结束所在循环，或者结束所在switch分支执行\ncontinue 只能在循环中使用\n八、案例技术：随机数Random类 1、 Random随机数技术 作用：用于在程序中获取随机数的技术\n2、使用步骤 （1）导包：告诉程序去JDK的那个包中找随机数技术\n（2）写一行代码代表的到随机数对象\n（3）调用随机数的功能获取0-9的随机数\n注意： nextInt功能只能生成：0至n-1之间的随机数，不包含n。\n3、Random生成随机数的特点 nextInt(n)功能只能生成：0-(n-1)之间的随机数。 4、Random生成区间随机数的技巧：减加法 例如：要生成1-10之间的随机数，程序怎么实现？ [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nOj5hN62-1684550528660)(.\\img\\生成随机数的减加法.png)]\n5、生成指定区间的方法 //导包 import java.util.Random; 第十三节、数组 ​ 数组就是用来存储一批同种类型数据的内存区域（可以理解成容器）。\n例如：\n数组适合做一批同样种类数据的存储\n一、数组的定义 1、静态初始化数组 定义数组的时候直接给数组赋值\n静态初始化数组的格式 数组的基本原理 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-u7S0pPdL-1684550528663)(.\\img\\数组的基本原理.png)]\n==注意：==数组变量名中存储的是数组在内存中的地址，数组是引用类型。\n数组的访问 数组的长度属性：length //获取数组的长度（就是数组元素的个数） System.out.println(arr.length); 数组的最大索引：数组名.length-1（前提：元素个数大于0）\n数组的几个注意事项 “数据类型[] 数组名” 也可以写成 “数据类型 数组名[]”。 什么类型的数组存放什么类型的数据，否则报错 数组一旦定义出来，程序执行的过程中，长度、类型就固定了。 2、动态初始化数组 ​ 定义数组的时候只确定元素的类型和数组的长度，之后再存入具体数据\n数组的动态初始化格式 两种数组的定义有什么区别 当前已经知道存入的元素值，用静态初始化。 当前还不知道要存入那些数据，用动态初始化。 动态初始化数组的元素默认值 元素默认值规则 两种初始化的使用场景总结、注意事项 动态初始化：只指定数组长度，后期赋值，适合开始知道数据的数量，但是不确定具体元素值的业务场景。 开始就存入元素值，适合一开始就能确定元素值的业务场景。 两种格式的写法是独立的严，不可以混用。 二、数组的遍历 1、数组遍历介绍 遍历：就是一个一个数据的访问 为什么要遍历数组？搜索、数据统计等等都要用到遍历 三、数组排序 ​ 就是对数组中的元素，进行升序（由小到大）或者降序（由大到小）的操作\n1、数组排序的技术 冒泡排序 从头开始两两比较，把较大的元素与较小的元素进行交换 每轮把节前最大的一个元素存入到数组当前的末尾。 实现步骤 定义一个外部循环控制总共需要冒几轮（数组的长度-1） 定义一个内部循环，控制每轮依次往后比较几个位置（数组长度-i-1)。 如果当前元素\u0026gt;后一个元素值，两者交换 选择排序\n快速排序\n插入排序\n2、数组搜索相关技术 二分搜索 分块查找 哈希表查找 四、数组的内存图 1、Java内存分配介绍 栈内存\n方法运行时所进入的内存，变量也是存在这里的\n堆内存\nnew出来的东西会在这块内存中开辟空间并产生地址\n方法区\n字节码文件加载时进入的内存\n本地方法栈\n寄存器\n2、数组内存图 3、两个变量指向同一个数组 五、数组使用的常见问题 1、如果访问的元素位置超过最大索引，执行时会出现ArraylndexOutOfBoundsException(数组索引越界异常)\n2、如果数组变量中没有存储数组的地址，而是nulL,在访问数组信息时会出现NullPointerException(空指针异常)\n六、Debug工具的使用 1、Debug工具（断电调试工具） ​ IDEA自带的断电调试（排错）工具，可以控制代码从断电开始一行一行的执行，然后详细观看程序执行的情况\n2、Debug工具基本使用步骤 在需要控制的代码左侧点一下，形成断点 选择使用Debug方式启动程序，启动后程序会在断电暂停 控制代码一行行的往下执行 第十四节、方法 什么是方法？ ​ 方法是一种语法结构，它可以把一段代码封装成一个功能，以方便重复调用。\n方法的优势： 提高了代码的复用性 让程序的逻辑更清晰 一、方法的定义、调用 1、方法定义的完整格式 修饰符 返回值类型 方法名(形参列表){ 放法体代码（需要执行的功能代码）; return 返回值; } 2、方法的调用格式 方法必须调用才可以跑起来，调用格式：\n方法名(参数); 3、方法格式的注意点 方法的修饰符：暂时都使用piblic static修饰 方法申明了具体的返回值类型，内部必须使用return返回对应类型的数据 形参列表可以有多个，甚至可以没有；如果有多个形参，多个形参必须用“，”隔开，且不能给初始化值。 4、方法定义的其他写法 方法定义时：返回值类型、形参列表可以按照需求进行填写。\n注意事项： 如果方法不需要返回结果，返回值类型必须申明成void(无返回值)，此时方法内部不可以使用return返回数据。 方法如果没有参数，或者返回值类型申明为void可以称为无参数、无返回值的方法，依次类推 二、方法使用的常见问题 1、方法的编写顺序无所谓\n2、方法与方法之间是平级关系，不能嵌套定义\n3、方法的返回值类型为void（无返回值），方法内部不能使用return返回数据，如果方法的返回值类型写了具体类型，方法内部必须使用return返回对应数据类型的数据\n4、return语句下面，不能编写代码，因为永远执行不到，属于无效代码。\n5、方法不调用就不执行，调用时必须严格匹配方法的参数情况\n6、有返回值的方法调用时可以选择定义变量接收结果，或者直接输出调用，甚至直接调用；无返回值方法的调用只能直接调用一下。\n三、方法定义的技巧说明 1、修饰符：public static（暂时固定）\n2、方法名称：自己取名，有意义，英文小写，驼峰模式。\n3、方法体代码：完成自己需要写的功能代码即可\n4、真正需要关注的就两点： 分析方法是否需要申明返回值类型； 分析方法是否需要接收参数。 四、方法调用的内存图 1、方法的调用流程-内存图解 方法没有被调用的时候，在方法区中的字节码文件中存放 方法被调用的时候，需要进入到栈内存中运行 五、方法的参数传递机制 1、Java的参数传递机制：值传递 ​ 在传输实参给方法的形参的时候，并不是传输实参变量本身，而是传输实参变量中存储的值，这就是值传递。\n注意： 形参：以方法为例，就是方法定义时的变量。 实参：在方法内部定义的变量 2、引用类型的参数传递 3、基本类型和引用类型的参数在传递的时候有什么不同？ 都是值传递。 基本类型的参数传输存储的数据值。 引用类型的参数传输存储的地址值。 六、方法重载 ​ 同一个类中，出现多个方法名称相同，但是形参不同的，那么这些方法就是重载方法\n1、方法重载的作用 ​ 对于相似功能的业务场景：可读性好，方法名称相同提示是同一类型的功能，通过形参不同实现功能差异化的选择，这是一种专业的代码设计。\n2、方法重载的识别技巧 只要是同一个类中，方法名称相同、形参列表不同，那么他们就是重载的方法，其他都不管！(如：修饰符，返回值类型都无所谓) 形参列表不同指的是：形参的个数、类型、顺序不同，不关心形参的名称。 七、return关键字单独使用 ​ return；可以立即跳出并结束当前方法的执行；return关键字单独使用可以放在任何方法中。\n第十五节：面向对象 1、什么是面向对象编程？\n面向：找、拿\n对象：东西\n面向对象编程：找或者拿东西过来编程\n2、面向对象编程的好处，为什么用面向对象编程？\n符合人类思维习惯，编程跟简单，更好理解\n3、面向对象学什么？\n学习自己设计对象并使用\n学习面向对象的语法\n一、设计对象并使用 1、设计类，创建对象并使用 什么是类，什么是对象？ **类（）设计图：**是对象共同特征的描述。 **对象：**是真实存在的具体实例。 **结论：**在java中，必须先设计类，才能创建对象并使用 （2）如何设计类 （3）如何得到类对象 （4）如何使用对象在这里插入图片描述 2、定义类的几个补充注意事项 1、定义类有哪些建议，有什么需要注意的？ 类名首字母建议大写，且有意义，满足“驼峰模式”，不能用关键字，必须是合法的标识符。 一个Java文件中可以定义多个class类，但只能一个类是public修饰，而且public修饰的类名必须成为代码文件名。实际开发中建议还是一个文件定义一个class类。 2、成员变量的格式是什么样的，有什么特点 成员变量的完整定义格式是：修饰符 数据类型 变量名称 = 初始化值； 一般无需指定初始化值，存在默认值。 成员变量的默认值规则\n二、对象在内存中的运行机制 1、两个对象内存图 总结：\n对象放在堆内存中 Car c = new Car();c变量中存储的是对象在堆内存中的地址 成员变量的数据放在对象中，也就是存在于堆内存中 2、两个变量指向同一个对象的内存图 垃圾回收：\n注意：当堆内存中的对象，没有被任何变量引用（指向）时，就会被判定为内存中的“垃圾”\nJava存在自动垃圾回收器，会定期进行垃圾清理\n三、构造器 1、学习构造器的目的： 真正知道对象具体是通过调用什么代码得到的。 能够掌握为对象赋值的其他简便写法 为以后学习面向对象编程的其他内容做支撑 2、构造器的作用 定义在类中的，可以用于初始化一个类的对象，并返回对象的地址。\n3、构造器的格式 修饰符 类名(形参列表){ ... } 例如：\npublic class Car{ ... //无参构造器 public Car(){ ... } //有参构造器 public Car(Sting n,double p){ ... } } 4、构造器的分类和作用 无参数构造器（默认存在的）：初始化对象时，成员变量的数据均采用默认值。 有参数构造器：在初始化对象的时候，同时可以接受参数为对象进行赋值。 5、构造器的注意事项 任何类定义出来，默认就自带了无参数构造器，写不写都有。 一旦定义了有参数构造器，那么无参数构造器就没有了，如果还想用无参数构造器，此时就需要自己手写一个无参数构造器了。 四、this关键字 1、this关键字是什么 可以出现在构造器、方法中 代表当前对象的地址。 2、this关键字的作用 可以用于指定访问当前对象的成员变量、成员方法。\n3、this出现在有参数构造器中的用法 ​ 可以用于访问当前对象的成员变量、成员方法（代表了当前对象）。\n五、封装 1、封装 面向对象的三大特征：封装，继承，多态\n**封装：**告诉我们，如何正确设计对象的属性和方法。\n**封装的原则：**对象代表什么，就得封装对应的数据，并提供数据对应的行为。\n2、理解封装思想有啥好处 有什么事，找对象，调方法就行，编程变得很简单。 降低学习成本，可以少学、少记。 3、如何进行分装更好 一般建议对成员变量使用private（私有、隐藏）关键字修饰（private修饰的成员只能在当前类中访问） 为每个成员变量提供配套public修饰的getter、setter方法暴露取值和赋值 六、标准JavaBean 1、JavaBean 也可以称为实体类，其对象可以用于在程序中封装数据。\n2、标准JavaBean需要满足如下要求： 成员变量使用private修饰 提供成员变量对应的setXxx()/getXxx()方法 必须提供一个无参构造器；有参数构造器可写可不写。 七、补充知识：成员变量、局部变量的区别 区别 成员变量 局部变量 类中位置不同 类中，方法外 常见于方法中 初始化值不同 有默认值，无需初始化 没有默认值 内存位置不同 堆内存 栈内存 生命周期不同 随着对像的创建而存在，随着对象的消失而消失 随着方法的调用而存在，随着方法的运行结束而消失 作用域 在所属的大括号中 第十六节、常用API 一、API（Application Programming Interface，应用程序编程接口） 1、Java写好的技术（功能代码），咱们可以直接调用\n2、Oracle也为Java提供的这些功能代码提供了相应的API文档（技术说明书）\n3、下载API文档:\nhttp://www.oracle.com/technetwork/java/javase/downloads/index.html\n二、String 1、String概述 java.lang.String类代表字符串，String类定义的变量可以用于指向字符串对像，然后操作该字符串。 Java程序中的所有字符串文字（例如 “abc”)都为此类的对象。 2、String类的特点详解 String其实常被称为不可变字符串类型，它的对象在创建后不能被改变 3、字符串对象存在哪里？ 以“ ”方式给出的字符串对象，在字符串常量池中存储。 4、String是不可变字符串的原因？ String变量每次的修改其实都是产生并指向了新的字符串对象。 原来的字符串对象都是没有改变的，所以称不可变字符串。 三、String类创建对象的2种方式 1、创建方法： 方式一：直接使用“ ”定义。（推荐方式）\nString name = \u0026#34;传智教育\u0026#34;; 方式二：通过String类的构造器创建对象。\n构造器 说明 public String() 创建一个空白字符串对象，不含有任何内容 public String(String original) 根据传入的字符内容，来创建字符串对象 public String(char[] chs) 根据字符数组的内容，来创建字符串对象 public String(byte[] chs) 根据字节数组，来创建字符串对象 2、区别 以 “ ” 方式给出的字符串对象，在字符串常量池中存储，而且相同内容只会在其中存储一份 通过利用构造器new对象，每个new一次都会产生一个新对象，放在堆内存中 四、String类常用API-字符串内容比较 1、字符串内容比较 字符串的内容比较不适合用“==”比较 推荐使用String类提供的\u0026quot;equals“比较：只关心内容一样即可 方法名 说明 public blean equals(Object anObject) 将此字符串与指定对象进行比较，只关心字符内容是否一致 public blean equalsIgnoreCase(String anotherString) 将此字符串与指定对象进行比较，忽略大小写比较字符串。只关心字符内容是否一致 2、开发中什么时候使用==比较数据 基本数据类型比较时使用。 五、String类常用API-遍历、替代、截取、分割操作 1、String常用API 方法名 说明 public int length() 返回此字符串的长度 public char charAt(int index) 获取某个索引位置处的字符 public char[] toCharArray() 将当前字符串转换成字符数组返回 public String substring(int beginIndex,int endIndex) 根据开始和结束索引进行截取，得到新的字符串（包前不包后） public String substring(int beinIndex) 从传入的索引处截取，截取到末尾，得到新的字符串 public String replace(CharSequence target,CharSequence replacement) 使用新值，将字符串中的旧值替换，得到新的字符串 public String[] split(String regex) 根据传入的规则切割字符串，得到字符串数组返回 第十七节、集合概述 ​ 集合是与数组类似，也是一种容器，用于装数据的。\n一、集合的特点 集合的大小不固定，启动后可以动态变化，类型也可以不固定 集合非常适合做元素个数不确定，且要进行增删操作的业务场景 集合的提供了许多丰富、好用的功能，而且数组的功能很单一 二、ArrayList集合快速入门 1、ArrayList集合 ArrayList是集合中的一种，它支持索引。（暂时先学习这个，后期课程会学习整个集合体系）\n2、ArrayList集合的对象获取 构造器 说明 public ArrayList() 创建一个空的集合对象 3、ArrayList集合添加元素的方法 方法名 说明 pubilc boolean add(E e) 将指定的元素追加到此集合的末尾 public void add(int index,E element) 在此集合中指定位置插入指定的元素 三、ArrayList对于泛型的支持 1、泛型概述 ArrayList：其实就是一个泛型类，可以在阶段约束集合对象只能操作某种数据类型\n2、举例 ArrayList：此集合只能操作字符串类型的元素。 ArrayList:此集合只能操作整数类型的元素。 注意：集合中只能存储引用类型，不支持基本数据类型\n四、ArrayList常用API、遍历 方法名称 说明 public E get(int index) 返回指定索引处元素 public int size() 返回集合中的元素个数 public E remove(int index) 删除指定索引处的元素，返回被删除的元素 public boolean remove(Objet o) 删除指定的元素，返回删除是否成功 public E set(int index,Eelement) 修改指定索引出的元素，返回被修改的元素 后续 JavaSE加强篇\n文章知识点与官方知识档案匹配，可进一步学习相关知识\nJava技能树首页概览147459 人正在系统学习中\n本文转自 https://blog.csdn.net/wocao_666/article/details/130778863，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/java/javase%E5%9F%BA%E7%A1%80%E7%AF%87%E8%B6%85%E8%AF%A6%E7%BB%86java%E5%85%A5%E9%97%A8%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86-csdn%E5%8D%9A%E5%AE%A2/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Java","url":"/tags/java/"}],"timestamp":1720150487,"title":"JavaSE基础篇——超详细，Java入门，这一篇就够了-CSDN博客"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":"1、位（bit）：\n又名 比特位，表示二进制位，是计算中内部数据储存的最小单位。一个二进制位只能表示0和1两种状态。\n2、字节（byte）：\n是计算机中处理数据的基本单位。一个字节等于八位（1Byte = 8bit）\n3、字（word）：\n计算机进行数据处理时，一次存取、加工和传送的数据长度。在常见的计算机编码格式下，一个字等于两个字节（十六位）（1word = 2Byte = 16bit）\n一、JAVA中的数据类型分为两大类： 1、基本数据类型：整型、浮点型、字符型、布尔型\n整数类型 —— byte、short、int、long,\n浮点类型 —— float、double\n字符类型 —— char\n布尔类型 —— boolean\n2、引用数据类型：接口（interface）、数组（[ ]）、类（class）。\n1.基本数据类型(八种)： 1.1 整数类型 整型 占用字节空间大小 取值范围 默认值 byte 1字节 -128 ~ 127 0 short 2字节 -32768 ~ 32767 0 int 4字节 -2^31 ~ （2^31） - 1 0 long 8字节 -2^63 ~ （2^63） - 1 0L 1.2 浮点类型（小数） 浮点型 占用字节空间大小 取值范围 默认值 float 4字节 10^38 0.0F double 8字节 10^308 0.0 1.3 字符类型 字符型 占用字节空间大小 取值范围 默认值 char 2字节 0 ~ 65535 ‘\\u0’ 1.4 布尔类型 布尔型 占用字节空间大小 取值范围 默认值 boolean 视情况而定 true、false false 2.引用数据类型（三种）： 引用数据类型是建立在八大基本数据类型基础之上，包括数组、接口、类。引用数据类型是由用户自定义，用来限制其他数据类型。简单的说，除八大基本类型之外的所有数据类型，都为引用数据类型。\n所有引用类型的默认值都为 null 。\n二、数据类型转换： 转化从低级到高级：byte,short,char（三者同级）—\u0026gt; int —\u0026gt; long—\u0026gt; float —\u0026gt; double\n1、低级转换高级：自动类型转换\n2、高级转换低级：强制类型转换\n注意事项\n1、强制类型转换过程中可能造成数据丢失；\n2、强制类型转换时要在需要转换的数据类型前加上 ()。\n例如：\npublic class Demo1 { public static void main(String[] args) { int intNumber = 10; float floatNumber = 3.4F; double doubleNumber = 6.18; // 低优先级类型数据 + 高优先级类型数据 ——\u0026gt; 结果会自动转换为高优先级数据。 System.out.println(\u0026#34;int + float = \u0026#34; + (intNumber + floatNumber)); System.out.println(\u0026#34;int + double = \u0026#34; + (intNumber + doubleNumber)); System.out.println(); // 将 int + double 所得到的值进行强制转转换，为int类型数据，造成数据精度丢失 System.out.println(\u0026#34;(强制类型转换) int + double = \u0026#34; + (int)(intNumber + doubleNumber)); System.out.println(\u0026#34;(强制类型转换) double = \u0026#34; + (int)doubleNumber); } } 输出结果：\nint + float = 13.4 int + double = 16.18 (强制类型转换) int + double = 16 (强制类型转换) double = 6 文章知识点与官方知识档案匹配，可进一步学习相关知识\nJava技能树首页概览147466 人正在系统学习中\n本文转自 https://blog.csdn.net/weixin_42428778/article/details/109603769，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/java/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-+-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Java","url":"/tags/java/"}],"timestamp":1720150487,"title":"Java数据类型（八种基本数据类型 + 四种引用数据类型）"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":" Markdown语法大全(超级版) CSDN的参考文档并不全……\n文章目录 Markdown语法大全(超级版) 文章目录 概述 设计理念 内联 HTML 语法 特殊字符自动转义 行内语法讲解 注释的表述 代码法 html注释 hack方法 分级标题、任务列表 分级标题 任务列表 缩进、换行、空行、对齐方式 首行缩进 换行 空行 斜体、粗体、删除线、下划线、背景高亮 超链接、页内链接、自动链接、注脚 行内式 参考式 脚注 锚点（页内超链接） 自动链接 无序列表、有序列表、定义型列表 无序列表 有序列表 定义型列表 插入图像 多级引用 转义字符、字体、字号、颜色 转义字符 块语法讲解 内容目录 代码块 行内式 缩进式多行代码 流程图 表格 LaTeX 公式 分隔线 HTML 原始码 特殊字 说明：现在markDown编译器和各平台先支持情况都不太统一，为了达到一些效果会使用语法超集，但有些平台支持不好，请自行裁剪。\n概述 设计理念 Markdown 易于阅读，方便创作web文档，利于各平台无缝分发。\nMarkdown 语法灵感最大的来源还是纯文本 email 的格式，完全由标点符号标签组成的纯文本。\nMarkdown 文件应该以纯文本形式原样发布，不应该包含标记标签和格式化指令。\n内联 HTML 语法 HTML 是一种发布格式，Markdown 是一种创作格式。\nMarkdown语法集合比较小，只是HTML标签的一小部分。\n对于 Markdown 中未包含的标签, 可以直接使用 HTML标签，例如用 HTML \u0026lt;a\u0026gt;标签替代 Markdown 的链接语法。\n特殊字符自动转义 在 HTML 中, 有两个字符需要特殊对待: \u0026lt; 和 \u0026amp;，左尖括号用于起始标签。果你想将它们用作字面量, 你必须将它们转义为字符实体, 例如(\u0026amp;lt;)\u0026lt; 和 (\u0026amp;amp;)\u0026amp;。\n行内语法讲解 注释的表述 代码法 \u0026lt;div style=\u0026#39;display: none\u0026#39;\u0026gt; 哈哈我是注释，不会在浏览器中显示。 \u0026lt;/div\u0026gt; 这种方法CSDN不支持，但是直接转成html是可行的\nhtml注释 既然支持html语法，那也支持html注释，快捷键 command + /。\n\u0026lt;!--哈哈我是注释，不会在浏览器中显示。--\u0026gt; \u0026lt;!-- 哈哈我是多段注释， 不会在浏览器中显示。 --\u0026gt; 这里真的有注释···\nhack方法 hack方法就是利用markdown的解析原理来实现注释的。\n一般有的markdown解析器不支持上面的注释方法，这个时候就可以用hack方法。\nhack方法比上面2种方法稳定得多，但是语义化太差。\n[//]: # (哈哈我是最强注释，不会在浏览器中显示。) [^_^]: # (哈哈我是最萌注释，不会在浏览器中显示。) [//]: \u0026lt;\u0026gt; (哈哈我是注释，不会在浏览器中显示。) [comment]: \u0026lt;\u0026gt; (哈哈我是注释，不会在浏览器中显示。) 分级标题、任务列表 分级标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 \u0026lt;!--最多6级标题--\u0026gt; 任务列表 Markdown 语法：\n- [ ] 任务一 未做任务 `- + 空格 + [ ]` - [x] 任务二 已做任务 `- + 空格 + [x]` 效果如下：\n任务一 未做任务 - + 空格 + [ ] 任务二 已做任务- + 空格 + [x] 缩进、换行、空行、对齐方式 首行缩进 不同特殊占位符所占空白是不一样大的。\n\u0026amp;emsp; 或\u0026amp;#8195; //全角 \u0026amp;ensp; 或\u0026amp;#8194; //半角 \u0026amp;nbsp; 或\u0026amp;#160; //半角之半角（你还真的能看出来吗） 或//啥也没有 换行 由于markdown编辑器的不同,可能在一行字后面，直接换行回车，也能实现换行，但是在有的地方，想要换行必须得在一行字后面空两个格子才行。\n空行 在编辑的时候有多少个空行(只要这一行只有回车或者space没有其他的字符就算空行)，在渲染之后，只隔着一行。\n对齐方式\n代码：\n\u0026lt;center\u0026gt;行中心对齐\u0026lt;/center\u0026gt; \u0026lt;p align=\u0026#34;left\u0026#34;\u0026gt;行左对齐\u0026lt;/p\u0026gt; \u0026lt;p align=\u0026#34;right\u0026#34;\u0026gt;行右对齐\u0026lt;/p\u0026gt; 显示效果：\n行中心对齐\n行左对齐\n行右对齐\n斜体、粗体、删除线、下划线、背景高亮 代码：\n*斜体* 或 _斜体_ **粗体** 或 __粗体__ ***加粗斜体*** ~~删除线~~ ++下划线++（又是CSDN不支持···） ==背景高亮== 显示效果：\n斜体 或 斜体\n粗体 或 粗体\n加粗斜体\n删除线\n++下划线++\n背景高亮\n超链接、页内链接、自动链接、注脚 行内式 语法说明：\n[]里写链接文字，()里写链接地址, ()中的\u0026quot;\u0026ldquo;中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字，链接地址与title前有一个空格。\n代码：\n欢迎阅读 [Lapland Stark](https://blog.csdn.net/weixin_45494811) 显示效果：\n欢迎阅读 Lapland Stark\n参考式 参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用_引用_ 的方式创建链接将非常好，它可以让你对链接进行统一的管理。\n语法说明：\n参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址。\n如果链接文字本身可以做为链接标记，你也可以写成\n[链接文字][Num] [链接文字]：链接地址的形式，见代码的最后一行。 代码：\n我经常去的几个网站[Google][1]、[Leanote][2]。 [1]:http://www.google.com [2]:http://www.leanote.com 显示效果：\n我经常去的几个网站Google、Leanote。\n脚注 在需要添加注脚的文字后加上脚注名字 [^注脚名字] ,称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。\n注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。\n代码：\n使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2]。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言 显示效果：\n使用 Markdown1可以效率的书写文档, 直接转换成 HTML2。\n注：脚注自动被搬运到最后面，请到文章末尾查看，脚注后方的链接可以直接跳转回到加注的地方。\n锚点（页内超链接） 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的，只支持在标题后插入锚点，其它地方无效。\n自动链接 语法说明：\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用\u0026lt;\u0026gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n代码：\n\u0026amp;lt;http://example.com/\u0026amp;gt; \u0026amp;emsp;\u0026amp;emsp; \u0026amp;lt;address@example.com\u0026amp;gt; \u0026lt;http://example.com/\u0026gt; \u0026lt;address@example.com\u0026gt; 显示效果：\nhttp://example.com/ address@example.com\nhttp://example.com/ address@example.com\n无序列表、有序列表、定义型列表 无序列表 使用 *，+，- 表示无序列表。\n代码：\n* 无序列表项 一 + 无序列表项 二 - 无序列表项 三 显示效果：\n无序列表项 一\n无序列表项 二\n无序列表项 三\n有序列表 有序列表则使用数字接着一个英文句点。\n代码：\n1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三 显示效果：\n有序列表项 一 有序列表项 二 有序列表项 三 定义型列表 语法说明：\n定义型列表由名词和解释组成。空一行，然后一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)\n代码\nMarkdown : 轻量级文本标记语言（左侧有一个可见的冒号和四个不可见的空格） 显示效果：\nMarkdown\n轻量级文本标记语言（左侧有一个可见的冒号和四个不可见的空格）\n插入图像 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停y于图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。\n语法：\n\u0026lt;center\u0026gt; \u0026lt;!--开始居中对齐--\u0026gt; ![Lapland](https://img-blog.csdnimg.cn/20200214111424248.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5NDgxMQ==,size_16,color_FFFFFF,t_70 \u0026#34;Lapland\u0026#34;) \u0026lt;/center\u0026gt; \u0026lt;!--结束居中对齐--\u0026gt; 效果如下：\n多级引用 语法说明：\n引用需要在被引用的文本前加上\u0026gt;符号和空格，允许多层嵌套，也允许你偷懒只在整个段落的第一行最前面加上 \u0026gt; 。\n代码：\n\u0026gt;\u0026gt;\u0026gt; 请问 Markdwon 怎么用？ - 小白 \u0026gt;\u0026gt; 自己看教程！ - 愤青 \u0026gt; 教程在哪？ - 小白 显示效果：\n请问 Markdwon 怎么用？ - 小白\n自己看教程！ - 愤青\n教程在哪？ - 小白\n转义字符、字体、字号、颜色 转义字符 Markdown中的转义字符为\\，转义的有：\n\\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号\n字体、字号、颜色\n代码：\n\u0026lt;font face=\u0026#34;黑体\u0026#34;\u0026gt;我是黑体字\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026#34;微软雅黑\u0026#34;\u0026gt;我是微软雅黑\u0026lt;/font\u0026gt; \u0026lt;font face=\u0026#34;STCAIYUN\u0026#34;\u0026gt;我是华文彩云\u0026lt;/font\u0026gt; \u0026lt;font color=#0099ff size=12 face=\u0026#34;黑体\u0026#34;\u0026gt;黑体\u0026lt;/font\u0026gt; \u0026lt;font color=gray size=5\u0026gt;gray\u0026lt;/font\u0026gt; \u0026lt;font color=#00ffff size=3\u0026gt;null\u0026lt;/font\u0026gt; 显示效果：\nCSDN显示不了我也没办法呀(ｰ ｰ;)\n我是黑体字\n我是微软雅黑\n我是华文彩云\n黑体\ngray\nnull\n块语法讲解 内容目录 在段落中填写 [TOC] 以显示全文内容的目录结构。\n@[toc]\n效果参见最上方的目录。\n代码块 对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。\n行内式 代码：\nC语言里的函数 `scanf()` 怎么使用？ 显示效果：\nC语言里的函数 scanf()怎么使用？\n缩进式多行代码 缩进 4 个空格或是 1 个制表符\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n代码：\n#include \u0026amp;lt;stdio.h\u0026amp;gt; int main(void) { printf(\u0026amp;#34;Hello world\\n\u0026amp;#34;); } 显示效果：\n#include \u0026amp;lt;stdio.h\u0026amp;gt; int main(void) { printf(\u0026amp;#34;Hello world\\n\u0026amp;#34;); } 用六个`包裹多行代码\n代码：\n``` include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); } ``` 显示效果：\ninclude \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); } 流程图 编辑自有道云笔记，代码：\n```mermaid graph LR A--\u0026gt;B ``` ```mermaid sequenceDiagram A-\u0026gt;\u0026gt;B: How are you? B-\u0026gt;\u0026gt;A: Great! ``` 显示效果：\nA\nB\nA B How are you? Great! A B\n表格 语法说明：\n不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。\n列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。\n第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。\n左对齐， :-: 中心对齐，-: 右对齐 表格代码：\n学号 姓名 序号 小明明 男 5 小红 女 79 小陆 男 192 LaTeX 公式 表示行内公式\n代码：\n质能守恒方程可以用一个很简洁的方程式 $E = m c^2$来表达。\n显示效果：\n质能守恒方程可以用一个很简洁的方程式 E = m c 2 E = m c^2 E=mc2来表达。\n表示整行公式:\n大部分的浏览器支持的\n$$ E = m c^2 $$ E = m c 2 E = m c^2 E=mc2\n分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n代码：\n* * * *** ***** - - - ----------- 显示效果都一样：\nHTML 原始码 在代码区块里面， \u0026amp; 、 \u0026lt; 和 \u0026gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：\n代码：\n第一个例子： \u0026lt;div class=\u0026#34;footer\u0026#34;\u0026gt; © 2004 Foo Corporation \u0026lt;/div\u0026gt; 第二个例子： \u0026lt;center\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th rowspan=\u0026#34;2\u0026#34;\u0026gt;值班人员\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;星期一\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;星期二\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;星期三\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;李强\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;张明\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;王平\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/center\u0026gt; 显示效果：\n第一个例子：\n© 2004 Foo Corporation\n第二个例子：\n值班人员 星期一 星期二 星期三 李强 张明 王平 特殊字 特殊字符 描述 字符的代码\n空格符 \u0026lt; 小于号 \u0026lt;\n大于号 \u0026gt;\n\u0026amp; 和号 \u0026amp;\n￥ 人民币 ¥\n© 版权 ©\n® 注册商标 ®\n°C 摄氏度 °C\n± 正负号 ±\n× 乘号 ×\n÷ 除号 ÷\n² 平方（上标²） ²\n³ 立方（上标³） ³\n注：本文根据简书文章修改完成\nMarkdown是一种纯文本标记语言 ↩︎\nHyperText Markup Language 超文本标记语言 ↩︎\n文章知识点与官方知识档案匹配，可进一步学习相关知识\nCS入门技能树MarkDown入门列表40950 人正在系统学习中\n本文转自 https://blog.csdn.net/weixin_45494811/article/details/104307670，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/markdown/markdown%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%E8%B6%85%E7%BA%A7%E7%89%88/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Markdown","url":"/tags/markdown/"}],"timestamp":1720150487,"title":"Markdown语法大全(超级版)"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":" 让 python pip 使用国内镜像源 国内镜像源： 清华：https://pypi.tuna.tsinghua.edu.cn/simple\n阿里云：http://mirrors.aliyun.com/pypi/simple/\n中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/\n华中理工大学：http://pypi.hustunique.com/\n山东理工大学：http://pypi.sdutlinux.org/\n豆瓣：http://pypi.douban.com/simple/\n注意：新版 Ubuntu 要求使用https源。\n例如：pip3 install -i https://pypi.doubanio.com/simple/ 包名\n临时使用：#\n可以在使用pip的时候加参数 -i https://pypi.tuna.tsinghua.edu.cn/simple\n例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华的镜像去安装pyspider库。\n永久修改，一劳永逸：#\nLinux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)\n内容如下：\n[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com windows下，直接在 %userprofile% 目录中创建一个 pip目录，再新建文件 pip.ini。（例如：C:\\Users\\WQP\\pip\\pip.ini）内容同上。\n引用：http://www.cnblogs.com/microman/p/6107879.html\n本文转自 https://www.cnblogs.com/chenjo/p/14071864.html，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/python/python-%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Python","url":"/tags/python/"}],"timestamp":1720150487,"title":"Python 国内镜像源"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":"终于有点实质性可以看到摸到的界面了，搜了一下虽然easygui用的不多，但是作为一个起步，先了解一下吧，毕竟道理想通。\n下面按照小甲鱼的代码敲了一遍\nimport easygui as g\nimport sys\nwhile 1:\ng.msgbox(\u0026lsquo;嗨，欢迎进入第一个界面小游戏\u0026rsquo;) #msgbox其实还可以设置第二个参数，第二个参数代表标题栏上面的文字，就如下面那个msgbox里面的 \u0026lsquo;结果\u0026rsquo;\nmsg=\u0026lsquo;请问你希望在鱼C工作室学习到什么知识呢？\u0026rsquo;\ntitle=\u0026lsquo;小游戏互动\u0026rsquo;\nchoices=[\u0026lsquo;谈恋爱\u0026rsquo;,\u0026lsquo;编程\u0026rsquo;,\u0026lsquo;OOXX\u0026rsquo;,\u0026lsquo;琴棋书画\u0026rsquo;]\nchoice=g.choicebox(msg,title,choices) #还没看文档，不过这个choicebox这个函数应该是可以接受好几个参数的，包括顶栏的标题，选项内容，已经主语句\ng.msgbox(\u0026lsquo;你的选择是:\u0026rsquo; + str(choice),\u0026rsquo;结果\u0026rsquo;)\nmsg =\u0026lsquo;你希望重新开始小游戏吗？\u0026rsquo;\ntitle=\u0026lsquo;请选择\u0026rsquo;\nif g.ccbox(msg,title):\npass\nelse:\nsys.exit(0)\n激活的界面如下：\n-\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n这里就是说明了，easygui函数也可以接受关键字参数\n然后，我们可以自行修改按钮的文本，ok_button是原始参数的名字！！，但是注意每个参数的排列顺序，比如你要修改标题名字，就得把这一个参数写在ok_button的前面\n接下去是ccbox，cc表示continue 还是 cancel\n他返回的是1和0，但是不代表True和False，但是在if里面还是可以用1和0，另外，选项后面还可以加，自己随意。\n这里讲的是buttonbox，这个和choicebox功能有点像，但是区别是，choicebox是类似于下拉列表的，而button则是按键型的。\n下面2个功能只是在返回值上有区别，没搞懂为什么要有这样的区别\n下面是很重要的一环，是讲插入图片的，但是easygui只接受gif格式的图片，下面是教程和自己做的例子\n下面讲choicebox的，他适用于什么情况呢？就是选项太多，导致用buttonbox的话会把界面拉太大\n下面是教程和自己做的例子\n接下来一节是比较重要的，就是让用户输入内容，教程和测试如下：\n一章节比一章节重要，下面是一个多项填写功能的函数，multenterbox,具体教程和试验如下：\n下面是passwordbox函数，可以将输入的函数表示为星号\n然后这个是多重条目的函数，可以有多重选项可以输入\n接下来一段是用于显示文本内容的函数, textbox\n接着是关于浏览文件夹的功能函数 diropenbox\n教程和试验如下\n接下来是打开文件的代码，教程和试验如下：\n然后是保存文件的函数 filesavebox，教程和试验如下\n最后，是一个捕获异常的，相对简单，只要写一句exceptionbox就可以用一个弹出框来显示错误内容\n文章知识点与官方知识档案匹配，可进一步学习相关知识\nPython入门技能树首页概览426662 人正在系统学习中\n本文转自 https://blog.csdn.net/bestallen/article/details/51933427?spm=1001.2101.3001.6661.1\u0026utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-51933427-blog-139477688.235%5Ev43%5Epc_blog_bottom_relevance_base6\u0026depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-51933427-blog-139477688.235%5Ev43%5Epc_blog_bottom_relevance_base6\u0026utm_relevant_index=1，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/python/python-%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%95%99%E7%A8%8B-easygui-%E7%AF%87/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Python","url":"/tags/python/"}],"timestamp":1720150487,"title":"Python 小甲鱼教程 Easygui 篇"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":"导入tkinter模块\n\u0026gt;\u0026gt;\u0026gt;from tkinter import messagebox 消息提示框 \u0026gt;\u0026gt;\u0026gt;messagebox.showinfo(\u0026#39;提示\u0026#39;,\u0026#39;你太帅了！\u0026#39;) 消息警告框 \u0026gt;\u0026gt;\u0026gt;messagebox.showwarning(\u0026#39;警告\u0026#39;,\u0026#39;您太帅了！\u0026#39;) 错误消息框 \u0026gt;\u0026gt;\u0026gt;messagebox.showerror(\u0026#39;错误\u0026#39;,\u0026#39;您帅出问题了\u0026#39;) 对话框 \u0026gt;\u0026gt;\u0026gt;messagebox.askokcancel(\u0026#39;提示\u0026#39;, \u0026#39;要执行此操作吗\u0026#39;) 返回值true/false\n\u0026gt;\u0026gt;\u0026gt;messagebox.askquestion(\u0026#39;提示\u0026#39;, \u0026#39;要执行此操作吗\u0026#39;) 返回值yes/no\n\u0026gt;\u0026gt;\u0026gt;messagebox.askyesno(\u0026#39;提示\u0026#39;, \u0026#39;要执行此操作吗\u0026#39;) 返回值true/false\n\u0026gt;\u0026gt;\u0026gt;messagebox.askretrycancel(\u0026#39;提示\u0026#39;, \u0026#39;要执行此操作吗\u0026#39;) 返回值true/false\n文件对话框 import tkinter.filedialog filename = tkinter.filedialog.asksaveasfilename() # 返回文件名 print(filename ) filename = tkinter.filedialog.asksaveasfile() # 会创建文件 print(filename ) filename =tkinter.filedialog.askopenfilename() # 返回文件名 print(filename ) filename = tkinter.filedialog.askopenfile() # 返回文件流对象 print(filename ) filename = tkinter.filedialog.askdirectory() # 返回目录名 print(filename ) filename = tkinter.filedialog.askopenfilenames() # 可以返回多个文件名 print(filename ) filename =tkinter.filedialog.askopenfiles() # 多个文件流对象 print(filename ) 文章知识点与官方知识档案匹配，可进一步学习相关知识\nPython入门技能树桌面应用开发Tkinter426662 人正在系统学习中\n本文转自 https://blog.csdn.net/XreqcxoKiss/article/details/108743930，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/python/python-%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA%E6%A1%86%E7%BB%83%E4%B9%A0tkinter.messagebox%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Python","url":"/tags/python/"}],"timestamp":1720150487,"title":"Python 弹出提示框练习：tkinter.messagebox使用方法"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":"在Python中需要通过正则表达式对字符串进⾏匹配的时候，可以使⽤⼀个python自带的模块，名字为re。\n正则表达式的大致匹配过程是：\n1.依次拿出表达式和文本中的字符比较，\n2.如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。\n3.如果表达式中有量词或边界，这个过程会稍微有一些不同。\nr：Python 中字符串的前导 r 代表原始字符串标识符，该字符串中的特殊符号不会被转义，适用于正则表达式中繁杂的特殊符号表示。 因此 r\u0026quot;\\n\u0026quot; 表示包含 '\\' 和 'n' 两个字符的字符串，而 \u0026quot;\\n\u0026quot; 则表示只包含一个换行符的字符串。\nprint(\u0026#34;\\\\n\u0026#34;) # 输出 \\nprint(r\u0026#34;\\n\u0026#34;) #输出 \\n re模块的使用：import re\nre.match函数 语法：re.match(pattern, string, flags=0)\n尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。匹配成功re.match方法返回一个匹配的对象。\n如果上⼀步匹配到数据的话，可以使⽤group⽅法来提取数据。以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。\ngroup()用来提出分组截获的字符串**，**（）用来分组，group() 同group（0）就是匹配正则表达式整体结果，group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。没有匹配成功的，re.search()返回None。\n举例：\n\u0026gt;\u0026gt;\u0026gt; import re\u0026gt;\u0026gt;\u0026gt; result = re.match(\u0026#34;itcast\u0026#34;,\u0026#34;itcast.cn\u0026#34;)\u0026gt;\u0026gt;\u0026gt; result.group()\u0026#39;itcast\u0026#39; 从string头开始匹配pattern完全可以匹配，pattern匹配结束，同时匹配终止，后面的.cn不再匹配，返回匹配成功的信息。\n匹配单个字符 [\u0026hellip;]字符集，对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，比如[abc]和[a-c]，第一个字符如果是^表示取反。所有特殊字符（比如\u0026quot;]\u0026quot;\u0026quot;-\u0026quot;\u0026quot;^\u0026quot;）在字符集中都失去原来的含义，如要使用可把\u0026quot;]\u0026quot;\u0026quot;-\u0026ldquo;放在第一个字符，\u0026quot;^\u0026ldquo;放在非第一个字符。\n举例：\nimport reret = re.match(\u0026#34;.\u0026#34;,\u0026#34;M\u0026#34;)print(ret.group())ret = re.match(\u0026#34;t.o\u0026#34;,\u0026#34;too\u0026#34;)print(ret.group())ret = re.match(\u0026#34;t.o\u0026#34;,\u0026#34;two\u0026#34;)print(ret.group())# 如果hello的⾸字符⼩写，那么正则表达式需要⼩写的hret = re.match(\u0026#34;h\u0026#34;,\u0026#34;hello Python\u0026#34;)print(ret.group())# 如果hello的⾸字符⼤写，那么正则表达式需要⼤写的Hret = re.match(\u0026#34;H\u0026#34;,\u0026#34;Hello Python\u0026#34;)print(ret.group())# ⼤⼩写h都可以的情况ret = re.match(\u0026#34;[hH]\u0026#34;,\u0026#34;hello Python\u0026#34;)print(ret.group())ret = re.match(\u0026#34;[hH]\u0026#34;,\u0026#34;Hello Python\u0026#34;)print(ret.group())ret = re.match(\u0026#34;[hH]ello Python\u0026#34;,\u0026#34;Hello Python\u0026#34;)print(ret.group())# 匹配0到9的多种写法ret = re.match(\u0026#34;[0123456789]Hello Python\u0026#34;,\u0026#34;7Hello Python\u0026#34;)print(ret.group())ret = re.match(\u0026#34;[0-9]Hello Python\u0026#34;,\u0026#34;7Hello Python\u0026#34;)print(ret.group())# 匹配0到3和5-9ret = re.match(\u0026#34;[0-35-9]Hello Python\u0026#34;,\u0026#34;7Hello Python\u0026#34;)print(ret.group())ret = re.match(\u0026#34;[0-35-9]Hello Python\u0026#34;,\u0026#34;4Hello Python\u0026#34;)#print(ret.group())ret = re.match(\u0026#34;嫦娥\\d号\u0026#34;,\u0026#34;嫦娥1号发射成功\u0026#34;)print(ret.group())ret = re.match(\u0026#34;嫦娥\\d号\u0026#34;,\u0026#34;嫦娥2号发射成功\u0026#34;)print(ret.group()) 结果：\nM\ntoo\ntwo\nh\nH\nh\nH\nHello Python\n7Hello Python\n7Hello Python\n7Hello Python\n嫦娥1号\n嫦娥2号\n匹配多个字符 举例：\nimport re#：匹配出，⼀个字符串第⼀个字⺟为⼤写字符，后⾯都是⼩写字⺟并且这些⼩写字⺟可有可⽆ret = re.match(\u0026#34;[A-Z][a-z]*\u0026#34;,\u0026#34;M\u0026#34;)print(ret.group())ret = re.match(\u0026#34;[A-Z][a-z]*\u0026#34;,\u0026#34;MnnM\u0026#34;)print(ret.group())ret = re.match(\u0026#34;[A-Z][a-z]*\u0026#34;,\u0026#34;Aabcdef\u0026#34;)print(ret.group())#匹配出，变量名是否有效names = [\u0026#34;name1\u0026#34;, \u0026#34;_name\u0026#34;, \u0026#34;2_name\u0026#34;, \u0026#34;__name__\u0026#34;]for name in names: ret = re.match(\u0026#34;[a-zA-Z_]+[\\w]*\u0026#34;,name) if ret: print(\u0026#34;变量名 %s 符合要求\u0026#34; % ret.group()) else: print(\u0026#34;变量名 %s ⾮法\u0026#34; % name)#匹配出，0到99之间的数字ret = re.match(\u0026#34;[1-9]?[0-9]\u0026#34;,\u0026#34;7\u0026#34;)print(ret.group())ret = re.match(\u0026#34;[1-9]?\\d\u0026#34;,\u0026#34;33\u0026#34;)print(ret.group())# 这个结果并不是想要的，利⽤$才能解决ret = re.match(\u0026#34;[1-9]?\\d\u0026#34;,\u0026#34;09\u0026#34;)print(ret.group())ret = re.match(\u0026#34;[a-zA-Z0-9_]{6}\u0026#34;,\u0026#34;12a3g45678\u0026#34;)print(ret.group())#匹配出，8到20位的密码，可以是⼤⼩写英⽂字⺟、数字、下划线ret = re.match(\u0026#34;[a-zA-Z0-9_]{8,20}\u0026#34;,\u0026#34;1ad12f23s34455ff66\u0026#34;)print(ret.group()) 结果：\nM\nMnn\nAabcdef\n变量名 name1 符合要求\n变量名 _name 符合要求\n变量名 2_name ⾮法\n变量名 __name__ 符合要求\n7\n33\n0\n12a3g4\n1ad12f23s34455ff66\n匹配开头结尾 举例：匹配163.com的邮箱地址\nimport reemail_list = [\u0026#34;xiaoWang@163.com\u0026#34;, \u0026#34;xiaoWang@163.comheihei\u0026#34;, \u0026#34;.com.xiaowang@qq.com\u0026#34;]for email in email_list: ret = re.match(\u0026#34;[\\w]{4,20}@163\\.com$\u0026#34;, email) if ret: print(\u0026#34;%s 是符合规定的邮件地址,匹配后的结果是:%s\u0026#34; % (email, ret.group())) else: print(\u0026#34;%s 不符合要求\u0026#34; % email) 结果：\nxiaoWang@163.com 是符合规定的邮件地址,匹配后的结果是:xiaoWang@163.com\nxiaoWang@163.comheihei 不符合要求\n.com.xiaowang@qq.com 不符合要求\n匹配分组 举例：|\n#匹配出0-100之间的数字import reret = re.match(\u0026#34;[1-9]?\\d$|100\u0026#34;,\u0026#34;8\u0026#34;)print(ret.group()) # 8ret = re.match(\u0026#34;[1-9]?\\d$|100\u0026#34;,\u0026#34;78\u0026#34;)print(ret.group()) # 78ret = re.match(\u0026#34;[1-9]?\\d$|100\u0026#34;,\u0026#34;08\u0026#34;)# print(ret.group()) # 不是0-100之间ret = re.match(\u0026#34;[1-9]?\\d$|100\u0026#34;,\u0026#34;100\u0026#34;)print(ret.group()) # 100 举例：()\n#需求：匹配出163、126、qq邮箱ret = re.match(\u0026#34;\\w{4,20}@163\\.com\u0026#34;, \u0026#34;test@163.com\u0026#34;)print(ret.group()) # test@163.comret = re.match(\u0026#34;\\w{4,20}@(163|126|qq)\\.com\u0026#34;, \u0026#34;test@126.com\u0026#34;)print(ret.group()) # test@126.comret = re.match(\u0026#34;\\w{4,20}@(163|126|qq)\\.com\u0026#34;, \u0026#34;test@qq.com\u0026#34;)print(ret.group()) # test@qq.comret = re.match(\u0026#34;\\w{4,20}@(163|126|qq)\\.com\u0026#34;, \u0026#34;test@gmail.com\u0026#34;)if ret: print(ret.group())else: print(\u0026#34;不是163、126、qq邮箱\u0026#34;) # 不是163、126、qq邮箱#不是以4、7结尾的⼿机号码(11位)tels = [\u0026#34;13100001234\u0026#34;, \u0026#34;18912344321\u0026#34;, \u0026#34;10086\u0026#34;, \u0026#34;18800007777\u0026#34;]for tel in tels: ret = re.match(\u0026#34;1\\d{9}[0-35-68-9]\u0026#34;, tel) if ret: print(ret.group()) else: print(\u0026#34;%s 不是想要的⼿机号\u0026#34; % tel)#提取区号和电话号码ret = re.match(\u0026#34;([^-]*)-(\\d+)\u0026#34;,\u0026#34;010-12345678\u0026#34;)print(ret.group())print(ret.group(1))print(ret.group(2)) 举例：\\number\n匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 (.+) \\1 匹配 'the the' 或者 '55 55', 但不会匹配 'thethe' (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果 number 的第一个数位是0， 或者 number 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 '[' 和 ']' 字符集合内，任何数字转义都被看作是字符。\n例子1：匹配出 \u0026lt;html\u0026gt;hh\u0026lt;/html\u0026gt; \\1,\u0026hellip;,\\9，匹配第n个分组的内容。如例子所示，指匹配第一个分组的内容。\nimport re# 正确的理解思路：如果在第⼀对\u0026lt;\u0026gt;中是什么，按理说在后⾯的那对\u0026lt;\u0026gt;中就应该是什么。通过引⽤分组中匹配到的数据即可，但是要注意是元字符串，即类似 r\u0026#34;\u0026#34;这种格式。ret = re.match(r\u0026#34;\u0026lt;([a-zA-Z]*)\u0026gt;\\w*\u0026lt;/\\1\u0026gt;\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;hh\u0026lt;/html\u0026gt;\u0026#34;)# 因为2对\u0026lt;\u0026gt;中的数据不⼀致，所以没有匹配出来test_label = [\u0026#34;\u0026lt;html\u0026gt;hh\u0026lt;/html\u0026gt;\u0026#34;,\u0026#34;\u0026lt;html\u0026gt;hh\u0026lt;/htmlbalabala\u0026gt;\u0026#34;]for label in test_label: ret = re.match(r\u0026#34;\u0026lt;([a-zA-Z]*)\u0026gt;\\w*\u0026lt;/\\1\u0026gt;\u0026#34;, label) if ret: print(\u0026#34;%s 这是一对正确的标签\u0026#34; % ret.group()) else: print(\u0026#34;%s 这是⼀对不正确的标签\u0026#34; % label) 结果：\n例子2：匹配出 www.itcast.cn\nimport relabels = [\u0026#34;\u0026lt;html\u0026gt;\u0026lt;h1\u0026gt;www.itcast.cn\u0026lt;/h1\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;h1\u0026gt;www.itcast.cn\u0026lt;/h2\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;]for label in labels: ret = re.match(r\u0026#34;\u0026lt;(\\w*)\u0026gt;\u0026lt;(\\w*)\u0026gt;.*\u0026lt;/\\2\u0026gt;\u0026lt;/\\1\u0026gt;\u0026#34;, label) if ret: print(\u0026#34;%s 是符合要求的标签\u0026#34; % ret.group()) else: print(\u0026#34;%s 不符合要求\u0026#34; % label) 结果：\n举例：(?P) (?P=name)\n一个用于标记，一个用于在同一个正则表达式中复用\nimport reret = re.match(r\u0026#34;\u0026lt;(?P\u0026lt;name1\u0026gt;\\w*)\u0026gt;\u0026lt;(?P\u0026lt;name2\u0026gt;\\w*)\u0026gt;.*\u0026lt;/(?P=name2)\u0026gt;\u0026lt;/(?P=name1)\u0026gt;\u0026#34;,\u0026#34;\u0026lt;html\u0026gt;\u0026lt;h1\u0026gt;www.itcast.cn\u0026lt;/h1\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;)ret.group()ret = re.match(r\u0026#34;\u0026lt;(?P\u0026lt;name1\u0026gt;\\w*)\u0026gt;\u0026lt;(?P\u0026lt;name2\u0026gt;\\w*)\u0026gt;.*\u0026lt;/(?P=name2)\u0026gt;\u0026lt;/(?P=name1)\u0026gt;\u0026#34;,\u0026#34;\u0026lt;html\u0026gt;\u0026lt;h1\u0026gt;www.itcast.cn\u0026lt;/h2\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;)#ret.group() re.compile 函数 compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。\nprog = re.compile(pattern)result = prog.match(string) 等价于\nresult = re.match(pattern, string) 举例：\n\u0026gt;\u0026gt;\u0026gt;import re\u0026gt;\u0026gt;\u0026gt; pattern = re.compile(r\u0026#39;\\d+\u0026#39;) m = pattern.match(\u0026#39;one12twothree34four\u0026#39;, 3, 10) # 从\u0026#39;1\u0026#39;的位置开始匹配，正好匹配\u0026gt;\u0026gt;\u0026gt; print m # 返回一个 Match 对象\u0026lt;_sre.SRE_Match object at 0x10a42aac0\u0026gt;\u0026gt;\u0026gt;\u0026gt; m.group(0) # 可省略 0\u0026#39;12\u0026#39;\u0026gt;\u0026gt;\u0026gt; m.start(0) # 可省略 03\u0026gt;\u0026gt;\u0026gt; m.end(0) # 可省略 05\u0026gt;\u0026gt;\u0026gt; m.span(0) # 可省略 0(3, 5) 在上面，当匹配成功时返回一个 Match 对象，其中：\ngroup([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)； start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0； end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0； span([group]) 方法返回 (start(group), end(group)) re.search函数 re.search 扫描整个字符串并返回第一个成功的匹配，如果没有匹配，就返回一个 None。\nre.match与re.search的区别：re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配\n举例：\nimport reret = re.search(r\u0026#34;\\d+\u0026#34;, \u0026#34;阅读次数为9999\u0026#34;)print(ret.group()) 结果：\n9999\nre.findall函数 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。注意**：** match 和 search 是匹配一次 findall 匹配所有。\n举例：\nimport reret = re.findall(r\u0026#34;\\d+\u0026#34;, \u0026#34;python = 9999, c = 7890, c++ = 12345\u0026#34;)print(ret) 结果：\n[\u0026lsquo;9999\u0026rsquo;, \u0026lsquo;7890\u0026rsquo;, \u0026lsquo;12345\u0026rsquo;]\nre.finditer函数 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。\nimport reit = re.finditer(r\u0026#34;\\d+\u0026#34;, \u0026#34;12a32bc43jf3\u0026#34;)for match in it: print(match.group()) 结果：\n12\n32\n43\n3\nre.sub函数 sub是substitute的所写，表示替换，将匹配到的数据进⾏替换。\n语法：re.sub(pattern, repl, string, count=0, flags=0)\n举例：将匹配到的阅读次数加1\n方法一：\nimport reret = re.sub(r\u0026#34;\\d+\u0026#34;, \u0026#39;998\u0026#39;, \u0026#34;python = 997\u0026#34;)print(ret) 结果：python = 998\n方法二：\nimport redef add(temp): #int（）参数必须是字符串，类似字节的对象或数字，而不是“re.Match” strNum = temp.group() num = int(strNum) + 1 return str(num)ret = re.sub(r\u0026#34;\\d+\u0026#34;, add, \u0026#34;python = 997\u0026#34;)print(ret)ret = re.sub(r\u0026#34;\\d+\u0026#34;, add, \u0026#34;python = 99\u0026#34;)print(ret) 结果;\npython = 998\npython = 100\nre.subn函数 行为与sub()相同，但是返回一个元组 (字符串, 替换次数)。\nre.subn(pattern, repl, string[, count])\n返回：(sub(repl, string[, count]), 替换次数)\nimport repattern = re.compile(r\u0026#39;(\\w+) (\\w+)\u0026#39;)s = \u0026#39;i say, hello world!\u0026#39;print(re.subn(pattern, r\u0026#39;\\2 \\1\u0026#39;, s))def func(m): return m.group(1).title() + \u0026#39; \u0026#39; + m.group(2).title()print(re.subn(pattern, func, s))### output #### (\u0026#39;say i, world hello!\u0026#39;, 2)# (\u0026#39;I Say, Hello World!\u0026#39;, 2) re.split函数 根据匹配进⾏切割字符串，并返回⼀个列表。\nre.``split(pattern, string, maxsplit=0, flags=0)\n举例：\nimport reret = re.split(r\u0026#34;:| \u0026#34;,\u0026#34;info:xiaoZhang 33 shandong\u0026#34;)print(ret) 结果：[\u0026lsquo;info\u0026rsquo;, \u0026lsquo;xiaoZhang\u0026rsquo;, \u0026lsquo;33\u0026rsquo;, \u0026lsquo;shandong\u0026rsquo;]\npython贪婪和⾮贪婪 Python⾥数量词默认是贪婪的（在少数语⾔⾥也可能是默认⾮贪婪），总是尝试匹配尽可能多的字符；⾮贪婪则相反，总是尝试匹配尽可能少的字符。\n例如：正则表达式”ab*”如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab*?”，将找到”a”。\n注：我们一般使用非贪婪模式来提取。\n在\u0026rdquo;*\u0026rdquo;,\u0026quot;?\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;{m,n}\u0026ldquo;后⾯加上？，使贪婪变成⾮贪婪。\n举例1：\nimport res=\u0026#34;This is a number 234-235-22-423\u0026#34;#正则表达式模式中使⽤到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满⾜匹配最⻓字符串，在我们上⾯的例⼦⾥⾯，“.+”会从字符串的启始处抓取满⾜模式的最⻓字符，其中包括我们想得到的第⼀个整型字段的中的⼤部分，“\\d+”只需⼀位字符就可以匹配，所以它匹配了数字“4”，⽽“.+”则匹配了从字符串起始到这个第⼀位数字4之前的所有字符r=re.match(\u0026#34;.+(\\d+-\\d+-\\d+-\\d+)\u0026#34;,s)print(r.group(1))#⾮贪婪操作符“？”，这个操作符可以⽤在\u0026#34;*\u0026#34;,\u0026#34;+\u0026#34;,\u0026#34;?\u0026#34;的后⾯，要求正则匹配的越少越好r=re.match(\u0026#34;.+?(\\d+-\\d+-\\d+-\\d+)\u0026#34;,s)print(r.group(1)) 结果：\n4-235-22-423\n234-235-22-423\n举例2：\n\u0026gt;\u0026gt;\u0026gt; re.match(r\u0026#34;aa(\\d+)\u0026#34;,\u0026#34;aa2343ddd\u0026#34;).group(1)\u0026#39;2343\u0026#39;\u0026gt;\u0026gt;\u0026gt; re.match(r\u0026#34;aa(\\d+?)\u0026#34;,\u0026#34;aa2343ddd\u0026#34;).group(1)\u0026#39;2\u0026#39;\u0026gt;\u0026gt;\u0026gt; re.match(r\u0026#34;aa(\\d+)ddd\u0026#34;,\u0026#34;aa2343ddd\u0026#34;).group(1)\u0026#39;2343\u0026#39;\u0026gt;\u0026gt;\u0026gt; re.match(r\u0026#34;aa(\\d+?)ddd\u0026#34;,\u0026#34;aa2343ddd\u0026#34;).group(1)\u0026#39;2343\u0026#39; 举例3：提取图片地址\nimport retest_str=\u0026#34;\u0026lt;img data-original=https://rpic.douyucdn.cn/appCovers/2016/11/13/1213973.jpg\u0026gt;\u0026#34;ret = re.search(r\u0026#34;https://.*?.jpg\u0026#34;, test_str)print(ret.group()) 结果：https://rpic.douyucdn.cn/appCovers/2016/11/13/1213973.jpg\nr的作⽤ 与大多数编程语言相同，正则表达式里使用”\\”作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\\\\\\\”：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，Python中字符串前⾯加上 r 表示原⽣字符串。\nimport remm = \u0026#34;c:\\\\a\\\\b\\\\c\u0026#34;print(mm)#c:\\a\\b\\cret = re.match(\u0026#34;c:\\\\\\\\\u0026#34;,mm).group()print(ret)#c:\\ret = re.match(\u0026#34;c:\\\\\\\\a\u0026#34;,mm).group()print(ret)#c:\\aret = re.match(r\u0026#34;c:\\\\a\u0026#34;,mm).group()print(ret)#c:\\aret = re.match(r\u0026#34;c:\\a\u0026#34;,mm).group()print(ret)#AttributeError: \u0026#39;NoneType\u0026#39; object has no attribute \u0026#39;group\u0026#39; 文章知识点与官方知识档案匹配，可进一步学习相关知识\nPython入门技能树网络爬虫正则表达式426640 人正在系统学习中\n本文转自 https://blog.csdn.net/guo_qingxia/article/details/113979135，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/python/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Python","url":"/tags/python/"},{"title":"正则表达式","url":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"timestamp":1720150487,"title":"Python——正则表达式(re模块)详解"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":" 注重版权，转载请注明原作者和原文链接\n作者：码农BookSea\n原文链接：https://blog.csdn.net/bookssea/article/details/107309591 先看后赞，养成习惯。\n点赞收藏，人生辉煌。\n讲解我们的爬虫之前，先概述关于爬虫的简单概念（毕竟是零基础教程）\n爬虫 网络爬虫（又被称为网页蜘蛛，网络机器人）就是模拟浏览器发送网络请求，接收请求响应，一种按照一定的规则，自动地抓取互联网信息的程序。\n原则上,只要是浏览器(客户端)能做的事情，爬虫都能够做。\n为什么我们要使用爬虫 互联网大数据时代，给予我们的是生活的便利以及海量数据爆炸式的出现在网络中。\n过去，我们通过书籍、报纸、电视、广播或许信息，这些信息数量有限，且是经过一定的筛选，信息相对而言比较有效，但是缺点则是信息面太过于狭窄了。不对称的信息传导，以致于我们视野受限，无法了解到更多的信息和知识。\n互联网大数据时代，我们突然间，信息获取自由了，我们得到了海量的信息，但是大多数都是无效的垃圾信息。\n例如新浪微博，一天产生数亿条的状态更新，而在百度搜索引擎中，随意搜一条——减肥100,000,000条信息。\n在如此海量的信息碎片中，我们如何获取对自己有用的信息呢？\n答案是筛选！\n通过某项技术将相关的内容收集起来，在分析删选才能得到我们真正需要的信息。\n这个信息收集分析整合的工作，可应用的范畴非常的广泛，无论是生活服务、出行旅行、金融投资、各类制造业的产品市场需求等等……都能够借助这个技术获取更精准有效的信息加以利用。\n网络爬虫技术，虽说有个诡异的名字，让能第一反应是那种软软的蠕动的生物，但它却是一个可以在虚拟世界里，无往不前的利器。\n爬虫准备工作 我们平时都说Python爬虫，其实这里可能有个误解，爬虫并不是Python独有的，可以做爬虫的语言有很多例如：PHP,JAVA,C#,C++,Python，选择Python做爬虫是因为Python相对来说比较简单，而且功能比较齐全。\n首先我们需要下载python，我下载的是官方最新的版本 3.8.3\n其次我们需要一个运行Python的环境，我用的是pychram\n也可以从官方下载，\n我们还需要一些库来支持爬虫的运行（有些库Python可能自带了）\n差不多就是这几个库了，良心的我已经在后面写好注释了\n（爬虫运行过程中，不一定就只需要上面几个库，看你爬虫的一个具体写法了，反正需要库的话我们可以直接在setting里面安装）\n爬虫项目讲解 我做的是爬取豆瓣评分电影Top250的爬虫代码\n我们要爬取的就是这个网站：https://movie.douban.com/top250\n这边我已经爬取完毕，给大家看下效果图，我是将爬取到的内容存到xls中\n我们的爬取的内容是：电影详情链接，图片链接，影片中文名，影片外国名，评分，评价数，概况，相关信息。\n代码分析 先把代码发放上来，然后我根据代码逐步解析\n# -*- codeing = utf-8 -*- from bs4 import BeautifulSoup # 网页解析，获取数据 import re # 正则表达式，进行文字匹配` import urllib.request, urllib.error # 制定URL，获取网页数据 import xlwt # 进行excel操作 #import sqlite3 # 进行SQLite数据库操作 findLink = re.compile(r\u0026#39;\u0026lt;a href=\u0026#34;(.*?)\u0026#34;\u0026gt;\u0026#39;) # 创建正则表达式对象，标售规则 影片详情链接的规则 findImgSrc = re.compile(r\u0026#39;\u0026lt;img.*src=\u0026#34;(.*?)\u0026#34;\u0026#39;, re.S) findTitle = re.compile(r\u0026#39;\u0026lt;span class=\u0026#34;title\u0026#34;\u0026gt;(.*)\u0026lt;/span\u0026gt;\u0026#39;) findRating = re.compile(r\u0026#39;\u0026lt;span class=\u0026#34;rating_num\u0026#34; property=\u0026#34;v:average\u0026#34;\u0026gt;(.*)\u0026lt;/span\u0026gt;\u0026#39;) findJudge = re.compile(r\u0026#39;\u0026lt;span\u0026gt;(\\d*)人评价\u0026lt;/span\u0026gt;\u0026#39;) findInq = re.compile(r\u0026#39;\u0026lt;span class=\u0026#34;inq\u0026#34;\u0026gt;(.*)\u0026lt;/span\u0026gt;\u0026#39;) findBd = re.compile(r\u0026#39;\u0026lt;p class=\u0026#34;\u0026#34;\u0026gt;(.*?)\u0026lt;/p\u0026gt;\u0026#39;, re.S) def main(): baseurl = \u0026#34;https://movie.douban.com/top250?start=\u0026#34; #要爬取的网页链接 # 1.爬取网页 datalist = getData(baseurl) savepath = \u0026#34;豆瓣电影Top250.xls\u0026#34; #当前目录新建XLS，存储进去 # dbpath = \u0026#34;movie.db\u0026#34; #当前目录新建数据库，存储进去 # 3.保存数据 saveData(datalist,savepath) #2种存储方式可以只选择一种 # saveData2DB(datalist,dbpath) # 爬取网页 def getData(baseurl): datalist = [] #用来存储爬取的网页信息 for i in range(0, 10): # 调用获取页面信息的函数，10次 url = baseurl + str(i * 25) html = askURL(url) # 保存获取到的网页源码 # 2.逐一解析数据 soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) for item in soup.find_all(\u0026#39;div\u0026#39;, class_=\u0026#34;item\u0026#34;): # 查找符合要求的字符串 data = [] # 保存一部电影所有信息 item = str(item) link = re.findall(findLink, item)[0] # 通过正则表达式查找 data.append(link) imgSrc = re.findall(findImgSrc, item)[0] data.append(imgSrc) titles = re.findall(findTitle, item) if (len(titles) == 2): ctitle = titles[0] data.append(ctitle) otitle = titles[1].replace(\u0026#34;/\u0026#34;, \u0026#34;\u0026#34;) #消除转义字符 data.append(otitle) else: data.append(titles[0]) data.append(\u0026#39; \u0026#39;) rating = re.findall(findRating, item)[0] data.append(rating) judgeNum = re.findall(findJudge, item)[0] data.append(judgeNum) inq = re.findall(findInq, item) if len(inq) != 0: inq = inq[0].replace(\u0026#34;。\u0026#34;, \u0026#34;\u0026#34;) data.append(inq) else: data.append(\u0026#34; \u0026#34;) bd = re.findall(findBd, item)[0] bd = re.sub(\u0026#39;\u0026lt;br(\\s+)?/\u0026gt;(\\s+)?\u0026#39;, \u0026#34;\u0026#34;, bd) bd = re.sub(\u0026#39;/\u0026#39;, \u0026#34;\u0026#34;, bd) data.append(bd.strip()) datalist.append(data) return datalist # 得到指定一个URL的网页内容 def askURL(url): head = { # 模拟浏览器头部信息，向豆瓣服务器发送消息 \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla / 5.0(Windows NT 10.0; Win64; x64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 80.0.3987.122 Safari / 537.36\u0026#34; } # 用户代理，表示告诉豆瓣服务器，我们是什么类型的机器、浏览器（本质上是告诉浏览器，我们可以接收什么水平的文件内容） request = urllib.request.Request(url, headers=head) html = \u0026#34;\u0026#34; try: response = urllib.request.urlopen(request) html = response.read().decode(\u0026#34;utf-8\u0026#34;) except urllib.error.URLError as e: if hasattr(e, \u0026#34;code\u0026#34;): print(e.code) if hasattr(e, \u0026#34;reason\u0026#34;): print(e.reason) return html # 保存数据到表格 def saveData(datalist,savepath): print(\u0026#34;save.......\u0026#34;) book = xlwt.Workbook(encoding=\u0026#34;utf-8\u0026#34;,style_compression=0) #创建workbook对象 sheet = book.add_sheet(\u0026#39;豆瓣电影Top250\u0026#39;, cell_overwrite_ok=True) #创建工作表 col = (\u0026#34;电影详情链接\u0026#34;,\u0026#34;图片链接\u0026#34;,\u0026#34;影片中文名\u0026#34;,\u0026#34;影片外国名\u0026#34;,\u0026#34;评分\u0026#34;,\u0026#34;评价数\u0026#34;,\u0026#34;概况\u0026#34;,\u0026#34;相关信息\u0026#34;) for i in range(0,8): sheet.write(0,i,col[i]) #列名 for i in range(0,250): # print(\u0026#34;第%d条\u0026#34; %(i+1)) #输出语句，用来测试 data = datalist[i] for j in range(0,8): sheet.write(i+1,j,data[j]) #数据 book.save(savepath) #保存 # def saveData2DB(datalist,dbpath): # init_db(dbpath) # conn = sqlite3.connect(dbpath) # cur = conn.cursor() # for data in datalist: # for index in range(len(data)): # if index == 4 or index == 5: # continue # data[index] = \u0026#39;\u0026#34;\u0026#39;+data[index]+\u0026#39;\u0026#34;\u0026#39; # sql = \u0026#39;\u0026#39;\u0026#39; # insert into movie250( # info_link,pic_link,cname,ename,score,rated,instroduction,info) # values (%s)\u0026#39;\u0026#39;\u0026#39;%\u0026#34;,\u0026#34;.join(data) # # print(sql) #输出查询语句，用来测试 # cur.execute(sql) # conn.commit() # cur.close # conn.close() # def init_db(dbpath): # sql = \u0026#39;\u0026#39;\u0026#39; # create table movie250( # id integer primary key autoincrement, # info_link text, # pic_link text, # cname varchar, # ename varchar , # score numeric, # rated numeric, # instroduction text, # info text # ) # # # \u0026#39;\u0026#39;\u0026#39; #创建数据表 # conn = sqlite3.connect(dbpath) # cursor = conn.cursor() # cursor.execute(sql) # conn.commit() # conn.close() # 保存数据到数据库 if __name__ == \u0026#34;__main__\u0026#34;: # 当程序执行时 # 调用函数 main() # init_db(\u0026#34;movietest.db\u0026#34;) print(\u0026#34;爬取完毕！\u0026#34;) 下面我根据代码，从下到下给大家讲解分析一遍\n-- codeing = utf-8 --，开头的这个是设置编码为utf-8 ，写在开头，防止乱码。\n然后下面 import就是导入一些库，做做准备工作，（sqlite3这库我并没有用到所以我注释起来了）。\n下面一些find开头的是正则表达式，是用来我们筛选信息的。\n（正则表达式用到 re 库，也可以不用正则表达式，不是必须的。）\n大体流程分三步走：\n1. 爬取网页\n2.逐一解析数据\n3. 保存网页\n先分析流程1，爬取网页，baseurl 就是我们要爬虫的网页网址，往下走，调用了 getData（baseurl) ,\n我们来看 getData方法\nfor i in range(0, 10): # 调用获取页面信息的函数，10次 url = baseurl + str(i * 25) 这段大家可能看不懂，其实是这样的：\n因为电影评分Top250，每个页面只显示25个，所以我们需要访问页面10次，25*10=250。\n我们只要在baseurl后面加上数字就会跳到相应页面，比如i=1时\nhttps://movie.douban.com/top250?start=25\n我放上超链接，大家可以点击看看会跳到哪个页面，毕竟实践出真知。\n然后又调用了askURL来请求网页，这个方法是请求网页的主体方法，\n怕大家翻页麻烦，我再把代码复制一遍，让大家有个直观感受\ndef askURL(url): head = { # 模拟浏览器头部信息，向豆瓣服务器发送消息 def askURL(url): head = { # 模拟浏览器头部信息，向豆瓣服务器发送消息 \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla / 5.0(Windows NT 10.0; Win64; x64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 80.0.3987.122 Safari / 537.36\u0026#34; } # 用户代理，表示告诉豆瓣服务器，我们是什么类型的机器、浏览器（本质上是告诉浏览器，我们可以接收什么水平的文件内容） request = urllib.request.Request(url, headers=head) html = \u0026#34;\u0026#34; try: response = urllib.request.urlopen(request) html = response.read().decode(\u0026#34;utf-8\u0026#34;) except urllib.error.URLError as e: if hasattr(e, \u0026#34;code\u0026#34;): print(e.code) if hasattr(e, \u0026#34;reason\u0026#34;): print(e.reason) return html 这个askURL就是用来向网页发送请求用的，那么这里就有老铁问了，为什么这里要写个head呢？\n这是因为我们要是不写的话，访问某些网站的时候会被认出来爬虫，显示错误，错误代码\n418 这是一个梗大家可以百度下，\n418 I’m a teapot\nThe HTTP 418 I’m a teapot client error response code indicates that\nthe server refuses to brew coffee because it is a teapot. This error\nis a reference to Hyper Text Coffee Pot Control Protocol which was an\nApril Fools’ joke in 1998.\n我是一个茶壶\n所以我们需要 “装” ，装成我们就是一个浏览器，这样就不会被认出来，\n伪装一个身份。\n来，我们继续往下走，\nhtml = response.read().decode(\u0026#34;utf-8\u0026#34;) 这段就是我们读取网页的内容，设置编码为utf-8，目的就是为了防止乱码。\n访问成功后，来到了第二个流程：\n2.逐一解析数据\n解析数据这里我们用到了 BeautifulSoup（靓汤） 这个库，这个库是几乎是做爬虫必备的库，无论你是什么写法。\n下面就开始查找符合我们要求的数据，用BeautifulSoup的方法以及 re 库的\n正则表达式去匹配，\nfindLink = re.compile(r\u0026#39;\u0026lt;a href=\u0026#34;(.*?)\u0026#34;\u0026gt;\u0026#39;) # 创建正则表达式对象，标售规则 影片详情链接的规则 findImgSrc = re.compile(r\u0026#39;\u0026lt;img.*src=\u0026#34;(.*?)\u0026#34;\u0026#39;, re.S) findTitle = re.compile(r\u0026#39;\u0026lt;span class=\u0026#34;title\u0026#34;\u0026gt;(.*)\u0026lt;/span\u0026gt;\u0026#39;) findRating = re.compile(r\u0026#39;\u0026lt;span class=\u0026#34;rating_num\u0026#34; property=\u0026#34;v:average\u0026#34;\u0026gt;(.*)\u0026lt;/span\u0026gt;\u0026#39;) findJudge = re.compile(r\u0026#39;\u0026lt;span\u0026gt;(\\d*)人评价\u0026lt;/span\u0026gt;\u0026#39;) findInq = re.compile(r\u0026#39;\u0026lt;span class=\u0026#34;inq\u0026#34;\u0026gt;(.*)\u0026lt;/span\u0026gt;\u0026#39;) findBd = re.compile(r\u0026#39;\u0026lt;p class=\u0026#34;\u0026#34;\u0026gt;(.*?)\u0026lt;/p\u0026gt;\u0026#39;, re.S) 匹配到符合我们要求的数据，然后存进 dataList ， 所以 dataList 里就存放着我们需要的数据了。\n最后一个流程：\n3.保存数据\n# 3.保存数据 saveData(datalist,savepath) #2种存储方式可以只选择一种 # saveData2DB(datalist,dbpath) 保存数据可以选择保存到 xls 表， 需要（xlwt库支持）\n也可以选择保存数据到 sqlite数据库， 需要（sqlite3库支持）\n这里我选择保存到 xls 表 ，这也是为什么我注释了一大堆代码，注释的部分就是保存到 sqlite 数据库的代码，二者选一就行\n保存到 xls 的主体方法是 saveData （下面的saveData2DB方法是保存到sqlite数据库）：\ndef saveData(datalist,savepath): print(\u0026#34;save.......\u0026#34;) book = xlwt.Workbook(encoding=\u0026#34;utf-8\u0026#34;,style_compression=0) #创建workbook对象 sheet = book.add_sheet(\u0026#39;豆瓣电影Top250\u0026#39;, cell_overwrite_ok=True) #创建工作表 col = (\u0026#34;电影详情链接\u0026#34;,\u0026#34;图片链接\u0026#34;,\u0026#34;影片中文名\u0026#34;,\u0026#34;影片外国名\u0026#34;,\u0026#34;评分\u0026#34;,\u0026#34;评价数\u0026#34;,\u0026#34;概况\u0026#34;,\u0026#34;相关信息\u0026#34;) for i in range(0,8): sheet.write(0,i,col[i]) #列名 for i in range(0,250): # print(\u0026#34;第%d条\u0026#34; %(i+1)) #输出语句，用来测试 data = datalist[i] for j in range(0,8): sheet.write(i+1,j,data[j]) #数据 book.save(savepath) #保存 创建工作表，创列（会在当前目录下创建），\nsheet = book.add_sheet(\u0026#39;豆瓣电影Top250\u0026#39;, cell_overwrite_ok=True) #创建工作表 col = (\u0026#34;电影详情链接\u0026#34;,\u0026#34;图片链接\u0026#34;,\u0026#34;影片中文名\u0026#34;,\u0026#34;影片外国名\u0026#34;,\u0026#34;评分\u0026#34;,\u0026#34;评价数\u0026#34;,\u0026#34;概况\u0026#34;,\u0026#34;相关信息\u0026#34;) 然后把 dataList里的数据一条条存进去就行。\n最后运作成功后，会在左侧生成这么一个文件\n打开之后看看是不是我们想要的结果\n成了，成了！\n如果我们需要以数据库方式存储，可以先生成 xls 文件，再把 xls 文件导入数据库中，就可以啦\n本篇文章讲解到这里啦，我感觉我讲的还算细致吧，爬虫我也是最近才可以学，对这个比较有兴趣，我肯定有讲的不好的地方，欢迎各位大佬来指正我 。\n我也在不断的学习中，学到新东西第一时间会跟大家分享\n大家可以动动小手，点波关注不迷路。\n如果关于本篇文章有不懂的地方，欢迎大家下面留言，我知道的都会给大家一 一解答。\n白嫖不好，创作不易。各位的点赞就是我创作的最大动力，如果我有哪里写的不对，欢迎评论区留言进行指正。\n老铁，如果有收获，请点个免费的赞鼓励一下博主呗\n文章知识点与官方知识档案匹配，可进一步学习相关知识\nPython入门技能树网络爬虫urllib426623 人正在系统学习中\n本文转自 https://blog.csdn.net/ChenBinBini/article/details/109739116，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/python/python%E7%88%AC%E8%99%AB%E5%8F%B2%E4%B8%8A%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E8%80%81%E5%B9%B4%E4%BA%BA%E9%83%BD%E7%9C%8B%E7%9A%84%E6%87%82-csdn%E5%8D%9A%E5%AE%A2/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Python","url":"/tags/python/"},{"title":"爬虫","url":"/tags/%E7%88%AC%E8%99%AB/"}],"timestamp":1720150487,"title":"Python爬虫史上超详细讲解（零基础入门，老年人都看的懂）-CSDN博客"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":" vscode 直接搜索安装插件 markdownlint\n当在vscode中书写markdown文本时,不符合规范的内容就会有黄色波浪线来提示及时修正。\nMD001 - Heading levels should only increment by one level at a time 标题级数只能每次扩大一个，也就是说不能隔级创建标题，必须h1-h2-h3…这样\nMD002 - First heading should be a top level heading 文档的第一个标题必须是最高级的标题，也就是h1\nMD003 - Heading style 整篇文档的标题格式要统一\nMD004 - Unordered list style\n整篇文档的无序列表的格式要一致\nMD005 - Inconsistent indentation for list items at the same level\n同一个等级的列表的缩进要一致\nMD006 - Consider starting bulleted lists at the beginning of the line\n一级标题不能够缩进\nMD007 - Unordered list indentation\n无序列表嵌套的时候默认采取两个空格的缩进方式\nMD009 - Trailing spaces\n行尾最多可以添加两个空格，超出之后会有警告，最好每次都是两个空格因为两个空格刚好可以用来换行\nMD010 - Hard tabs\n不能使用tab来进行缩进，要使用空格\nMD011 - Reversed link syntax\n内联形式的链接和创建方式是否错误，中括号和圆括号是否使用正确\nMD012 - Multiple consecutive blank lines\n文档中不能有连续的空行（文档末可以有一个空行），在代码块中这个规则不会生效\nMD013 - Line length\n默认行的最大长度是80，对表格代码块标题都起效果\nMD014 - Dollar signs used before commands without showing output\n在代码块中，终端命令前面不需要有美元符号，如果如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号($)\nMD018 - No space after hash on atx style heading\n标题格式如果是\u0026quot;atx\u0026quot;的话，#号和文字之间需要一个空格隔开\nMD019 - Multiple spaces after hash on atx style heading\n标题格式如果是\u0026quot;atx\u0026quot;的话，#号和文字之间只需要一个空格隔开，不需要多个\nMD020 - No space inside hashes on closed atx style heading\n在closed_atx格式的标题中，文字和前后的#号之间都需要一个空格隔开\nMD021 - Multiple spaces inside hashes on closed atx style heading\n在closed_atx格式的标题中，文字和前后的#号之间只需要一个空格隔开，不能有多余的\nMD022 - Headings should be surrounded by blank lines\n标题的上下行必须都是空格\nMD023 - Headings must start at the beginning of the line\n标题行不能缩进\nMD024 - Multiple headings with the same content\n在文档中不能有重复性的标题\nMD025 - Multiple top level headings in the same document\n同一个文档中，只能有一个最高级的标题，默认也只能有一个一级标题\nMD026 - Trailing punctuation in heading\n标题的末尾不能有\u0026quot;. , ; : ! ? \u0026ldquo;这些符号\nMD027 - Multiple spaces after blockquote symbol\n在创建引用块的时候，右尖号与文字之间必须有且只有一个空格\nMD028 - Blank line inside blockquote\n两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用\u0026gt;开头\nMD029 - Ordered list item prefix\n有序列表的前缀序号格式必须只用1或者从1开始的加1递增数字\nMD030 - Spaces after list markers\n列表（有序、无序）的前缀符号和文字之间用1个空格隔开，在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进3个空格\nMD031 - Fenced code blocks should be surrounded by blank lines\n单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块\nMD032 - Lists should be surrounded by blank lines\n列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表，列表的缩进必须一致，否则会警告\nMD033 - Inline HTML\n文档中不允许使用html语句\nMD034 - Bare URL used\n单纯的链接地址需要用尖括号 (\u0026lt;\u0026gt;) 包裹，否则有些解释器不会解释为链接\nMD035 - Horizontal rule style\n创建水平线时整篇文档要统一，要和文档中第一次创建水平线使用的符号一致\nMD036 - Emphasis used instead of a heading\n不能用强调来代替标题 ****\nMD037 - Spaces inside emphasis markers\n强调的符号和文字之间不能有空格\nMD038 - Spaces inside code span elements\n当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格，如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开\nMD039 - Spaces inside link text\n链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格\nMD040 - Fenced code blocks should have a language specified\n单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮\nMD041 - First line in file should be a top level heading\n文档的第一个非空行应该是文档最高级的标题，默认是1级标题\nMD042 - No empty links\n链接的地址不能为空\nMD043 - Required heading structure\n要求标题遵循一定的结构，默认是没有规定的结构\nMD044 - Proper names should have the correct capitalization\n指定一些名称，会检查它是否有正确的大写\nMD045 - Images should have alternate text (alt text)\n图片链接必须包含描述文本\nMD046 - Code block style\n整篇文档采用一致的代码格式\nMD047 - Files should end with a single newline character\n文档末尾需要一个空行结尾\n原文地址 文章知识点与官方知识档案匹配，可进一步学习相关知识\nCS入门技能树MarkDown入门MarkDown介绍41790 人正在系统学习中\n本文转自 https://blog.csdn.net/qq_43307934/article/details/108023805，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/markdown/vs-code-markdown%E6%8A%A5%E9%94%99%E8%87%AA%E6%9F%A5/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Markdown","url":"/tags/markdown/"}],"timestamp":1720150487,"title":"VS Code Markdown报错自查"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":" 文章目录 驼峰命令法(Camel) 匈牙利命名法(Hungarian) 帕斯卡（Pascal）命名法 命名的基本原则 变量名的命名规则 函数的命名规范 函数参数命名规范 三种流行的命名法则\n目前，业界共有四种命名法则：驼峰命名法、匈牙利命名法、帕斯卡命名法和下划线命名法，其中前三种是较为流行的命名法。\n驼峰命令法(Camel) 也称骆驼式命名法正如它的名称所表示的那样，是指混合使用大小写字母来构成变量和函数的名字例如，下面是分别用骆驼式命名法和下划线法命名的同一个函数：\nprintEmployeePaychecks()； print_employee_paychecks()； 第一个函数名使用了骆驼式命名法，函数名中的每一个逻辑断点都有一个大写字母来标记；第二个函数名使用了下划线法，函数名中的每一个逻辑断点都有一个下划线来标记\n骆驼式命名法近年来越来越流行了，在许多新的函数库和Microsoft Windows这样的环境中，它使用得当相多另一方面，下划线法是c出现后开始流行起来的，在许多旧的程序和UNIX这样的环境中，它的使用非常普遍\n驼峰式命名法分为大驼峰式命名规则：FirstName, CamelCase\n小驼峰式命名规则：firstName, camelCase\n[中间不需要空格 - _等分割符]\n匈牙利命名法(Hungarian) 广泛应用于象Microsoft Windows这样的环境中Windows 编程中用到的变量（还包括宏）的命名规则匈牙利命名法，这种命名技术是由一位能干的 Microsoft 程序员查尔斯- 西蒙尼(Charles Simonyi) 提出的\n匈牙利命名法通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域，类型等这些符号可以多个同时使用，顺序是先m_（成员变量）， 再指针，再简单数据类型，再其它\n例如：m_lpszStr, 表示指向一个以0字符结尾的字符串的长指针成员变量\n匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途\n匈牙利命名法的规则是：\n属性+类型+描述\n属性一般是小写字母+:\ng:全局变量\nm_:类成员变量\ns_:静态变量\nc_:常量\n类型就多了：\nb:bool\nsz:以零结束的字符串\np:指针\nn:整整\ndw:双字\nl:长整型\n无符号:u\n函数:fn\n匈牙利命名法分为系统和应用两种。系统着眼于类型。应用着眼于语义，比如col表示行，c表示计数。\n帕斯卡（Pascal）命名法 与骆驼命名法类似只不过骆驼命名法是首字母小写，而帕斯卡命名法是首字母大写，如：\nDisplayInfo(); string UserName; pascal命名规则：大驼峰式命名规则\n命名的基本原则 (1)标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解——尽量采用采用英文单词或全部中文全拼表示，若出现英文单词和中文混合定义时，使用连字符“_”将英文与中文割开。较短的单词可通过去掉“元音”形成缩写；较长的单词可取单词的头几个字母形成缩写；一些单词有大家公认的缩写。例如：temp-\u0026gt;tmp、flag-\u0026gt;标志寄存器、statistic-\u0026gt;stat、increment-\u0026gt;inc、message-\u0026gt;msg等缩写能够被大家基本认可。\n(2)命名中若使用特殊约定或缩写，则要有注释说明。应该在源文件的开始之处，对文件中所使用的缩写或约定，特别是特殊的缩写，进行必要的注释说明。\n(3)自己特有的命名风格，要自始至终保持一致，不可来回变化。个人的命名风格，在符合所在项目组或产品组的命名规则的前提下，才可使用。(即命名规则中没有规定到的地方才可有个人命名风格)。\n(4)对于变量命名，禁止取单个字符(如i 、j 、k… )，建议除了要有具体含义外，还能表明其变量类型、数据类型等，但i 、j 、k 作局部循环变量是允许的。变量，尤其是局部变量，如果用单个字符表示，很容易敲错(如i写成j)，而编译时又检查不出来，有可能为了这个小小的错误而花费大量的查错时间。\n(5)除非必要，不要用数字或较奇怪的字符来定义标识符。\n(6)命名规范必须与所使用的系统风格保持一致，并在同一项目中统一。\n(7)在同一软件产品内，应规划好接口部分标识符(变量、结构、函数及常量)的命名，防止编译、链接时产生冲突。对接口部分的标识符应该有更严格限制，防止冲突。如可规定接口部分的变量与常量之前加上“模块”标识等。\n(8)用正确的反义词组命名具有互斥意义的变量或相**作的函数等。\n下面是一些在软件中常用的反义词组:\nadd / remove begin / end create / destroy\ninsert / delete first / last g et / release\nincrement / decrement put / get\nadd / delete lock / unlock open / close\nmin / max old / new start / stop\nnext / previous source / target show / hide\nsend / receive source / destination\ncut / paste up / down\n示例：\nintmin_sum;\nintmax_sum;\nintadd_user( BYTE *user_name );\nintdelete_user( BYTE *user_name );\n(9)除了编译开关/ 头文件等特殊应用，应避免使用_EXAMPLE_TEST_ 之类以下划线开始和结尾的定义。\n变量名的命名规则 (1)变量的命名规则要求用“匈牙利法则”。\n即开头字母用变量的类型，其余部分用变量的英文意思、英文的缩写、中文全拼或中文全拼的缩写,要求单词的第一个字母应大写。\n即： 变量名=变量类型+变量的英文意思(或英文缩写、中文全拼、中文全拼缩写)\n对非通用的变量，在定义时加入注释说明，变量定义尽量可能放在函数的开始处。\n见下表：\n类型 首字母 例子 bool 用b开头 b标志寄存器 int 用i开头 iCount short int 用n开头 nStepCount long int 用l开头 lSum char 用c开头 cCount unsigned char 用by开头 float 用f开头 fAvg double 用d开头 dDeta unsigned int(WORD) 用w开头 wCount unsigned long int(DWORD) 用dw开头 dwBroad 字符串 用s开头 sFileName 用0结尾的字符串 用sz开头 szFileName (2)指针变量命名的基本原则为：\n对一重指针变量的基本原则为：“p”+变量类型前缀+命名，如一个float*型应该表示为pfStat。对二重指针变量的基本规则为：“pp”+变量类型前缀+命名。对三重指针变量的基本规则为：“ppp”+变量类型前缀+命名。\n(3)全局变量用g_开头,如一个全局的长型变量定义为g_lFailCount。即：变量名=g_+变量类型+变量的英文意思(或缩写)。此规则还可避免局部变量和全局变量同名而引起的问题。\n(4)静态变量用s_开头,如一个静态的指针变量定义为s_plPerv_Inst。即： 变量名=s_+变量类型+变量的英文意思(或缩写)\n(5)对枚举类型(enum)中的变量，要求用枚举变量或其缩写做前缀。并且要求用大写。如：\nenum cmEMDAYS { EMDAYS_MONDAY; EMDAYS_TUESDAY; …… }; (6)对struct、union变量的命名要求定义的类型用大写。并要加上前缀，其内部变量的命名规则与变量命名规则一致。\n结构一般用S开头，如：\nstruct ScmNPoint { int nX;//点的X位置 int nY; //点的Y位置 }; 联合体一般用U开头，如:\nunion UcmLPoint { LONG lX; LONG lY; } (7)对常量(包括错误的编码)命名，要求常量名用大写，常量名用英文表达其意思。当需要由多个单词表示时，单词与单词之间必须采用连字符“_”连接。\n如：#define CM_FILE_NOT_FOUND CMMAKEHR(0X20B) 其中CM表示类别。\n(8)对const 的变量要求在变量的命名规则前加入c_。即：c_+变量命名规则；示例：const char* c_szFileName;\n函数的命名规范 (1)函数的命名应该尽量用英文(或英文缩写、中文全拼、中文全拼缩写)表达出函数完成的功能——函数名应准确描述函数的功能。遵循动宾结构的命名法则，函数名中动词在前,并在命名前加入函数的前缀，函数名的长度不得少于8个字母。函数名首字大写，若包含有两个单词的每个单词首字母大写。如果是OOP 方法，可以只有动词(名词是对象本身)。示例：\nLONG GetDeviceCount(……); void print_record( unsigned int rec_ind ) ; intinput_record( void ) ; unsigned char get_current_color( void ) ; (2)避免使用无意义或含义不清的动词为函数命名。如使用process、handle等为函数命名，因为这些动词并没有说明要具体做什么。\n(3)必须使用函数原型声明。函数原型声明包括：引用外来函数及内部函数，外部引用必须在右侧注明函数来源： 模块名及文件名；内部函数，只要注释其定义文件名——和调用者在同一文件中(简单程序)时不需要注释。\n应确保每个函数声明中的参数的名称、类型和定义中的名称、类型一致。\n函数参数命名规范 (1)参数名称的命名参照变量命名规范。\n(2)为了提高程序的运行效率，减少参数占用的堆栈，传递大结构的参数，一律采用指针或引用方式传递。\n(3)为了便于其他程序员识别某个指针参数是入口参数还是出口参数，同时便于编译器检查错误，应该在入口参数前加入const标志。\n如：……cmCopyString(const CHAR * c_szSource, CHAR * szDest)\n文件名(包括动态库、组件、控件、工程文件等)的命名规范文件名的命名要求表达出文件的内容，要求文件名的长度不得少于5个字母，严禁使用象file1,myfile之类的文件名。\n[转][三种编程命名规则：驼峰命名法，帕斯卡命名法，匈牙利命名法](https://www.cnblogs.com/Offie/p/5021368.html)\n本文转自 https://blog.csdn.net/weixin_43758823/article/details/84888470，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/java/%E4%B8%89%E7%A7%8D%E7%BC%96%E7%A8%8B%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E6%B3%95%E5%B8%95%E6%96%AF%E5%8D%A1%E5%91%BD%E5%90%8D%E6%B3%95%E5%8C%88%E7%89%99%E5%88%A9%E5%91%BD%E5%90%8D%E6%B3%95/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Java","url":"/tags/java/"}],"timestamp":1720150487,"title":"三种编程命名规则：驼峰命名法，帕斯卡命名法，匈牙利命名法"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":"废话少说，直接开始学习！\n一、元字符 元字符是构造正则表达式的一种基本元素。\n. ：匹配除换行符以外的任意字符\nw：匹配字母或数字或下划线或汉字\ns：匹配任意的空白符\nd：匹配数字\nb：匹配单词的开始或结束\n^：匹配字符串的开始\n$：匹配字符串的结束\n匹配有abc开头的字符串：abc或者^abc 匹配8位数字的QQ号码：^dddddddd$ 匹配1开头11位数字的手机号码：^1dddddddddd$ 二、重复限定符 正则没提供办法处理这些重复的元字符吗？答案肯定是有的。\n*：重复零次或更多次\n+：重复一次或更多次\n?：重复零次或一次\n{n}：重复n次\n{n,}：重复n次或更多次\n{n,m}：重复n到m次\n有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：\n匹配8位数字的QQ号码：^d{8}$ 匹配1开头11位数字的手机号码：^1d{10}$ 匹配银行卡号是14~18位的数字：^d{14,18}$ 匹配以a开头的，0个或多个b结尾的字符串^ab*$ 三、分组（） 限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要ab同时被限定那怎么办呢？\n正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。\n因此当我们要匹配多个ab时，我们可以这样。\n如匹配字符串中包含0到多个ab开头：^(ab)* 四、转义 正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\\即可。\n匹配字符串中包含0到多个ab开头：^(\\(ab\\))* 五、条件或 | 回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有130/131/132/155/156/185/186/145/176等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？\n正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。\n那么我们就可以用或条件来处理这个问题\n^(130|131|132|155|156|185|186|145|176)\\d{8}$ 六、区间\\[ \\] 看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？\n实际是有的\n正则提供一个元字符中括号 [] 来表示区间条件。\n限定0到9 可以写成[0-9]\n限定A-Z 写成[A-Z]\n限定某些数字 [165]\n那上面的正则我们还改成这样：\n^((13[0-2])|(15[56])|(18[5-6])|145|176)\\d{8}$ 七、正则进阶之零宽断言 断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，\n意思正则也可以像人类那样断定什么什么，比如\u0026quot;ss1aa2bb3\u0026quot;,正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.\n零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。\n我们来举个栗子：\n假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构\n\u0026#34;\u0026lt;span class=\u0026#34;read-count\u0026#34;\u0026gt;阅读数：641\u0026lt;/span\u0026gt;\u0026#34; 其中也就‘641’这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？下面先来讲几种类型的断言：\n正向先行断言（正前瞻）： 语法：（?=pattern）\n作用：匹配pattern表达式的前面内容，不返回本身。\n这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到‘’前面的数字内容\n按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=) 就可以匹配到前面的内容了。\n匹配什么内容呢？如果要所有内容那就是：\nString reg=\u0026#34;.+(?=\u0026lt;/span\u0026gt;)\u0026#34;; String test = \u0026#34;\u0026lt;span class=\\\u0026#34;read-count\\\u0026#34;\u0026gt;阅读数：641\u0026lt;/span\u0026gt;\u0026#34;; Pattern pattern = Pattern.compile(reg); Matcher mc= pattern.matcher(test); while(mc.find()){ System.out.println(\u0026#34;匹配结果：\u0026#34;) System.out.println(mc.group()); } //匹配结果：//\u0026lt;span class=\u0026#34;read-count\u0026#34;\u0026gt;阅读数：641 可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \\d,那可以改成：\nString reg=\u0026#34;\\\\d+(?=\u0026lt;/span\u0026gt;)\u0026#34;;String test = \u0026#34;\u0026lt;span class=\\\u0026#34;read-count\\\u0026#34;\u0026gt;阅读数：641\u0026lt;/span\u0026gt;\u0026#34;;Pattern pattern = Pattern.compile(reg);Matcher mc= pattern.matcher(test);while(mc.find()){ System.out.println(mc.group());} //匹配结果：//641 大功告成！\n正向后行断言（正后顾）: 语法：（?\u0026lt;=pattern）\n作用：匹配pattern表达式的后面的内容，不返回本身。\n有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。\n上面的栗子，我们也可以用后行断言来处理.\n//(?\u0026lt;=\u0026lt;span class=\u0026#34;read-count\u0026#34;\u0026gt;阅读数：)\\d+ String reg=\u0026#34;(?\u0026lt;=\u0026lt;span class=\\\u0026#34;read-count\\\u0026#34;\u0026gt;阅读数：)\\\\d+\u0026#34;; String test = \u0026#34;\u0026lt;span class=\\\u0026#34;read-count\\\u0026#34;\u0026gt;阅读数：641\u0026lt;/span\u0026gt;\u0026#34;; Pattern pattern = Pattern.compile(reg); Matcher mc= pattern.matcher(test); while(mc.find()){ System.out.println(mc.group()); } //匹配结果：//641 就这么简单。\n负向先行断言（负前瞻） 语法：(?!pattern)\n作用：匹配非pattern表达式的前面内容，不返回本身。\n有正向也有负向，负向在这里其实就是非的意思。\n举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”\n现在要找到不是\u0026rsquo;的花朵\u0026rsquo;前面的祖国\n用正则就可以这样写：\n祖国(?!的花朵) 负向后行断言（负后顾） 语法：(?\u0026lt;!pattern)\n作用：匹配非pattern表达式的后面内容，不返回本身。\n八、正则进阶之捕获和非捕获 单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”\n捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。\n而根据命名方式的不同，又可以分为两种组：\n数字编号捕获组：\n语法：(exp)\n解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。\n比如固定电话的：020-85653333\n正则表达式为：(0\\d{2})-(\\d{8})\n按照左括号的顺序，这个表达式有如下分组： 序号 编号 分组 内容 0 0 (0\\d{2})-(\\d{8}) 020-85653333 1 1 (0\\d{2}) 020 2 2 (\\d{8}) 85653333 我们用Java来验证一下：\nString test = \u0026#34;020-85653333\u0026#34;; String reg=\u0026#34;(0\\\\d{2})-(\\\\d{8})\u0026#34;; Pattern pattern = Pattern.compile(reg); Matcher mc= pattern.matcher(test); if(mc.find()){ System.out.println(\u0026#34;分组的个数有：\u0026#34;+mc.groupCount()); for(int i=0;i\u0026lt;=mc.groupCount();i++){ System.out.println(\u0026#34;第\u0026#34;+i+\u0026#34;个分组为：\u0026#34;+mc.group(i)); } } 输出结果：\n分组的个数有：2第0个分组为：020-85653333第1个分组为：020第2个分组为：85653333 可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。\n命名编号捕获组：\n语法：(?exp)\n解释：分组的命名由表达式中的name指定\n比如区号也可以这样写:(?\\0\\d{2})-(?\\d{8})\n按照左括号的顺序，这个表达式有如下分组：\n序号 名称 分组 内容 0 0 (0\\d{2})-(\\d{8}) 020-85653333 1 quhao (0\\d{2}) 020 2 haoma (\\d{8}) 85653333 用代码来验证一下：\n1String test = \u0026#34;020-85653333\u0026#34;;2 String reg=\u0026#34;(?\u0026lt;quhao\u0026gt;0\\\\d{2})-(?\u0026lt;haoma\u0026gt;\\\\d{8})\u0026#34;;3 Pattern pattern = Pattern.compile(reg);4 Matcher mc= pattern.matcher(test);5 if(mc.find()){6 System.out.println(\u0026#34;分组的个数有：\u0026#34;+mc.groupCount());7 System.out.println(mc.group(\u0026#34;quhao\u0026#34;));8 System.out.println(mc.group(\u0026#34;haoma\u0026#34;));9 } 输出结果：\n分组的个数有：2分组名称为:quhao,匹配内容为：020分组名称为:haoma,匹配内容为：85653333 非捕获组：\n语法：(?:exp)\n解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。 比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：\n(?:\\0\\d{2})-(\\d{8}) 序号 编号 分组 内容 0 0 (0\\d{2})-(\\d{8}) 020-85653333 1 1 (\\d{8}) 85653333 验证一下：\nString test = \u0026#34;020-85653333\u0026#34;; String reg=\u0026#34;(?:0\\\\d{2})-(\\\\d{8})\u0026#34;; Pattern pattern = Pattern.compile(reg); Matcher mc= pattern.matcher(test); if(mc.find()){ System.out.println(\u0026#34;分组的个数有：\u0026#34;+mc.groupCount()); for(int i=0;i\u0026lt;=mc.groupCount();i++){ System.out.println(\u0026#34;第\u0026#34;+i+\u0026#34;个分组为：\u0026#34;+mc.group(i)); } } 输出结果：\n分组的个数有：1第0个分组为：020-85653333第1个分组为：85653333 九、正则进阶之反向引用 上面讲到捕获，我们知道：捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。\n根据捕获组的命名规则，反向引用可分为：\n数字编号组反向引用：\\k\n或\\number\n命名编号组反向引用：\\k\n或者\\\u0026rsquo;name'\n好了 讲完了，懂吗？不懂！！！\n可能连前面讲的捕获有什么用都还不懂吧？\n其实只是看完捕获不懂不会用是很正常的！\n因为捕获组通常是和反向引用一起使用的\n上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用\n注意两个字眼：“内容” 和 “使用”\n这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住\n那这里所说的“使用”是怎样使用呢？\n因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。\n还是举栗子吧：\n比如要查找一串字母\u0026quot;aabbbbgbddesddfiid\u0026quot;里成对的字母\n如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，\n现在我们先用程序思维理一下思路：\n1）匹配到一个字母\n2）匹配第下一个字母，检查是否和上一个字母是否一样\n3）如果一样，则匹配成功，否则失败\n这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？\n这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件\n好了，有思路就要实践\n首先匹配一个字母：\\w\n我们需要做成分组才能捕获，因此写成这样：(\\w)\n那这个表达式就有一个捕获组：（\\w）\n然后我们要用这个捕获组作为条件，那就可以：(\\w)\\1\n这样就大功告成了\n可能有人不明白了，\\1是什么意思呢？\n还记得捕获组有两种命名方式吗，一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名\n在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的\n因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \\k\u0026lt;1\u0026gt;或者\\1\n当然，通常都是是后者。\n我们来测试一下：\nString test = \u0026#34;aabbbbgbddesddfiid\u0026#34;; Pattern pattern = Pattern.compile(\u0026#34;(\\\\w)\\\\1\u0026#34;); Matcher mc= pattern.matcher(test); while(mc.find()){ System.out.println(mc.group()); } 输出结果：\naabbbbddddii 嗯，这就是我们想要的了。\n在举个替换的例子，假如想要把字符串中abc换成a\nString test = \u0026#34;abcbbabcbcgbddesddfiid\u0026#34;;String reg=\u0026#34;(a)(b)c\u0026#34;;System.out.println(test.replaceAll(reg, \u0026#34;$1\u0026#34;));; 输出结果：\nabbabcgbddesddfiid 十、正则进阶之贪婪和非贪婪 1、贪婪\n我们都知道，贪婪就是不满足，尽可能多的要。\n在正则中，贪婪也是差不多的意思:\n贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。\n特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。\n前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：\n\\d{3,6} 用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。\n如\nString reg=\u0026#34;\\\\d{3,6}\u0026#34;;String test=\u0026#34;61762828 176 2991 871\u0026#34;;System.out.println(\u0026#34;文本：\u0026#34;+test);System.out.println(\u0026#34;贪婪模式：\u0026#34;+reg);Pattern p1 =Pattern.compile(reg);Matcher m1 = p1.matcher(test); while(m1.find()){ System.out.println(\u0026#34;匹配结果：\u0026#34;+m1.group(0)); } 输出结果：\n文本：61762828 176 2991 44 871贪婪模式：\\d{3,6}匹配结果：617628匹配结果：176匹配结果：2991匹配结果：871 由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。\n一个量词就如此贪婪了，\n那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？\n是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。\nString reg=\u0026#34;(\\\\d{1,2})(\\\\d{3,4})\u0026#34;;String test=\u0026#34;61762828 176 2991 87321\u0026#34;;System.out.println(\u0026#34;文本：\u0026#34;+test);System.out.println(\u0026#34;贪婪模式：\u0026#34;+reg);Pattern p1 =Pattern.compile(reg);Matcher m1 = p1.matcher(test); while(m1.find()){ System.out.println(\u0026#34;匹配结果：\u0026#34;+m1.group(0)); } 输出结果：\n文本：61762828 176 2991 87321贪婪模式：(\\d{1,2})(\\d{3,4})匹配结果：617628匹配结果：2991匹配结果：87321 “617628” 是前面的\\d{1,2}匹配出了61，后面的匹配出了7628\n\u0026ldquo;2991\u0026rdquo; 是前面的\\d{1,2}匹配出了2 ，后面的匹配出了991\n\u0026ldquo;87321\u0026quot;是前面的\\d{1,2}匹配出了87，后面的匹配出了321\n再来一个例子\nimport java.util.regex.*;class Untitled {\tpublic static void main(String[] args) {\tString reg=\u0026#34;(\\\\d{1,2})(\\\\d{2,4})(\\\\d{1,2})\u0026#34;;\tString test=\u0026#34;61762828 176 2991 871\u0026#34;;\tSystem.out.println(\u0026#34;文本：\u0026#34;+test);\tSystem.out.println(\u0026#34;贪婪模式：\u0026#34;+reg);\tPattern p1 =Pattern.compile(reg);\tMatcher m1 = p1.matcher(test);\twhile(m1.find()){\tSystem.out.println(\u0026#34;匹配结果：\u0026#34;+m1.group(0));\t}\t}} 输出结果：\n文本：61762828 176 2991 871贪婪模式：(\\d{1,2})(\\d{2,4})(\\d{1,2})匹配结果：61762828匹配结果：2991 “61762828” 是前面的\\d{1,2}匹配出了61，后面\\d{2,4}匹配出了7628，后面\\d{1,2}匹配出了28\n\u0026ldquo;2991\u0026rdquo; 是前面的\\d{1,2}匹配出了2 ，后面\\d{2,4}匹配出了99，后面\\d{1,2}匹配出了1\n从执行结果来看，贪婪不是严格从左到右匹配，不然2991就匹配不出来了，而是会丢弃一些字符尽可能的匹配到字符。\n2、懒惰（非贪婪）\n懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。\n特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。\n懒惰量词是在贪婪量词后面加个“？”\n代码 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 String reg=\u0026#34;(\\\\d{1,2}?)(\\\\d{3,4})\u0026#34;; String test=\u0026#34;61762828 176 2991 87321\u0026#34;; System.out.println(\u0026#34;文本：\u0026#34;+test); System.out.println(\u0026#34;贪婪模式：\u0026#34;+reg); Pattern p1 =Pattern.compile(reg); Matcher m1 = p1.matcher(test); while(m1.find()){ System.out.println(\u0026#34;匹配结果：\u0026#34;+m1.group(0)); } 输出结果：\n文本：61762828 176 2991 87321贪婪模式：(\\d{1,2}?)(\\d{3,4})匹配结果：61762匹配结果：2991匹配结果：87321 解答：\n“61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762\n\u0026ldquo;2991\u0026rdquo; 是左边的懒惰匹配出2，右边的贪婪匹配出991\n\u0026ldquo;87321\u0026rdquo; 左边的懒惰匹配出8，右边的贪婪匹配出7321\n十一、正则进阶之反义 前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：\n元字符 解释 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 十二、正则表达式匹配网站 http://tool.chinaz.com/regex\n十三、附录，常用正则表达式 一、校验数字的表达式 1 数字：^[0-9]*$ 2 n位的数字：^\\d{n}$ 3 至少n位的数字：^\\d{n,}$ 4 m-n位的数字：^\\d{m,n}$ 5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 8 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 12 非零的负整数：^\\-[1-9][]0-9*$ 或 ^-[1-9]\\d*$ 13 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 16 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 17 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 18 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 19 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3 长度为3-20的所有字符：^.{3,20}$ 4 由26个英文字母组成的字符串：^[A-Za-z]+$ 5 由26个大写英文字母组成的字符串：^[A-Z]+$ 6 由26个小写英文字母组成的字符串：^[a-z]+$ 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11 可以输入含有^%\u0026amp;\u0026#39;,;=?$\\\u0026#34;等字符：[^%\u0026amp;\u0026#39;,;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 1 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3 InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026amp;=]*)?$ 4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5 电话号码(\u0026#34;XXX-XXXXXXX\u0026#34;、\u0026#34;XXXX-XXXXXXXX\u0026#34;、\u0026#34;XXX-XXXXXXX\u0026#34;、\u0026#34;XXX-XXXXXXXX\u0026#34;、\u0026#34;XXXXXXX\u0026#34;和\u0026#34;XXXXXXXX\u0026#34;)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 12 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 15 钱的输入格式： 16 1).有四种钱的表示形式我们可以接受:\u0026#34;10000.00\u0026#34; 和 \u0026#34;10,000.00\u0026#34;, 和没有 \u0026#34;分\u0026#34; 的 \u0026#34;10000\u0026#34; 和 \u0026#34;10,000\u0026#34;：^[1-9][0-9]*$ 17 2).这表示任意一个不以0开头的数字,但是,这也意味着一个字符\u0026#34;0\u0026#34;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 18 3).一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 19 4).这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 20 5).必须说明的是,小数点后面至少应该有1位数,所以\u0026#34;10.\u0026#34;是不通过的,但是 \u0026#34;10\u0026#34; 和 \u0026#34;10.2\u0026#34; 是通过的：^[0-9]+(.[0-9]{2})?$ 21 6).这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 22 7).这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 23 8). 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 24 备注：这就是最终结果了,别忘了\u0026#34;+\u0026#34;可以用\u0026#34;*\u0026#34;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 26 中文字符的正则表达式：[\\u4e00-\\u9fa5] 27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 29 HTML标记的正则表达式：\u0026lt;(\\S*?)[^\u0026gt;]*\u0026gt;.*?\u0026lt;/\\1\u0026gt;|\u0026lt;.*? /\u0026gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 30 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 33 IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用) 34 IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 好了，正则表达式的基本用法就讲到这里了，其实它还有非常多的知识点以及元字符，我们在此只列举了部分元字符和语法来讲，旨在给那些不懂正则或者想学正则但有看不下去文档的人做一个快速入门级的教程，看完本教程，即使你不能写出高大上的正则，至少也能写一些简单的正则或者看得懂别人写的正则了。\n—————————————\n文章来源：公众号码农沉思录、数据库开发、Java基基\n本文转自 https://blog.csdn.net/William0318/article/details/102775217，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/python/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E6%96%87%E6%9C%AB%E9%99%84%E5%B8%B8%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Python","url":"/tags/python/"},{"title":"正则表达式","url":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"timestamp":1720150487,"title":"史上最全正则表达式语法，文末附常用表达式！"},{"authors":[{"title":"CSDN_user","url":"/authors/csdn_user/"}],"categories":[],"content":" 文章目录 一、pyAutoGUI 概括 二、pyAutoGUI 库安装 三、pyAutoGUI 操作前置知识 1.屏幕分辨率与尺寸 2.暂停操作 3.故障保护功能 四、鼠标操作 1.鼠标移动操作 2.获取鼠标位置的坐标值 3.鼠标拖拽操作 4.鼠标点击操作 5.鼠标单击分布操作 五、键盘操作 1.输入字符 2.按键操作 3.热键操作（组合键） 六，消息框 1.可以设置一个button 2.可以设置多个button 3.自带文本输入框的消息框 4.自带密码的文本输入框的消息框 七、屏幕截图 1.截全屏 2.指定区域内截屏 3.图片定位 这篇博客主要介绍了如何使用Python库pyAutoGUI进行计算机自动化行为操作。文章首先介绍了pyAutoGUI库的概括和安装方法。接下来，详细讲解了操作前需要了解的屏幕分辨率与尺寸，暂停操作，以及故障保护功能的使用方法。在鼠标操作部分，详细解析了鼠标的移动、获取位置、拖拽、点击以及单击分布操作。键盘操作部分，讨论了如何进行输入字符、按键以及热键操作。此外，文章还提到了使用消息框显示信息，可设置一个或多个按钮，及带有文本输入框和密码输入框的消息框使用方法。最后，文章详述了如何进行屏幕截图并在指定区域内截屏，以及图片定位的方法。整篇文章旨在帮助读者理解和掌握使用pyAutoGUI库进行计算机自动化操作的方法。\n一、pyAutoGUI 概括 pyAutoGUI是一个用于自动化计算机行为的Python库。它可以用来操作鼠标和键盘，模拟人类的输入方式，比如移动鼠标、点击按钮、输入文本等。pyAutoGUI还可以用来开发自动化工具，比如自动回复聊天机器人、自动游戏挂机等。\n二、pyAutoGUI 库安装 pyAutoGUI的下载代码如下：\n打开命令行窗口输入以下代码即可\npip install pyautogui 或者，你可以直接从PyCharm上下载，教程如下：Python基础第八篇（Python异常处理，模块与包）\n三、pyAutoGUI 操作前置知识 1.屏幕分辨率与尺寸 为方便编写代码，pyautogui 接口用起了别名“pg”\nimport pyautogui as pg import time # 获取屏幕尺寸 # 元组类型的返回值 screen_width, screen_height = pg.size() # 获取屏幕宽高 print(\u0026#34;屏幕宽度:\u0026#34;, screen_width) print(\u0026#34;屏幕高度:\u0026#34;, screen_height) 2.暂停操作 #暂停操作，全局暂停，局部暂停 #全局暂停是指在程序中暂停所有操作（进行一行改代码，停一次，一般写在接口下面先执行），局部暂停是指在程序中暂停某个操作 #--------全局暂停-------- #默认是0.1 浮点型 单位是秒 pg.PAUSE = 1.0 #--------局部暂停-------- #默认是0 浮点型 单位是秒 time.sleep(2) 3.故障保护功能 pyAutoGUI 有一个名为“故障保护”的功能，当鼠标或键盘操作失败时，这个功能可以防止程序崩溃。要启用故障保护功能，可以在使用pyAutoGUI之前导入pyautogui.PAUSE：\n插入\nimport pyautogui as pg pg.PAUSE = 1 这样，当pyAutoGUI遇到错误时，它会等待1秒后再尝试执行操作。你可以根据需要调整PAUSE的值。\n或者在pyAutoGUI程序执行过程中想要停止，可以快速将鼠标移动到屏幕的四个角以中止程序，默认存在的。不想用可在pyAutoGUI代码执行之前插入\npg.failsafe=false 四、鼠标操作 1.鼠标移动操作 #移动鼠标到指定位置 #duration是指所用时间，默认是0.25 浮点型 单位是秒 pg.moveTo(100, 100, duration=1) #移动鼠标到相对位置 pg.move(100, -100, duration=1) 2.获取鼠标位置的坐标值 # 获取鼠标位置的坐标值 mouse_x, mouse_y = pg.position() print(\u0026#34;鼠标位置的坐标值:\u0026#34;, mouse_x, mouse_y) #检测指定坐标是否在屏幕上 print(\u0026#34;(100, 100)坐标是否在屏幕上:\u0026#34;, pg.onScreen(100, 100)) 3.鼠标拖拽操作 #鼠标拖拽操作 #默认左键，左键 left，右键 right,中键 middle #绝对拖拽，指拖拽到那个位置 pg.dragTo(x=100, y=-100, duration=0.5, button=\u0026#39;left\u0026#39;) #相对拖拽，相对于当前位置拖拽 pg.drag(xOffset=100, yOffset=100, duration=0.5, button=\u0026#39;right\u0026#39;) 4.鼠标点击操作 #鼠标点击操作 #单击 #button:默认左键，左键 left，右键 right,中键 middle #clicks:点击次数，默认是1次 #interval:每次点击间隔时间，默认是0 #duration:持续时间，默认是0 pg.click(x=90, y=100,clicks=2,interval=0,duration=0, button=\u0026#39;left\u0026#39;) # 双击 #button:默认左键，左键 left，右键 right,中键 middle pg.doubleClick(x=90, y=100, duration=0, button=\u0026#39;left\u0026#39;) 5.鼠标单击分布操作 #单击分布操作 #按下鼠标键位 pg.mouseDown(button=\u0026#39;left\u0026#39;) #释放鼠标键位 pg.mouseUp(button=\u0026#39;left\u0026#39;) 五、键盘操作 1.输入字符 # 键盘操作 #输入字符 #messge:想要输入的字符 #interval:每次输入间隔时间，默认是0 #不能直接输入中文，需要使用unicode编码 #输入时应先使输入框获取焦点，否则无法输入（可以先单击一下） pg.write(\u0026#34;Hello, World!\u0026#34;,interval=0.2) 2.按键操作 #按键操作 #presses:按键的次数，默认是1次 #interval:每次按键间隔时间，默认是0 pg.press(\u0026#39;enter\u0026#39;,presses=2,interval=0.2) 3.热键操作（组合键） #热键操作 #interval:每次按键间隔时间，默认是0 pg.hotkey(\u0026#39;ctrl\u0026#39;,\u0026#39;a\u0026#39;,interval=0.2) 常用按键\n# 所有按键的字符串标识如下 print(pyautogui.KEYBOARD_KEYS) # 输出: [ \u0026#39;\\t\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;$\u0026#39;, \u0026#39;%\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#34;\u0026#39;\u0026#34;, \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;:\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;@\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;^\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;|\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;~\u0026#39;, \u0026#39;accept\u0026#39;, \u0026#39;add\u0026#39;, \u0026#39;alt\u0026#39;, \u0026#39;altleft\u0026#39;, \u0026#39;altright\u0026#39;, \u0026#39;apps\u0026#39;, \u0026#39;backspace\u0026#39;, \u0026#39;browserback\u0026#39;, \u0026#39;browserfavorites\u0026#39;, \u0026#39;browserforward\u0026#39;, \u0026#39;browserhome\u0026#39;, \u0026#39;browserrefresh\u0026#39;, \u0026#39;browsersearch\u0026#39;, \u0026#39;browserstop\u0026#39;, \u0026#39;capslock\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;convert\u0026#39;, \u0026#39;ctrl\u0026#39;, \u0026#39;ctrlleft\u0026#39;, \u0026#39;ctrlright\u0026#39;, \u0026#39;decimal\u0026#39;, \u0026#39;del\u0026#39;, \u0026#39;delete\u0026#39;, \u0026#39;divide\u0026#39;, \u0026#39;down\u0026#39;, \u0026#39;end\u0026#39;, \u0026#39;enter\u0026#39;, \u0026#39;esc\u0026#39;, \u0026#39;escape\u0026#39;, \u0026#39;execute\u0026#39;, \u0026#39;f1\u0026#39;, \u0026#39;f10\u0026#39;, \u0026#39;f11\u0026#39;, \u0026#39;f12\u0026#39;, \u0026#39;f13\u0026#39;, \u0026#39;f14\u0026#39;, \u0026#39;f15\u0026#39;, \u0026#39;f16\u0026#39;, \u0026#39;f17\u0026#39;, \u0026#39;f18\u0026#39;, \u0026#39;f19\u0026#39;, \u0026#39;f2\u0026#39;, \u0026#39;f20\u0026#39;, \u0026#39;f21\u0026#39;, \u0026#39;f22\u0026#39;, \u0026#39;f23\u0026#39;, \u0026#39;f24\u0026#39;, \u0026#39;f3\u0026#39;, \u0026#39;f4\u0026#39;, \u0026#39;f5\u0026#39;, \u0026#39;f6\u0026#39;, \u0026#39;f7\u0026#39;, \u0026#39;f8\u0026#39;, \u0026#39;f9\u0026#39;, \u0026#39;final\u0026#39;, \u0026#39;fn\u0026#39;, \u0026#39;hanguel\u0026#39;, \u0026#39;hangul\u0026#39;, \u0026#39;hanja\u0026#39;, \u0026#39;help\u0026#39;, \u0026#39;home\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;junja\u0026#39;, \u0026#39;kana\u0026#39;, \u0026#39;kanji\u0026#39;, \u0026#39;launchapp1\u0026#39;, \u0026#39;launchapp2\u0026#39;, \u0026#39;launchmail\u0026#39;, \u0026#39;launchmediaselect\u0026#39;, \u0026#39;left\u0026#39;, \u0026#39;modechange\u0026#39;, \u0026#39;multiply\u0026#39;, \u0026#39;nexttrack\u0026#39;, \u0026#39;nonconvert\u0026#39;, \u0026#39;num0\u0026#39;, \u0026#39;num1\u0026#39;, \u0026#39;num2\u0026#39;, \u0026#39;num3\u0026#39;, \u0026#39;num4\u0026#39;, \u0026#39;num5\u0026#39;, \u0026#39;num6\u0026#39;, \u0026#39;num7\u0026#39;, \u0026#39;num8\u0026#39;, \u0026#39;num9\u0026#39;, \u0026#39;numlock\u0026#39;, \u0026#39;pagedown\u0026#39;, \u0026#39;pageup\u0026#39;, \u0026#39;pause\u0026#39;, \u0026#39;pgdn\u0026#39;, \u0026#39;pgup\u0026#39;, \u0026#39;playpause\u0026#39;, \u0026#39;prevtrack\u0026#39;, \u0026#39;print\u0026#39;, \u0026#39;printscreen\u0026#39;, \u0026#39;prntscrn\u0026#39;, \u0026#39;prtsc\u0026#39;, \u0026#39;prtscr\u0026#39;, \u0026#39;return\u0026#39;, \u0026#39;right\u0026#39;, \u0026#39;scrolllock\u0026#39;, \u0026#39;select\u0026#39;, \u0026#39;separator\u0026#39;, \u0026#39;shift\u0026#39;, \u0026#39;shiftleft\u0026#39;, \u0026#39;shiftright\u0026#39;, \u0026#39;sleep\u0026#39;, \u0026#39;space\u0026#39;, \u0026#39;stop\u0026#39;, \u0026#39;subtract\u0026#39;, \u0026#39;tab\u0026#39;, \u0026#39;up\u0026#39;, \u0026#39;volumedown\u0026#39;, \u0026#39;volumemute\u0026#39;, \u0026#39;volumeup\u0026#39;, \u0026#39;win\u0026#39;, \u0026#39;winleft\u0026#39;, \u0026#39;winright\u0026#39;, \u0026#39;yen\u0026#39;, \u0026#39;command\u0026#39;, \u0026#39;option\u0026#39;, \u0026#39;optionleft\u0026#39;, \u0026#39;optionright\u0026#39; ] + \u0026#39;Add\u0026#39; - 加号键（\u0026#34;+\u0026#34;）通常用于添加或增加操作。 + \u0026#39;Alt\u0026#39; - 通常与键盘上的 \u0026#34;Alt\u0026#34; 键相对应，它是一种常用的快捷键，可以用于访问特殊功能或菜单。 + \u0026#39;Altleft\u0026#39; - 这个单词通常与键盘上的 \u0026#34;Alt\u0026#34; 键左边的部分相对应，也是用于访问特殊功能或菜单。 + \u0026#39;Altright\u0026#39; - 这个单词通常与键盘上的 \u0026#34;Alt\u0026#34; 键右边的部分相对应，也是用于访问特殊功能或菜单。 + \u0026#39;Apps\u0026#39; - 右键菜单 + \u0026#39;Backspace\u0026#39; - 这个单词通常与键盘上的 \u0026#34;Backspace\u0026#34; 键相对应，用于删除前一个字符或命令。 + \u0026#39;Browserback\u0026#39; - 这个单词通常与浏览器相关的快捷键相对应，用于返回浏览器的上一个页面。 + \u0026#39;Browserfavorites\u0026#39; - 这个单词通常与浏览器相关的快捷键相对应，用于访问浏览器的收藏夹。 + \u0026#39;Browserforward\u0026#39; - 这个单词通常与浏览器相关的快捷键相对应，用于前进到浏览器的一个页面。 + \u0026#39;Browserhome\u0026#39; - 这个单词通常与浏览器相关的快捷键相对应，用于导航到浏览器的首页。 + \u0026#39;Browserrefresh\u0026#39; - 这个单词通常与浏览器相关的快捷键相对应，用于刷新当前页面。 + \u0026#39;Browsersearch\u0026#39; - 这个单词通常与浏览器相关的快捷键相对应，用于在浏览器中执行搜索操作。 + \u0026#39;Browserstop\u0026#39; - 这个单词通常与浏览器相关的快捷键相对应，用于停止加载当前页面。 + \u0026#39;Capslock\u0026#39; - 这个单词通常与键盘上的 \u0026#34;Capslock\u0026#34; 键相对应，用于锁定或解锁大写字母输入。 + \u0026#39;Ctrl\u0026#39; - 这个单词通常与键盘上的 \u0026#34;Ctrl\u0026#34; 键相对应，用于执行各种控制命令或组合键操作。 + \u0026#39;Ctrlleft\u0026#39; - 这个单词通常与键盘上的 \u0026#34;Ctrl\u0026#34; 键左边的部分相对应，也是用于执行各种控制命令或组合键操作。 + \u0026#39;Ctrlright\u0026#39; - 这个单词通常与键盘上的 \u0026#34;Ctrl\u0026#34; 键右边的部分相对应，也是用于执行各种控制命令或组合键操作。 + \u0026#39;Decimal\u0026#39; - 这个单词通常与键盘上的 \u0026#34;Decimal\u0026#34; 或 \u0026#34;.\u0026#34; 键相对应，用于输入小数点或十进制数字。 + \u0026#39;fn\u0026#39; - \u0026#34;fn\u0026#34; 是一个特殊的键盘功能键，通常在笔记本电脑和一些特定的键盘布局中找到。它用于配合其他按键使用，以实现一些特定的功能，如调节亮度、音量等。 + \u0026#39;home\u0026#39; - \u0026#34;home\u0026#34; 对应的按键是键盘上的 \u0026#34;Home\u0026#34; 键，通常用于快速导航到页面的顶部或文本的开头。 + \u0026#39;insert\u0026#39; - \u0026#34;insert\u0026#34; 对应的按键是键盘上的 \u0026#34;Insert\u0026#34; 键，用于插入文本或数据。 + \u0026#39;left\u0026#39;, \u0026#39;right\u0026#39;, \u0026#39;up\u0026#39;, \u0026#39;down\u0026#39; - 这些方向键对应的按键分别是 \u0026#34;Left Arrow\u0026#34;、\u0026#34;Right Arrow\u0026#34;、\u0026#34;Up Arrow\u0026#34; 和 \u0026#34;Down Arrow\u0026#34;。它们通常用于控制光标的位置。 + \u0026#39;num0\u0026#39; 到 \u0026#39;num9\u0026#39; - 这些数字键对应的按键是从 \u0026#34;0\u0026#34; 到 \u0026#34;9\u0026#34;。它们用于输入数字和进行数学运算。 + \u0026#39;numlock\u0026#39;, \u0026#39;scrolllock\u0026#39;, \u0026#39;select\u0026#39;, \u0026#39;separator\u0026#39;, \u0026#39;tab\u0026#39; - 这些都是特殊的锁定键或其他功能键，通常用于控制光标移动、滚动页面、选择文本等操作。 + \u0026#39;space\u0026#39;, \u0026#39;return\u0026#39; - \u0026#34;Space\u0026#34; 键对应的按键是空格键，用于在文本中插入空格。\u0026#34;Return\u0026#34; 键对应的按键是回车键，用于换行或确认输入。 + \u0026#39;win\u0026#39;, \u0026#39;winleft\u0026#39;, \u0026#39;winright\u0026#39; - 这些是特定的功能键，通常用于操作系统中的窗口控制和菜单操作。\u0026#34;Win\u0026#34; 键对应的按键通常是 Windows 徽标键（通常是带有 Windows 标志的按键）。\u0026#34;Winleft\u0026#34; 和 \u0026#34;Winright\u0026#34; 是左右 Windows 功能键的称呼，但它们并不对应键盘上的标准按键 六，消息框 1.可以设置一个button #消息框 #title:标题 #text:文本 # button:按钮，默认是OK #返回值：默认是OK arr1 = pg.alert(title=\u0026#39;Hello, World!\u0026#39;,text=\u0026#39;没钱只能当牛马\u0026#39;,button=\u0026#39;ok\u0026#39;) print(arr1) 2.可以设置多个button #可以设置多个button #返回值：返回用户点击的按钮 arr2 = pg.confirm(title=\u0026#39;Hello, World!\u0026#39;,text=\u0026#39;没钱只能当牛马\u0026#39;,buttons=[\u0026#39;ok\u0026#39;,\u0026#39;cancel\u0026#39;]) print(arr2) 3.自带文本输入框的消息框 #自带文本输入框的消息框 #返回值：返回用户输入的内容 #文本输入框没字返回：None arr3=pg.prompt(title=\u0026#39;Hello, World!\u0026#39;,text=\u0026#39;没钱只能当牛马\u0026#39;,default=\u0026#39;请您输入：\u0026#39;) print(\u0026#34;您输入的内容是：\u0026#34;+arr3) 4.自带密码的文本输入框的消息框 #自带密码的文本输入框的消息框 #返回值：返回用户输入的密码 #密码没字返回：None arr4=pg.password(title=\u0026#39;Hello, World!\u0026#39;,text=\u0026#39;没钱只能当牛马\u0026#39;,default=\u0026#39;请您输入：\u0026#39;,mask=\u0026#39;*\u0026#39;) print(\u0026#34;您输入的密码是：\u0026#34;+arr4) 七、屏幕截图 1.截全屏 #屏幕截图 #imageformat:截图保存的格式，默认是png #region:截图的范围，默认是整个屏幕 # 截取全屏 在1920 x 1080屏幕上，screenshot（）函数大约需要100毫秒-不快但不慢。 # 截取全屏，并以图片保存 pg.screenshot(\u0026#34;E:\\\\pythonDemo\\\\python_2024\\\\all.png\u0026#34;) 2.指定区域内截屏 #指定区域内截屏 #region:截图的范围，默认是整个屏幕 : [开始位置x,开始位置y,x扩展的分辨率,y扩展的分辨率] pg.screenshot(\u0026#34;E:\\\\pythonDemo\\\\python_2024\\\\all2.png\u0026#34;,region=[100,100,500,500]) 3.图片定位 #图片定位 #定位到的图片的坐标（从左到右，从上到下） #image:图片路径 #confidence:定位精度，默认是0.8 #count:定位到的图片数量，默认是1 #返回图片中心点 pg.locateCenterOnScreen(\u0026#34;E:\\\\pythonDemo\\\\python_2024\\\\Google_tubiao.png\u0026#34;,confidence=0.1) 文章知识点与官方知识档案匹配，可进一步学习相关知识\n云原生入门技能树首页概览18885 人正在系统学习中\n本文转自 https://blog.csdn.net/Du_XiaoNan/article/details/136197235，如有侵权，请联系删除。\n","date":"July 5, 2024","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/helpdocs/python/%E6%8E%8C%E6%8F%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%8C%96pyautogui%E5%BA%93%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%E6%9C%80%E5%85%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%AF%8F%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%83%BD%E6%9C%89%E6%B3%A8%E9%87%8A%E5%B8%AE%E4%BD%A0%E8%A7%A3%E5%86%B3%E4%B8%8E%E4%B9%8B%E6%9C%89%E5%85%B3%E7%9A%84%E6%89%80%E6%9C%89%E9%97%AE%E9%A2%98-csdn%E5%8D%9A%E5%AE%A2/","series":[{"title":"HelpDocs","url":"/series/helpdocs/"}],"smallImg":"","tags":[{"title":"HelpDocs","url":"/tags/helpdocs/"},{"title":"Python","url":"/tags/python/"}],"timestamp":1720150487,"title":"掌握计算机自动化：PyAutoGUI库详细教程（最全使用方法，每行代码都有注释，帮你解决与之有关的所有问题）-CSDN博客"},{"authors":[],"categories":[],"content":"！被你找到了！！！\n这里其实是我实验各种交互效果的地方嘻嘻\n我的推特 我的博客 🎉 .\n.\n.\n.\n.\n","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/about/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"About"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Contact Us"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[{"title":"阳沐","url":"/authors/%E9%98%B3%E6%B2%90/"}],"categories":[{"title":"Annoucement","url":"/categories/annoucement/"}],"content":"Hi,这里是阳沐，经过紧锣密鼓的筹划之后落茜聚终于和大家见面啦！\n希望与你在2025年的夏天见面\n我和泰茜在落茜聚等你！\n","date":"January 1, 1","img":"/news/1/01/%E8%90%BD%E8%8C%9C%E8%81%9A/featured-sample.webp","lang":"en","langName":"English","largeImg":"/news/1/01/%E8%90%BD%E8%8C%9C%E8%81%9A/featured-sample_hu14422031441054246417.webp","permalink":"/news/1/01/%E8%90%BD%E8%8C%9C%E8%81%9A/","series":[{"title":"News","url":"/series/news/"}],"smallImg":"/news/1/01/%E8%90%BD%E8%8C%9C%E8%81%9A/featured-sample_hu719346528928233388.webp","tags":[{"title":"Furcon","url":"/tags/furcon/"}],"timestamp":-62135596800,"title":"落茜聚"}]
